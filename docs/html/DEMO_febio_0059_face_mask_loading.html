
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>DEMO_febio_0059_face_mask_loading</title><meta name="generator" content="MATLAB 9.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-04-27"><meta name="DC.source" content="DEMO_febio_0059_face_mask_loading.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>DEMO_febio_0059_face_mask_loading</h1><!--introduction--><p>Below is a demonstration for:</p><div><ul><li>Building triangulated surface geometry for a face</li><li>Meshing the face using pentahedral elements</li><li>Building model of a tube</li><li>Defining the boundary conditions</li><li>Coding the febio structure</li><li>Running the model</li><li>Importing and visualizing results</li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Keywords</a></li><li><a href="#4">Control parameters</a></li><li><a href="#5">Load face geometry</a></li><li><a href="#6">Remeshing surface</a></li><li><a href="#10">Centre on nose and rotate to face face looking down Z-axis</a></li><li><a href="#12">Construct mask rim curve</a></li><li><a href="#34">Join and merge rim surfaces</a></li><li><a href="#38">Join and merge mask body components</a></li><li><a href="#47">Join node sets</a></li><li><a href="#49">Define contact surfaces</a></li><li><a href="#51">Define boundary conditions</a></li><li><a href="#53">Defining the FEBio input structure</a></li><li><a href="#54">Quick viewing of the FEBio input file structure</a></li><li><a href="#56">Exporting the FEBio input file</a></li><li><a href="#57">Running the FEBio analysis</a></li><li><a href="#58">Import FEBio results</a></li></ul></div><h2 id="1">Keywords</h2><div><ul><li>febio_spec version 4.0</li><li>febio, FEBio</li><li>face</li><li>contact, sliding, friction</li><li>pentahedral elements, penta6</li><li>static, solid</li><li>hyperelastic, Ogden</li><li>displacement logfile</li></ul></div><pre class="codeinput">clear; close <span class="string">all</span>; clc;
</pre><p>Plot settings</p><pre class="codeinput">fontSize=15;
faceAlpha1=1;
faceAlpha2=0.3;
markerSize1=15;
markerSize2=10;
lineWidth=2;
cMap=spectral(250);
</pre><h2 id="4">Control parameters</h2><pre class="codeinput"><span class="comment">% Path names</span>
defaultFolder = fileparts(fileparts(mfilename(<span class="string">'fullpath'</span>)));
savePath=fullfile(defaultFolder,<span class="string">'data'</span>,<span class="string">'temp'</span>);

<span class="comment">% Defining file names</span>
febioFebFileNamePart=<span class="string">'tempModel'</span>;
febioFebFileName=fullfile(savePath,[febioFebFileNamePart,<span class="string">'.feb'</span>]); <span class="comment">%FEB file name</span>
febioLogFileName=fullfile(savePath,[febioFebFileNamePart,<span class="string">'.txt'</span>]); <span class="comment">%FEBio log file name</span>
febioLogFileName_disp=[febioFebFileNamePart,<span class="string">'_disp_out.txt'</span>]; <span class="comment">%Log file name for exporting displacement</span>
febioLogFileName_force=[febioFebFileNamePart,<span class="string">'_force_out.txt'</span>]; <span class="comment">%Log file name for exporting force</span>
febioLogFileName_strainEnergy=[febioFebFileNamePart,<span class="string">'_energy_out.txt'</span>]; <span class="comment">%Log file name for exporting strain energy density</span>

<span class="comment">% Geometry parameters</span>
pointSpacingTissue=6;
faceTissueThickness=6;
pointSpacingMask=pointSpacingTissue/2;
maskRimWidth=5;
maskRimFilletRadius=6;
maskDiscRadius1=25;
maskDiscRadius2=maskDiscRadius1+4;
maskDiscOffset=25;
bezierTangency=0.1;

distInclude=40; <span class="comment">%Distance from mask to include face in FEA</span>

<span class="comment">%Ray tracing parameters</span>
optionStructRayTrace.tolEps        = 1e-6;
optionStructRayTrace.triSide       = 0;
optionStructRayTrace.rayType       = <span class="string">'ray'</span>;
optionStructRayTrace.exclusionType = <span class="string">'inclusive'</span>;
optionStructRayTrace.paired        = 0;

<span class="comment">%Material parameters</span>
c1_tissue=1e-3; <span class="comment">%Shear-modulus-like parameter</span>
m1_tissue=2; <span class="comment">%Material parameter setting degree of non-linearity</span>
k_tissue=c1_tissue*100; <span class="comment">%Bulk modulus</span>

c1_rim=c1_tissue*5; <span class="comment">%Shear-modulus-like parameter</span>
m1_rim=2; <span class="comment">%Material parameter setting degree of non-linearity</span>
k_rim=c1_rim*10; <span class="comment">%Bulk modulus</span>

<span class="comment">% FEA control settings</span>
numTimeSteps=15; <span class="comment">%Number of time steps desired</span>
max_refs=35; <span class="comment">%Max reforms</span>
max_ups=0; <span class="comment">%Set to zero to use full-Newton iterations</span>
opt_iter=10; <span class="comment">%Optimum number of iterations</span>
max_retries=5; <span class="comment">%Maximum number of retires</span>
dtmin=(1/numTimeSteps)/100; <span class="comment">%Minimum time step size</span>
dtmax=(1/numTimeSteps); <span class="comment">%Maximum time step size</span>
symmetric_stiffness=0;
min_residual=1e-20;
runMode=<span class="string">'external'</span>;

<span class="comment">%Boundary condition parameters</span>
initialOffset=0;
displacementMagnitude_z=-2-initialOffset; <span class="comment">%Displacement applied</span>

<span class="comment">%Contact parameters</span>
contactPenalty=10;
laugon=0;
minaug=1;
maxaug=10;
fric_coeff=0.5;
</pre><h2 id="5">Load face geometry</h2><pre class="codeinput">testCase=1;
<span class="keyword">switch</span> testCase
    <span class="keyword">case</span> 1
        <span class="comment">%Load surface model</span>
        [Ff,Vf]=graphicsModels(9);

        <span class="comment">%Surface markers</span>
        V_markers=[65.51,49.94,217.14;<span class="keyword">...</span><span class="comment"> %Tip of the nose</span>
            66.44,54.79,259.81;<span class="keyword">...</span><span class="comment"> %Nose between eyes</span>
            53.81,115,263.39;<span class="keyword">...</span><span class="comment"> %Right eye outer corner</span>
            126.5,46.62,269.75;<span class="keyword">...</span><span class="comment"> %Left eye outer corner</span>
            85.67,69.44,194.1;<span class="keyword">...</span><span class="comment"> %Middle of mounth</span>
            98.39,80.38,158]; <span class="comment">%Bottom of chin</span>
    <span class="keyword">case</span> 2
        <span class="comment">%Load surface model</span>
        [Ff,Vf]=graphicsModels(13);

        <span class="comment">%Surface markers</span>
        V_markers=[3.50162,-181.107,-8.09110;<span class="keyword">...</span><span class="comment">  %Tip of the nose</span>
                   1.51627,-159.171,30.4679;<span class="keyword">...</span><span class="comment"> %Nose between eyes</span>
                   -43.2473,-139.003,24.6407;<span class="keyword">...</span><span class="comment"> %Right eye outer corner</span>
                   48.4245,-136.490,25.3913;<span class="keyword">...</span><span class="comment"> %Left eye outer corner</span>
                   4.11905,-167.594,-36.9600;<span class="keyword">...</span><span class="comment"> %Middle of mounth</span>
                   2.85290,-161.802,-73.4644]; <span class="comment">%Bottom of chin</span>
<span class="keyword">end</span>

distEyes=sqrt(sum((V_markers(3,:)-V_markers(4,:)).^2,2));
</pre><h2 id="6">Remeshing surface</h2><pre class="codeinput">optionStruct_remesh.pointSpacing=pointSpacingTissue; <span class="comment">%Set desired point spacing</span>
optionStruct_remesh.disp_on=0; <span class="comment">% Turn off command window text display</span>
[Ff,Vf]=ggremesh(Ff,Vf,optionStruct_remesh);
</pre><pre class="codeinput">ny=vecnormalize(V_markers(2,:)-V_markers(6,:));
nx=vecnormalize(V_markers(4,:)-V_markers(3,:));
nz=vecnormalize(cross(nx,ny));
nx=vecnormalize(cross(ny,nz));

Q=[nx;ny;nz]';
</pre><pre class="codeinput"><span class="comment">% cFigure; hold on;</span>
<span class="comment">% gpatch(Ff,Vf,'w','none',1);</span>
<span class="comment">% % plotV(V_markers,'r.','MarkerSize',35);</span>
<span class="comment">% % text(V_markers(:,1)+4,V_markers(:,2),V_markers(:,3),{'1','2','3','4','5','6'},'FontSize',25);</span>
<span class="comment">% % quiverTriad(V_markers(1,:),Q,100);</span>
<span class="comment">% axisGeom; camlight headlight;</span>
<span class="comment">% colormap(spectral(250))</span>
<span class="comment">% gdrawnow;</span>
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
gpatch(Ff,Vf,<span class="string">'w'</span>,<span class="string">'none'</span>,0.5);
plotV(V_markers,<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,35);
text(V_markers(:,1)+4,V_markers(:,2),V_markers(:,3),{<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>},<span class="string">'FontSize'</span>,25);
quiverTriad(V_markers(1,:),Q,100);
axisGeom; camlight <span class="string">headlight</span>;
colormap(spectral(250))
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_01.jpg" alt=""> <h2 id="10">Centre on nose and rotate to face face looking down Z-axis</h2><pre class="codeinput">Vf=Vf-V_markers(1,:);
Vf=Vf*Q;
V_markers=V_markers-V_markers(1,:);
V_markers=V_markers*Q;
nz=[0 0 1];<span class="comment">%nz*Q;</span>
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
gpatch(Ff,Vf,<span class="string">'w'</span>,<span class="string">'none'</span>,0.5);
plotV(V_markers,<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,35);
text(V_markers(:,1)+6,V_markers(:,2),V_markers(:,3)+15,{<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>},<span class="string">'FontSize'</span>,25);
axisGeom; camlight <span class="string">headlight</span>;
colormap(spectral(250))
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_02.jpg" alt=""> <h2 id="12">Construct mask rim curve</h2><pre class="codeinput">V1=V_markers(1,[1 2]);
V2=V_markers(2,[1 2]);
V3=V_markers(3,[1 2]);
V4=V_markers(4,[1 2]);
V5=V_markers(5,[1 2]);
V6=V_markers(6,[1 2]);

pp1=0.4*V1+0.6*V2;
pp2=0.6*V1+0.4*V3;
pp3=V3-[0 V3(2)]+[0 0.5*V5(2)+0.5*V1(2)];
pp4=[0.3*V2(1)+0.8*V3(1) 0.5*V5(2)+0.5*V6(2)];
pp5=V6;
pp6=[0.3*V2(1)+0.8*V4(1) 0.5*V5(2)+0.5*V6(2)];
pp7=V4-[0 V4(2)]+[0 0.5*V5(2)+0.5*V1(2)];
pp8=0.6*V1+0.4*V4;

V_rim_points=[pp1;pp2;pp3;pp4;pp5;pp6;pp7;pp8];
V_rim_points(:,3)=0;

[V_rim_points,indFaceIntersect]=traceToSurf(V_rim_points,-nz,Ff,Vf,optionStructRayTrace);
numRimControlPoints=size(V_rim_points,1);

V_rim_curve=evenlySpaceCurve(V_rim_points,pointSpacingMask,<span class="string">'pchip'</span>,1);
V_rim_curve=traceToSurf(V_rim_curve,-nz,Ff,Vf,optionStructRayTrace);
numPointsRimCurve=size(V_rim_curve,1);


Ne1=vecnormalize([V_rim_points(2:end,:); V_rim_points(1,:)]-V_rim_points(1:end,:));
Ne2=vecnormalize(V_rim_points - [V_rim_points(end,:); V_rim_points(1:end-1,:)]);
Ne=vecnormalize(0.5*Ne1+0.5*Ne2);

Nf=patchNormal(Ff,Vf); <span class="comment">%Normal directions</span>
Nff=Nf(indFaceIntersect(:,2),:);
N_rim_points=vecnormalize(cross(Nff,Ne));

V_rim_points1=V_rim_points-N_rim_points.*maskRimWidth/2;
V_rim_points2=V_rim_points+N_rim_points.*maskRimWidth/2;
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
gpatch(Ff,Vf,<span class="string">'w'</span>,<span class="string">'none'</span>,0.5);
plotV(V_markers,<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,25);
text(V_markers(:,1)+4,V_markers(:,2),V_markers(:,3),{<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>},<span class="string">'FontSize'</span>,25);

plotV(V_rim_points,<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,25);
plotV(V_rim_points1,<span class="string">'b.'</span>,<span class="string">'MarkerSize'</span>,25);
plotV(V_rim_points2,<span class="string">'g.'</span>,<span class="string">'MarkerSize'</span>,25);

quiverVec(V_rim_points,N_rim_points,maskRimWidth/2,<span class="string">'y'</span>);
quiverVec(V_rim_points,-N_rim_points,maskRimWidth/2,<span class="string">'y'</span>);
axisGeom; camlight <span class="string">headlight</span>;
view(2);
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_03.jpg" alt=""> <pre class="codeinput">[~,indClose]=minDist(V_markers,Vf);
d=meshDistMarch(Ff,Vf,indClose([1 5]));

[~,indClose]=minDist(V_rim_curve,Vf);
d_rim_curve=meshDistMarch(Ff,Vf,indClose);
d_markers_max=max(d(indClose));

logicCloseVertices= d&lt;=d_markers_max | d_rim_curve&lt;distInclude;

logicCloseFaces= any(logicCloseVertices(Ff),2);
logicCloseFaces=triSurfLogicSharpFix(Ff,logicCloseFaces);

[Fs,Vs]=patchCleanUnused(Ff(logicCloseFaces,:),Vf);

ns=vecnormalize(mean(patchNormal(Fs,Vs)));

[Q]=pointSetPrincipalDir(Vs);
nz=Q(:,3)';
<span class="keyword">if</span> dot(nz,ns)&lt;1
    nz=-nz;
<span class="keyword">end</span>

ny=vecnormalize(V_markers(2,:)-V_markers(1,:));
nx=cross(ny,nz);
ny=cross(nz,nx);
Q=[nx;ny;nz]';

Ffc=Ff(~logicCloseFaces,:);
</pre><pre class="codeinput">cFigure;  hold <span class="string">on</span>;
gpatch(Ff,Vf,d,<span class="string">'k'</span>,0.5);
gpatch(Ff(logicCloseFaces,:),Vf,<span class="string">'none'</span>,<span class="string">'b'</span>,1,2);
plotV(V_markers,<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,25);
plotV(V_rim_points,<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,15);
plotV(V_rim_curve,<span class="string">'k-'</span>,<span class="string">'LineWidth'</span>,3);

axisGeom; camlight <span class="string">headlight</span>;
colormap(spectral(250))
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_04.jpg" alt=""> <pre class="codeinput">cFigure;  hold <span class="string">on</span>;
gpatch(Ff,Vf,<span class="string">'w'</span>,<span class="string">'none'</span>,0.5);
<span class="comment">% gpatch(Ff(logicCloseFaces,:),Vf,'none','b',1,2);</span>
plotV(V_markers,<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,25);
plotV(V_rim_points,<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,15);
plotV(V_rim_curve,<span class="string">'k-'</span>,<span class="string">'LineWidth'</span>,3);

axisGeom; camlight <span class="string">headlight</span>;
colormap(spectral(250))
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_05.jpg" alt=""> <pre class="codeinput">cFigure;  hold <span class="string">on</span>;
gpatch(Ff,Vf,<span class="string">'w'</span>,<span class="string">'none'</span>);
gpatch(Fs,Vs,<span class="string">'w'</span>,<span class="string">'b'</span>);
<span class="comment">% patchNormPlot(Fs,Vs);</span>
plotV(V_markers,<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,25);
<span class="comment">% quiverTriad(V_markers(1,:),Q,50);</span>
axisGeom;
camlight <span class="string">headlight</span>;
<span class="comment">% colormap(viridis(2)); icolorbar;</span>
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_06.jpg" alt=""> <pre class="codeinput">Ebs=patchBoundary(Fs);
indBoundaryCurve=edgeListToCurve(Ebs);
indBoundaryCurve=indBoundaryCurve(1:end-1)';

[~,~,Ns]=patchNormal(Fs,Vs);

Vs2=Vs-Ns*faceTissueThickness;
Fs2=Fs;

Vsc=Vs2(indBoundaryCurve,:);<span class="comment">%-Ns(indBoundaryCurve,:)*layerThickness;</span>
[Fs2t,Vs2t]=regionTriMesh3D({Vsc},pointSpacingMask,0,<span class="string">'natural'</span>);
Vs2t_ori=Vs2t;
indBoundary=unique(patchBoundary(Fs2t));

[~,indMap]=minDist(Vsc,Vs2t(indBoundary,:));
indBoundaryCurve_2t=indBoundary(indMap);
indBoundaryCurve_2t=indBoundaryCurve_2t(:);

Vs2t=traceToSurf(Vs2t,-nz,Fs2,Vs2,optionStructRayTrace);

cParSmooth.n=3;
cParSmooth.Method=<span class="string">'HC'</span>;
cParSmooth.RigidConstraints=indBoundaryCurve_2t;
Vs2t=patchSmooth(Fs2t,Vs2t,[],cParSmooth);

numNodesThickness=ceil(faceTissueThickness./pointSpacingTissue);
<span class="keyword">if</span> numNodesThickness&lt;2
    numNodesThickness=2;
<span class="keyword">end</span>

cParLoft.numSteps=numNodesThickness;
cParLoft.closeLoopOpt=1;
cParLoft.patchType=<span class="string">'tri'</span>;
[Fss,Vss,ind1,ind2]=polyLoftLinear(Vs(indBoundaryCurve,:),Vs2t(indBoundaryCurve_2t,:),cParLoft);

[Fb,Vb,Cb]=joinElementSets({Fs,Fs2t,Fss},{Vs,Vs2t,Vss});
[Fb,Vb]=mergeVertices(Fb,Vb);
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
gpatch(Ffc,Vf,<span class="string">'w'</span>,<span class="string">'none'</span>,0.5);
gpatch(Fb,Vb,Cb,<span class="string">'k'</span>,0.5);

<span class="comment">% gpatch(Fs,Vs,'bw','k',1);</span>
<span class="comment">% % gpatch(Fs2t,Vs2t_ori,'gw','g',0.5);</span>
<span class="comment">% gpatch(Fs2t,Vs2t,'rw','k',1);</span>
<span class="comment">% gpatch(Fss,Vss,'gw','k',1);</span>

<span class="comment">% patchNormPlot(Fb,Vb);</span>
axisGeom; camlight <span class="string">headlight</span>;
colormap(spectral); icolorbar;
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_07.jpg" alt=""> <p>Get inner mesh point between top and bottom at nose</p><pre class="codeinput">Pn=triSurfRayTrace(V_markers(1,:),-nz,Fb,Vb,optionStructRayTrace);
Pn=mean(Pn,1);
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
<span class="comment">%gpatch(Ffc,Vf,'w','none',0.5);</span>
gpatch(Fb,Vb,Cb,<span class="string">'k'</span>,1);
plotV(Pn,<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,25);

<span class="comment">% patchNormPlot(Fb,Vb);</span>
axisGeom; camlight <span class="string">headlight</span>;
colormap(spectral); icolorbar;
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_08.jpg" alt=""> <pre class="codeinput"><span class="comment">%Create tetgen input structure</span>
inputStruct.stringOpt=<span class="string">'-pq1.2AaY'</span>; <span class="comment">%Options for tetgen</span>
inputStruct.Faces=Fb; <span class="comment">%Boundary faces</span>
inputStruct.Nodes=Vb; <span class="comment">%Nodes of boundary</span>
inputStruct.faceBoundaryMarker=Cb;
inputStruct.regionPoints=Pn; <span class="comment">%Interior points for regions</span>
inputStruct.holePoints=[]; <span class="comment">%Interior points for holes</span>
inputStruct.regionA=tetVolMeanEst(Fb,Vb); <span class="comment">%Desired tetrahedral volume for each region</span>

<span class="comment">% Mesh model using tetrahedral elements using tetGen</span>
[meshOutput]=runTetGen(inputStruct); <span class="comment">%Run tetGen</span>
</pre><pre class="codeoutput"> 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- TETGEN Tetrahedral meshing --- 27-Apr-2023 16:34:14
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- Writing SMESH file --- 27-Apr-2023 16:34:14
----&gt; Adding node field
----&gt; Adding facet field
----&gt; Adding holes specification
----&gt; Adding region specification
--- Done --- 27-Apr-2023 16:34:14
--- Running TetGen to mesh input boundary--- 27-Apr-2023 16:34:14
Opening /mnt/data/MATLAB/GIBBON/data/temp/temp.smesh.
Delaunizing vertices...
Delaunay seconds:  0.013751
Creating surface mesh ...
Surface mesh seconds:  0.004709
Recovering boundaries...
Boundary recovery seconds:  0.008599
Removing exterior tetrahedra ...
Spreading region attributes.
Exterior tets removal seconds:  0.004921
Recovering Delaunayness...
Delaunay recovery seconds:  0.00424
Refining mesh...
  4040 insertions, added 280 points, 9506 tetrahedra in queue.
  1345 insertions, added 66 points, 8189 tetrahedra in queue.
  1793 insertions, added 56 points, 4853 tetrahedra in queue.
  2390 insertions, added 91 points, 794 tetrahedra in queue.
  3186 insertions, added 217 points, 6087 tetrahedra in queue.
  4247 insertions, added 253 points, 1635 tetrahedra in queue.
Refinement seconds:  0.148259
Smoothing vertices...
Mesh smoothing seconds:  0.046542
Improving mesh...
Mesh improvement seconds:  0.003576

Writing /mnt/data/MATLAB/GIBBON/data/temp/temp.1.node.
Writing /mnt/data/MATLAB/GIBBON/data/temp/temp.1.ele.
Writing /mnt/data/MATLAB/GIBBON/data/temp/temp.1.face.
Writing /mnt/data/MATLAB/GIBBON/data/temp/temp.1.edge.

Output seconds:  0.046706
Total running seconds:  0.281613

Statistics:

  Input points: 3031
  Input facets: 6058
  Input segments: 9087
  Input holes: 0
  Input regions: 1

  Mesh points: 4217
  Mesh tetrahedra: 16411
  Mesh faces: 35851
  Mesh faces on exterior boundary: 6058
  Mesh faces on input facets: 6058
  Mesh edges on input segments: 9087
  Steiner points inside domain: 1186

--- Done --- 27-Apr-2023 16:34:15
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- Importing TetGen files --- 27-Apr-2023 16:34:15
--- Done --- 27-Apr-2023 16:34:15
</pre><p>Access mesh output structure</p><pre class="codeinput">E_face=meshOutput.elements; <span class="comment">%The elements</span>
V=meshOutput.nodes; <span class="comment">%The vertices or nodes</span>
F=meshOutput.faces; <span class="comment">%Element faces (all)</span>
CE=meshOutput.elementMaterialID; <span class="comment">%Element material or region id</span>
Fb=meshOutput.facesBoundary; <span class="comment">%The boundary faces</span>
Cb=meshOutput.boundaryMarker; <span class="comment">%The boundary markers</span>
</pre><p>Visualization</p><pre class="codeinput">hf=cFigure;
subplot(1,2,1); hold <span class="string">on</span>;
title(<span class="string">'Input boundaries'</span>,<span class="string">'FontSize'</span>,fontSize);
hp(1)=gpatch(Fb,V,Cb,<span class="string">'k'</span>,faceAlpha1);
hp(2)=plotV(Pn,<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,markerSize1);
legend(hp,{<span class="string">'Input mesh'</span>,<span class="string">'Interior point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'NorthWestOutside'</span>);
axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;
colormap(cMap); icolorbar;

hs=subplot(1,2,2); hold <span class="string">on</span>;
title(<span class="string">'Tetrahedral mesh'</span>,<span class="string">'FontSize'</span>,fontSize);

<span class="comment">% Visualizing using |meshView|</span>
optionStruct.hFig=[hf,hs];

meshView(meshOutput,optionStruct);
hold <span class="string">on</span>; plotV(Pn,<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,25);
axisGeom(gca,fontSize);
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_09.jpg" alt=""> <pre class="codeinput">pp9=V_markers(5,:);<span class="comment">% (0.1*V_markers(1,:)+0.9*V_markers(5,:));</span>

t=linspace(0.5*pi,2.5*pi,numPointsRimCurve+1)';
t=t(1:end-1);
Vcd1=maskDiscRadius1*[cos(t) sin(t) zeros(size(t))];
Vcd1=Vcd1+pp9;
Vcd1(:,3)=maskDiscOffset;

Vcd2=maskDiscRadius2*[cos(t) sin(t) zeros(size(t))];
Vcd2=Vcd2+pp9;
Vcd2(:,3)=maskDiscOffset;

<span class="comment">%</span>
cFigure; hold <span class="string">on</span>;
gpatch(Fb,V,<span class="string">'w'</span>,<span class="string">'none'</span>,0.5);
plotV(V_markers,<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,50);
text(V_markers(:,1)+4,V_markers(:,2),V_markers(:,3)+10,{<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>},<span class="string">'FontSize'</span>,25);

plotV(V_rim_points,<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,35);
plotV(V_rim_curve,<span class="string">'k-'</span>,<span class="string">'LineWidth'</span>,6);
plotV(Vcd1,<span class="string">'b-'</span>,<span class="string">'LineWidth'</span>,6);
plotV(Vcd2,<span class="string">'b-'</span>,<span class="string">'LineWidth'</span>,6);
axisGeom;
camlight <span class="string">headlight</span>;
view(2);
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_10.jpg" alt=""> <pre class="codeinput">V_rim_curve1=evenlySampleCurve(V_rim_points1,numPointsRimCurve,<span class="string">'pchip'</span>,1);
V_rim_curve2=evenlySampleCurve(V_rim_points2,numPointsRimCurve,<span class="string">'pchip'</span>,1);

V_rim_curve1=traceToSurf(V_rim_curve1,[0 0 -1],Fb(Cb==1,:),V,optionStructRayTrace);
V_rim_curve2=traceToSurf(V_rim_curve2,[0 0 -1],Fb(Cb==1,:),V,optionStructRayTrace);
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
gpatch(Fb(Cb==1,:),Vb,<span class="string">'kw'</span>,<span class="string">'none'</span>,0.5);

<span class="comment">% patchNormPlot(Fm,Vm);</span>
plotV(V_markers,<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,50);
text(V_markers(:,1)+2,V_markers(:,2),V_markers(:,3),{<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>},<span class="string">'FontSize'</span>,25);
plotV(V_rim_points,<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,35,<span class="string">'LineWidth'</span>,3);
plotV(V_rim_curve,<span class="string">'k-'</span>,<span class="string">'LineWidth'</span>,3);

plotV(V_rim_points1,<span class="string">'g.'</span>,<span class="string">'MarkerSize'</span>,35,<span class="string">'LineWidth'</span>,3);
plotV(V_rim_curve1,<span class="string">'g-'</span>,<span class="string">'LineWidth'</span>,3);

plotV(V_rim_points2,<span class="string">'b.'</span>,<span class="string">'MarkerSize'</span>,35,<span class="string">'LineWidth'</span>,3);
plotV(V_rim_curve2,<span class="string">'b-'</span>,<span class="string">'LineWidth'</span>,3);

axisGeom; camlight <span class="string">headlight</span>;
view(2);
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_11.jpg" alt=""> <pre class="codeinput">pointSpacingNow=mean(diff(pathLength(V_rim_curve1)));
numNodStrip=ceil(maskRimWidth./pointSpacingNow);
<span class="keyword">if</span> numNodStrip&lt;2
    numNodStrip=2;
<span class="keyword">end</span>
<span class="keyword">if</span> iseven(numNodStrip)
    numNodStrip=numNodStrip+1;
<span class="keyword">end</span>

cParLoft.numSteps=numNodStrip;
cParLoft.closeLoopOpt=1;
cParLoft.patchType=<span class="string">'tri'</span>;
[Fm,Vm,indStart_Vm,indEnd_Vm]=polyLoftLinear(V_rim_curve1,V_rim_curve2,cParLoft);
Fm=fliplr(Fm);
indStart_Vm=fliplr(indStart_Vm);
indEnd_Vm=fliplr(indEnd_Vm);

[~,~,Nm]=patchNormal(Fm,Vm);
Vm=traceToSurf(Vm,Nm,Fb(Cb==1,:),V,optionStructRayTrace);
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
gpatch(Fb(Cb==1,:),Vb,<span class="string">'kw'</span>,<span class="string">'none'</span>,0.5);
gpatch(Fm,Vm,<span class="string">'rw'</span>,<span class="string">'k'</span>,1,1);
<span class="comment">% patchNormPlot(Fm,Vm);</span>
<span class="comment">% plotV(V_markers,'r.','MarkerSize',50);</span>
<span class="comment">% text(V_markers(:,1)+4,V_markers(:,2),V_markers(:,3),{'1','2','3','4','5','6'},'FontSize',25);</span>
plotV(V_rim_points,<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,35,<span class="string">'LineWidth'</span>,3);
plotV(Vm(indStart_Vm,:),<span class="string">'g-'</span>,<span class="string">'LineWidth'</span>,3);
plotV(Vm(indEnd_Vm,:),<span class="string">'b-'</span>,<span class="string">'LineWidth'</span>,3);
axisGeom; camlight <span class="string">headlight</span>;
view(2);
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_12.jpg" alt=""> <pre class="codeinput">[~,~,Nm]=patchNormal(Fm,Vm);

pointSpacingNow=mean(diff(pathLength(Vm(indStart_Vm,:))));
nRim=ceil((pi/2*maskRimFilletRadius)/pointSpacingNow)+1;
<span class="keyword">if</span> nRim&lt;4
    nRim=4;
<span class="keyword">end</span>

[Fr1,Vr1]=roundMesh(indStart_Vm,Vm,Nm,nRim,maskRimFilletRadius);
[Fr2,Vr2]=roundMesh(indEnd_Vm,Vm,Nm,nRim,maskRimFilletRadius);
indEnd_Vr1=size(Vr1)-numPointsRimCurve+1:1:size(Vr1);
indEnd_Vr2=fliplr(indEnd_Vr1);
[Fr1,Vr1]=quad2tri(Fr1,Vr1,<span class="string">'a'</span>);
[Fr2,Vr2]=quad2tri(Fr2,Vr2,<span class="string">'a'</span>);
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
gpatch(Fb,V,<span class="string">'kw'</span>,<span class="string">'none'</span>,0.5);
gpatch(Fm,Vm,<span class="string">'rw'</span>,<span class="string">'k'</span>,1,1);
gpatch(Fr1,Vr1,<span class="string">'gw'</span>,<span class="string">'k'</span>,1,1);
gpatch(Fr2,Vr2,<span class="string">'bw'</span>,<span class="string">'k'</span>,1,1);
plotV(Vr1(indEnd_Vr1,:),<span class="string">'r-'</span>,<span class="string">'LineWidth'</span>,3);
plotV(Vr2(indEnd_Vr2,:),<span class="string">'b-'</span>,<span class="string">'LineWidth'</span>,3);
axisGeom; camlight <span class="string">headlight</span>;
view(2);
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_13.jpg" alt=""> <pre class="codeinput">pointSpacingNow=mean(diff(pathLength(Vr1(indEnd_Vr1,:))));
numNodStripTop=ceil((maskRimWidth+2*maskRimFilletRadius)./pointSpacingNow);
<span class="keyword">if</span> numNodStripTop&lt;2
    numNodStripTop=2;
<span class="keyword">end</span>
<span class="keyword">if</span> iseven(numNodStripTop)
    numNodStripTop=numNodStripTop+1;
<span class="keyword">end</span>

cParLoft.numSteps=numNodStripTop;
cParLoft.closeLoopOpt=1;
cParLoft.patchType=<span class="string">'tri'</span>;
[Ft,Vt,indCurve1_Vt,indCurve2_Vt]=polyLoftLinear(Vr1(indEnd_Vr1,:),Vr2(indEnd_Vr2,:),cParLoft);
Ft=fliplr(Ft);
indCurve1_Vt=flipud(indCurve1_Vt(:));
<span class="comment">% indCurve2_Vt=flipud(indCurve2_Vt(:));</span>
[~,~,Nt]=patchNormal(Ft,Vt);
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
gpatch(Fb,V,<span class="string">'w'</span>,<span class="string">'none'</span>,1);
gpatch(Fm,Vm,<span class="string">'y'</span>,<span class="string">'k'</span>,0,1);
gpatch(Ft,Vt,<span class="string">'gw'</span>,<span class="string">'k'</span>,1,1);
gpatch(Fr1,Vr1,<span class="string">'rw'</span>,<span class="string">'k'</span>,1,1);
gpatch(Fr2,Vr2,<span class="string">'bw'</span>,<span class="string">'k'</span>,1,1);
plotV(Vr1(indEnd_Vr1,:),<span class="string">'r-'</span>,<span class="string">'LineWidth'</span>,3);
plotV(Vr2(indEnd_Vr1,:),<span class="string">'b-'</span>,<span class="string">'LineWidth'</span>,3);
axisGeom; camlight <span class="string">headlight</span>;
view(2);
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_14.jpg" alt=""> <h2 id="34">Join and merge rim surfaces</h2><pre class="codeinput">[F_rim,V_rim,C_rim]=joinElementSets({Fm,Fr1,Fr2,Ft},{Vm,Vr1,Vr2,Vt});
[F_rim,V_rim]=mergeVertices(F_rim,V_rim);
[F_rim,V_rim]=patchCleanUnused(F_rim,V_rim);
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
gpatch(Fb(Cb==1,:),V,<span class="string">'w'</span>,<span class="string">'none'</span>,1);
gpatch(F_rim,V_rim,C_rim,<span class="string">'none'</span>,1);
<span class="comment">% patchNormPlot(F_rim,V_rim);</span>
axisGeom; camlight <span class="string">headlight</span>;
colormap <span class="string">spectral</span>; icolorbar;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_15.jpg" alt=""> <pre class="codeinput">V_loft1=Vt(indCurve1_Vt,:);
V_loft2=Vcd2;

V_loft3=Vt(indCurve2_Vt,:);
V_loft4=Vcd1;

[~,indMax]=max(V_loft4(:,1));
<span class="keyword">if</span> indMax&lt;numPointsRimCurve/2
    V_loft4=flipud(V_loft4);
<span class="keyword">end</span>

[~,indMax]=max(V_loft2(:,1));
<span class="keyword">if</span> indMax&lt;numPointsRimCurve/2
    V_loft2=flipud(V_loft2);
<span class="keyword">end</span>

N1=Nt(indCurve1_Vt,:);
N3=Nt(indCurve2_Vt,:);
N4=ones(size(V_loft4,1),1)*[0 0 1];

N2e=vecnormalize([V_loft2(2:end,:); V_loft2(1,:)]-V_loft2(1:end,:));
N2=vecnormalize(cross(N4,N2e));

[Fd1,Vd1,X,Y,Z]=bezierLoft(V_loft1,V_loft2,N1,N2,pointSpacingMask,bezierTangency);
[Fd1,Vd1]=quad2tri(Fd1,Vd1);
[Fd2,Vd2,X,Y,Z]=bezierLoft(V_loft3,V_loft4,N3,N4,pointSpacingMask,bezierTangency);
[Fd2,Vd2]=quad2tri(Fd2,Vd2);

pointSpacingNow=mean(diff(pathLength(V_loft2)));
n=ceil((maskDiscRadius2-maskDiscRadius1)./pointSpacingNow);
<span class="keyword">if</span> n&lt;2
    n=2;
<span class="keyword">end</span>
<span class="keyword">if</span> iseven(n)
    n=n+1;
<span class="keyword">end</span>

cParLoft.numSteps=n;
cParLoft.closeLoopOpt=1;
cParLoft.patchType=<span class="string">'tri'</span>;
[Fdt,Vdt]=polyLoftLinear(V_loft2,V_loft4,cParLoft);

[Fc,Vc]=regionTriMesh2D({V_loft4(:,[1 2])},pointSpacingNow,0,0);
Vc(:,3)=maskDiscOffset;
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
gpatch(Fb(Cb==1,:),V,<span class="string">'kw'</span>,<span class="string">'none'</span>,0.5);
gpatch(F_rim,V_rim,<span class="string">'kw'</span>,<span class="string">'none'</span>,1);

gpatch(Fd1,Vd1,<span class="string">'rw'</span>,<span class="string">'none'</span>,0.5);
gpatch(Fd2,Vd2,<span class="string">'bw'</span>,<span class="string">'none'</span>,0.5);
gpatch(Fdt,Vdt,<span class="string">'gw'</span>,<span class="string">'none'</span>,0.5);
gpatch(Fc,Vc,<span class="string">'yw'</span>,<span class="string">'none'</span>,0.5);

plotV(V_loft1,<span class="string">'r-'</span>,<span class="string">'LineWidth'</span>,3);
quiverVec(V_loft1,N1,5,<span class="string">'k'</span>);

plotV(V_loft4,<span class="string">'b-'</span>,<span class="string">'LineWidth'</span>,2);
quiverVec(V_loft4,N4,5,<span class="string">'k'</span>);

plotV(V_loft3,<span class="string">'b-'</span>,<span class="string">'LineWidth'</span>,3);
quiverVec(V_loft3,N3,5,<span class="string">'k'</span>);

plotV(V_loft2,<span class="string">'r-'</span>,<span class="string">'LineWidth'</span>,2);

quiverVec(V_loft2,N2,5,<span class="string">'k'</span>);

axisGeom; camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_16.jpg" alt=""> <h2 id="38">Join and merge mask body components</h2><pre class="codeinput">[F_mask,V_mask,C_mask]=joinElementSets({Ft,Fd1,Fd2,Fdt,Fc},{Vt,Vd1,Vd2,Vdt,Vc});
[F_mask,V_mask]=mergeVertices(F_mask,V_mask);
[F_mask,V_mask]=patchCleanUnused(F_mask,V_mask);
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
gpatch(Ff,Vf,<span class="string">'w'</span>,<span class="string">'none'</span>,1);
<span class="comment">% gpatch(Fb,V,'w','none',1);</span>
gpatch(F_mask,V_mask,<span class="string">'bw'</span>,<span class="string">'none'</span>,1);
gpatch(F_rim,V_rim,<span class="string">'kw'</span>,<span class="string">'none'</span>,1);
axisGeom; camlight <span class="string">headlight</span>;
view(2);
<span class="comment">% colormap spectral; icolorbar;</span>
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_17.jpg" alt=""> <pre class="codeinput">cFigure; hold <span class="string">on</span>;
gpatch(Ff,Vf,<span class="string">'w'</span>,<span class="string">'none'</span>,1);
<span class="comment">% gpatch(Fb,V,'w','none',1);</span>
<span class="comment">% gpatch(F_mask,V_mask,'gw','none',0.5);</span>
gpatch(F_rim,V_rim,<span class="string">'kw'</span>,<span class="string">'none'</span>,1);
axisGeom; camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_18.jpg" alt=""> <pre class="codeinput">cFigure; hold <span class="string">on</span>;
<span class="comment">% gpatch(Fp1,V,'w','none',1);</span>
gpatch(F_mask,V_mask,<span class="string">'bw'</span>,<span class="string">'none'</span>,1);
gpatch(F_rim,V_rim,<span class="string">'gw'</span>,<span class="string">'none'</span>,1);
axisGeom;
camlight <span class="string">headlight</span>;
view(2);
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_19.jpg" alt=""> <pre class="codeinput">cFigure; hold <span class="string">on</span>;
<span class="comment">% gpatch(Fb,V,'w','none',0.9);</span>
gpatch(F_rim,V_rim,C_rim,<span class="string">'k'</span>,1);
<span class="comment">% patchNormPlot(F_rim,V_rim);</span>
axisGeom;
camlight <span class="string">headlight</span>;
view(2);
colormap <span class="string">gjet</span>; icolorbar;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_20.jpg" alt=""> <pre class="codeinput">[V_regions]=getInnerPoint(F_rim,V_rim); <span class="comment">% Define region points</span>
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
gpatch(F_rim,V_rim,C_rim,<span class="string">'k'</span>,1);
<span class="comment">% plotV(V_regions,'r.','MarkerSize',markerSize1)</span>
axisGeom;
camlight <span class="string">headlight</span>; view(2);
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_21.jpg" alt=""> <pre class="codeinput">[regionA]=tetVolMeanEst(F_rim,V_rim); <span class="comment">%Volume for regular tets</span>

inputStruct.stringOpt=<span class="string">'-pq1.2AaY'</span>;
inputStruct.Faces=F_rim;
inputStruct.Nodes=V_rim;
inputStruct.holePoints=[];
inputStruct.faceBoundaryMarker=C_rim; <span class="comment">%Face boundary markers</span>
inputStruct.regionPoints=V_regions; <span class="comment">%region points</span>
inputStruct.regionA=regionA;

<span class="comment">% Mesh model using tetrahedral elements using tetGen</span>
[meshOutput]=runTetGen(inputStruct); <span class="comment">%Run tetGen</span>
</pre><pre class="codeoutput"> 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- TETGEN Tetrahedral meshing --- 27-Apr-2023 16:34:37
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- Writing SMESH file --- 27-Apr-2023 16:34:37
----&gt; Adding node field
----&gt; Adding facet field
----&gt; Adding holes specification
----&gt; Adding region specification
--- Done --- 27-Apr-2023 16:34:37
--- Running TetGen to mesh input boundary--- 27-Apr-2023 16:34:37
Opening /mnt/data/MATLAB/GIBBON/data/temp/temp.smesh.
Delaunizing vertices...
Delaunay seconds:  0.006364
Creating surface mesh ...
Surface mesh seconds:  0.002057
Recovering boundaries...
Boundary recovery seconds:  0.004818
Removing exterior tetrahedra ...
Spreading region attributes.
Exterior tets removal seconds:  0.002076
Recovering Delaunayness...
Delaunay recovery seconds:  0.001725
Refining mesh...
  1759 insertions, added 497 points, 6317 tetrahedra in queue.
  585 insertions, added 23 points, 226 tetrahedra in queue.
  780 insertions, added 17 points, 558 tetrahedra in queue.
Refinement seconds:  0.021674
Smoothing vertices...
Mesh smoothing seconds:  0.019916
Improving mesh...
Mesh improvement seconds:  0.002095

Writing /mnt/data/MATLAB/GIBBON/data/temp/temp.1.node.
Writing /mnt/data/MATLAB/GIBBON/data/temp/temp.1.ele.
Writing /mnt/data/MATLAB/GIBBON/data/temp/temp.1.face.
Writing /mnt/data/MATLAB/GIBBON/data/temp/temp.1.edge.

Output seconds:  0.020412
Total running seconds:  0.081298

Statistics:

  Input points: 1320
  Input facets: 2640
  Input segments: 3960
  Input holes: 0
  Input regions: 1

  Mesh points: 1864
  Mesh tetrahedra: 6859
  Mesh faces: 15038
  Mesh faces on exterior boundary: 2640
  Mesh faces on input facets: 2640
  Mesh edges on input segments: 3960
  Steiner points inside domain: 544

--- Done --- 27-Apr-2023 16:34:37
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- Importing TetGen files --- 27-Apr-2023 16:34:37
--- Done --- 27-Apr-2023 16:34:37
</pre><p>Access model element and patch data</p><pre class="codeinput">Fb_rim=meshOutput.facesBoundary;
Cb_rim=meshOutput.boundaryMarker;
V_rim=meshOutput.nodes;
E_rim=meshOutput.elements;

<span class="comment">% Visualizing mesh using |meshView|, see also |anim8|</span>
meshView(meshOutput);
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_22.jpg" alt=""> <h2 id="47">Join node sets</h2><pre class="codeinput">V_rim(:,3)=V_rim(:,3)+initialOffset;
Fb_rim=Fb_rim+size(V,1);
E_rim=E_rim+size(V,1);
V=[V;V_rim];
</pre><pre class="codeinput">cFigure;
gpatch(F,V,<span class="string">'w'</span>,<span class="string">'k'</span>,1);
gpatch(Fb_rim,V,Cb_rim,<span class="string">'k'</span>,1);
axisGeom;
colormap <span class="string">gjet</span>; icolorbar;
camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_23.jpg" alt=""> <h2 id="49">Define contact surfaces</h2><pre class="codeinput"><span class="comment">% The rigid primary surface of the sphere</span>
F_contact_primary=fliplr(Fb_rim(Cb_rim~=4,:));

<span class="comment">% The deformable secondary surface of the slab</span>
Fb_contact=Fb(Cb==1,:);
V_Fb_centre=patchCentre(Fb_contact,V);
D=minDist(V_Fb_centre,V_rim);
logicSecondary=D&lt;=(2*pointSpacingTissue);
logicSecondary=triSurfLogicSharpFix(Fb_contact,logicSecondary,3);
F_contact_secondary=fliplr(Fb_contact(logicSecondary,:));
</pre><p>Visualize contact surfaces</p><pre class="codeinput">cFigure; hold <span class="string">on</span>;
title(<span class="string">'Contact sets and normal directions'</span>,<span class="string">'FontSize'</span>,fontSize);

gpatch(Fb,V,<span class="string">'kw'</span>,<span class="string">'none'</span>,0.5);

hl(1)=gpatch(F_contact_primary,V,<span class="string">'gw'</span>,<span class="string">'k'</span>,1);
patchNormPlot(F_contact_primary,V);
hl(2)=gpatch(F_contact_secondary,V,<span class="string">'rw'</span>,<span class="string">'k'</span>,1);
patchNormPlot(F_contact_secondary,V);

legend(hl,{<span class="string">'Primary'</span>,<span class="string">'secondary'</span>});

axisGeom(gca,fontSize);
camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_24.jpg" alt=""> <h2 id="51">Define boundary conditions</h2><pre class="codeinput"><span class="comment">%Supported nodes</span>
bcSupportList=unique(Fb(Cb==2,:));

<span class="comment">%Prescribed displacement nodes</span>
bcPrescribeList=unique(Fb_rim(Cb_rim==4,:));
</pre><p>Visualize BC's</p><pre class="codeinput">hf=cFigure; hold <span class="string">on</span>;
<span class="comment">% title('Boundary conditions model','FontSize',fontSize);</span>
gpatch(Fb,V,<span class="string">'kw'</span>,<span class="string">'none'</span>,faceAlpha2);
gpatch(Fb_rim(Cb_rim~=4,:),V,<span class="string">'kw'</span>,<span class="string">'none'</span>,faceAlpha2);
gpatch(Fb_rim(Cb_rim==4,:),V,<span class="string">'rw'</span>,<span class="string">'none'</span>,1);
gpatch(Fb(Cb==2,:),V,<span class="string">'kw'</span>,<span class="string">'none'</span>,1);
hl2(1)=plotV(V(bcPrescribeList,:),<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,markerSize2);
hl2(2)=plotV(V(bcSupportList,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize2);
legend(hl2,{<span class="string">'BC prescribe'</span>,<span class="string">'BC support'</span>});
axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_25.jpg" alt=""> <h2 id="53">Defining the FEBio input structure</h2><p>See also <tt>febioStructTemplate</tt> and <tt>febioStruct2xml</tt> and the FEBio user manual.</p><pre class="codeinput"><span class="comment">%Get a template with default settings</span>
[febio_spec]=febioStructTemplate;

<span class="comment">%febio_spec version</span>
febio_spec.ATTR.version=<span class="string">'4.0'</span>;

<span class="comment">%Module section</span>
febio_spec.Module.ATTR.type=<span class="string">'solid'</span>;

<span class="comment">%Control section</span>
febio_spec.Control.analysis=<span class="string">'STATIC'</span>;
febio_spec.Control.time_steps=numTimeSteps;
febio_spec.Control.step_size=1/numTimeSteps;
febio_spec.Control.solver.max_refs=max_refs;
febio_spec.Control.solver.qn_method.max_ups=max_ups;
febio_spec.Control.solver.symmetric_stiffness=symmetric_stiffness;
febio_spec.Control.time_stepper.dtmin=dtmin;
febio_spec.Control.time_stepper.dtmax=dtmax;
febio_spec.Control.time_stepper.max_retries=max_retries;
febio_spec.Control.time_stepper.opt_iter=opt_iter;

<span class="comment">%Material section</span>
materialName1=<span class="string">'Material1'</span>;
febio_spec.Material.material{1}.ATTR.name=materialName1;
febio_spec.Material.material{1}.ATTR.type=<span class="string">'Ogden unconstrained'</span>;
febio_spec.Material.material{1}.ATTR.id=1;
febio_spec.Material.material{1}.c1=c1_tissue;
febio_spec.Material.material{1}.m1=m1_tissue;
febio_spec.Material.material{1}.c2=c1_tissue;
febio_spec.Material.material{1}.m2=-m1_tissue;
febio_spec.Material.material{1}.cp=k_tissue;

materialName2=<span class="string">'Material2'</span>;
febio_spec.Material.material{2}.ATTR.name=materialName2;
febio_spec.Material.material{2}.ATTR.type=<span class="string">'Ogden unconstrained'</span>;
febio_spec.Material.material{2}.ATTR.id=2;
febio_spec.Material.material{2}.c1=c1_rim;
febio_spec.Material.material{2}.m1=m1_rim;
febio_spec.Material.material{2}.c2=c1_rim;
febio_spec.Material.material{2}.m2=-m1_rim;
febio_spec.Material.material{2}.cp=k_rim;

<span class="comment">% Mesh section</span>
<span class="comment">% -&gt; Nodes</span>
febio_spec.Mesh.Nodes{1}.ATTR.name=<span class="string">'All'</span>; <span class="comment">%The node set name</span>
febio_spec.Mesh.Nodes{1}.node.ATTR.id=(1:size(V,1))'; <span class="comment">%The node id's</span>
febio_spec.Mesh.Nodes{1}.node.VAL=V; <span class="comment">%The nodel coordinates</span>

<span class="comment">% -&gt; Elements</span>
partName1=<span class="string">'Part1'</span>;
febio_spec.Mesh.Elements{1}.ATTR.name=partName1; <span class="comment">%Name of this part</span>
febio_spec.Mesh.Elements{1}.ATTR.type=<span class="string">'tet4'</span>; <span class="comment">%Element type</span>
febio_spec.Mesh.Elements{1}.elem.ATTR.id=(1:1:size(E_face,1))'; <span class="comment">%Element id's</span>
febio_spec.Mesh.Elements{1}.elem.VAL=E_face; <span class="comment">%The element matrix</span>

partName2=<span class="string">'Part2'</span>;
febio_spec.Mesh.Elements{2}.ATTR.name=partName2; <span class="comment">%Name of this part</span>
febio_spec.Mesh.Elements{2}.ATTR.type=<span class="string">'tet4'</span>; <span class="comment">%Element type</span>
febio_spec.Mesh.Elements{2}.elem.ATTR.id=size(E_face,1)+(1:1:size(E_rim,1))'; <span class="comment">%Element id's</span>
febio_spec.Mesh.Elements{2}.elem.VAL=E_rim; <span class="comment">%The element matrix</span>

<span class="comment">% -&gt; NodeSets</span>
nodeSetName1=<span class="string">'bcSupportList'</span>;
febio_spec.Mesh.NodeSet{1}.ATTR.name=nodeSetName1;
febio_spec.Mesh.NodeSet{1}.VAL=mrow(bcSupportList);

nodeSetName2=<span class="string">'bcPrescribeList'</span>;
febio_spec.Mesh.NodeSet{2}.ATTR.name=nodeSetName2;
febio_spec.Mesh.NodeSet{2}.VAL=mrow(bcPrescribeList);

<span class="comment">%MeshDomains section</span>
febio_spec.MeshDomains.SolidDomain{1}.ATTR.name=partName1;
febio_spec.MeshDomains.SolidDomain{1}.ATTR.mat=materialName1;

febio_spec.MeshDomains.SolidDomain{2}.ATTR.name=partName2;
febio_spec.MeshDomains.SolidDomain{2}.ATTR.mat=materialName2;

<span class="comment">% -&gt; Surfaces</span>
surfaceName1=<span class="string">'contactSurface1'</span>;
febio_spec.Mesh.Surface{1}.ATTR.name=surfaceName1;
febio_spec.Mesh.Surface{1}.tri3.ATTR.id=(1:1:size(F_contact_primary,1))';
febio_spec.Mesh.Surface{1}.tri3.VAL=F_contact_primary;

surfaceName2=<span class="string">'contactSurface2'</span>;
febio_spec.Mesh.Surface{2}.ATTR.name=surfaceName2;
febio_spec.Mesh.Surface{2}.tri3.ATTR.id=(1:1:size(F_contact_secondary,1))';
febio_spec.Mesh.Surface{2}.tri3.VAL=F_contact_secondary;

<span class="comment">% -&gt; Surface pairs</span>
contactPairName=<span class="string">'Contact1'</span>;
febio_spec.Mesh.SurfacePair{1}.ATTR.name=contactPairName;
febio_spec.Mesh.SurfacePair{1}.primary=surfaceName1;
febio_spec.Mesh.SurfacePair{1}.secondary=surfaceName2;


<span class="comment">%Boundary condition section</span>
<span class="comment">% -&gt; Fix boundary conditions</span>
febio_spec.Boundary.bc{1}.ATTR.name=<span class="string">'zero_displacement_xyz'</span>;
febio_spec.Boundary.bc{1}.ATTR.type=<span class="string">'zero displacement'</span>;
febio_spec.Boundary.bc{1}.ATTR.node_set=nodeSetName1;
febio_spec.Boundary.bc{1}.x_dof=1;
febio_spec.Boundary.bc{1}.y_dof=1;
febio_spec.Boundary.bc{1}.z_dof=1;

febio_spec.Boundary.bc{2}.ATTR.name=<span class="string">'zero_displacement_xy'</span>;
febio_spec.Boundary.bc{2}.ATTR.type=<span class="string">'zero displacement'</span>;
febio_spec.Boundary.bc{2}.ATTR.node_set=nodeSetName2;
febio_spec.Boundary.bc{2}.x_dof=1;
febio_spec.Boundary.bc{2}.y_dof=1;
febio_spec.Boundary.bc{2}.z_dof=0;

febio_spec.Boundary.bc{3}.ATTR.name=<span class="string">'prescibed_displacement_z'</span>;
febio_spec.Boundary.bc{3}.ATTR.type=<span class="string">'prescribed displacement'</span>;
febio_spec.Boundary.bc{3}.ATTR.node_set=nodeSetName2;
febio_spec.Boundary.bc{3}.dof=<span class="string">'z'</span>;
febio_spec.Boundary.bc{3}.value.ATTR.lc=1;
febio_spec.Boundary.bc{3}.value.VAL=displacementMagnitude_z;
febio_spec.Boundary.bc{3}.relative=0;

<span class="comment">%Contact section</span>
febio_spec.Contact.contact{1}.ATTR.type=<span class="string">'sliding-elastic'</span>;
febio_spec.Contact.contact{1}.ATTR.surface_pair=contactPairName;
febio_spec.Contact.contact{1}.two_pass=0;
febio_spec.Contact.contact{1}.laugon=laugon;
febio_spec.Contact.contact{1}.tolerance=0.2;
febio_spec.Contact.contact{1}.gaptol=0;
febio_spec.Contact.contact{1}.minaug=minaug;
febio_spec.Contact.contact{1}.maxaug=maxaug;
febio_spec.Contact.contact{1}.search_tol=0.01;
febio_spec.Contact.contact{1}.search_radius=0.1*sqrt(sum((max(V,[],1)-min(V,[],1)).^2,2));
febio_spec.Contact.contact{1}.symmetric_stiffness=0;
febio_spec.Contact.contact{1}.auto_penalty=1;
febio_spec.Contact.contact{1}.penalty=contactPenalty;
febio_spec.Contact.contact{1}.fric_coeff=fric_coeff;

<span class="comment">%LoadData section</span>
<span class="comment">% -&gt; load_controller</span>
febio_spec.LoadData.load_controller{1}.ATTR.name=<span class="string">'LC_1'</span>;
febio_spec.LoadData.load_controller{1}.ATTR.id=1;
febio_spec.LoadData.load_controller{1}.ATTR.type=<span class="string">'loadcurve'</span>;
febio_spec.LoadData.load_controller{1}.interpolate=<span class="string">'LINEAR'</span>;
<span class="comment">%febio_spec.LoadData.load_controller{1}.extend='CONSTANT';</span>
febio_spec.LoadData.load_controller{1}.points.pt.VAL=[0 0; 1 1];

<span class="comment">%Output section</span>
<span class="comment">% -&gt; log file</span>
febio_spec.Output.logfile.ATTR.file=febioLogFileName;
febio_spec.Output.logfile.node_data{1}.ATTR.file=febioLogFileName_disp;
febio_spec.Output.logfile.node_data{1}.ATTR.data=<span class="string">'ux;uy;uz'</span>;
febio_spec.Output.logfile.node_data{1}.ATTR.delim=<span class="string">','</span>;

febio_spec.Output.logfile.node_data{2}.ATTR.file=febioLogFileName_force;
febio_spec.Output.logfile.node_data{2}.ATTR.data=<span class="string">'Rx;Ry;Rz'</span>;
febio_spec.Output.logfile.node_data{2}.ATTR.delim=<span class="string">','</span>;

febio_spec.Output.logfile.element_data{1}.ATTR.file=febioLogFileName_strainEnergy;
febio_spec.Output.logfile.element_data{1}.ATTR.data=<span class="string">'sed'</span>;
febio_spec.Output.logfile.element_data{1}.ATTR.delim=<span class="string">','</span>;
febio_spec.Output.logfile.element_data{1}.VAL=1:1:size(E_face,1);

<span class="comment">% Plotfile section</span>
febio_spec.Output.plotfile.compression=0;
</pre><h2 id="54">Quick viewing of the FEBio input file structure</h2><p>The <tt>febView</tt> function can be used to view the xml structure in a MATLAB figure window.</p><p><tt>febView(febio_spec); %Viewing the febio file</tt></p><h2 id="56">Exporting the FEBio input file</h2><p>Exporting the febio_spec structure to an FEBio input file is done using the <tt>febioStruct2xml</tt> function.</p><pre class="codeinput">febioStruct2xml(febio_spec,febioFebFileName); <span class="comment">%Exporting to file and domNode</span>
<span class="comment">%system(['gedit ',febioFebFileName,' &amp;']);</span>
</pre><h2 id="57">Running the FEBio analysis</h2><p>To run the analysis defined by the created FEBio input file the <tt>runMonitorFEBio</tt> function is used. The input for this function is a structure defining job settings e.g. the FEBio input file name. The optional output runFlag informs the user if the analysis was run succesfully.</p><pre class="codeinput">febioAnalysis.run_filename=febioFebFileName; <span class="comment">%The input file name</span>
febioAnalysis.run_logname=febioLogFileName; <span class="comment">%The name for the log file</span>
febioAnalysis.disp_on=1; <span class="comment">%Display information on the command window</span>
febioAnalysis.runMode=runMode;
febioAnalysis.maxLogCheckTime=10; <span class="comment">%Max log file checking time</span>

[runFlag]=runMonitorFEBio(febioAnalysis);<span class="comment">%START FEBio NOW!!!!!!!!</span>
</pre><pre class="codeoutput"> 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--------&gt;    RUNNING/MONITORING FEBIO JOB    &lt;-------- 27-Apr-2023 16:34:48
FEBio path: /home/kevin/FEBioStudio2/bin/febio4
# Attempt removal of existing log files                27-Apr-2023 16:34:48
 * Removal succesful                                   27-Apr-2023 16:34:48
# Attempt removal of existing .xplt files              27-Apr-2023 16:34:48
 * Removal succesful                                   27-Apr-2023 16:34:48
# Starting FEBio...                                    27-Apr-2023 16:34:48
  Max. total analysis time is: Inf s
 * Waiting for log file creation                       27-Apr-2023 16:34:49
   Max. wait time: 10 s
 * Log file found.                                     27-Apr-2023 16:34:49
# Parsing log file...                                  27-Apr-2023 16:34:49
    number of iterations   : 5                         27-Apr-2023 16:34:50
    number of reformations : 5                         27-Apr-2023 16:34:50
------- converged at time : 0.0666667                  27-Apr-2023 16:34:50
    number of iterations   : 4                         27-Apr-2023 16:34:51
    number of reformations : 4                         27-Apr-2023 16:34:51
------- converged at time : 0.133333                   27-Apr-2023 16:34:51
    number of iterations   : 4                         27-Apr-2023 16:34:51
    number of reformations : 4                         27-Apr-2023 16:34:51
------- converged at time : 0.2                        27-Apr-2023 16:34:51
    number of iterations   : 4                         27-Apr-2023 16:34:52
    number of reformations : 4                         27-Apr-2023 16:34:52
------- converged at time : 0.266667                   27-Apr-2023 16:34:52
    number of iterations   : 4                         27-Apr-2023 16:34:53
    number of reformations : 4                         27-Apr-2023 16:34:53
------- converged at time : 0.333333                   27-Apr-2023 16:34:53
    number of iterations   : 4                         27-Apr-2023 16:34:54
    number of reformations : 4                         27-Apr-2023 16:34:54
------- converged at time : 0.4                        27-Apr-2023 16:34:54
    number of iterations   : 5                         27-Apr-2023 16:34:54
    number of reformations : 5                         27-Apr-2023 16:34:54
------- converged at time : 0.466667                   27-Apr-2023 16:34:54
    number of iterations   : 4                         27-Apr-2023 16:34:55
    number of reformations : 4                         27-Apr-2023 16:34:55
------- converged at time : 0.533333                   27-Apr-2023 16:34:55
    number of iterations   : 4                         27-Apr-2023 16:34:56
    number of reformations : 4                         27-Apr-2023 16:34:56
------- converged at time : 0.6                        27-Apr-2023 16:34:56
    number of iterations   : 4                         27-Apr-2023 16:34:57
    number of reformations : 4                         27-Apr-2023 16:34:57
------- converged at time : 0.666667                   27-Apr-2023 16:34:57
    number of iterations   : 5                         27-Apr-2023 16:34:58
    number of reformations : 5                         27-Apr-2023 16:34:58
------- converged at time : 0.733333                   27-Apr-2023 16:34:58
    number of reformations : 5                         27-Apr-2023 16:34:59
------- converged at time : 0.8                        27-Apr-2023 16:34:59
    number of iterations   : 5                         27-Apr-2023 16:34:59
    number of reformations : 5                         27-Apr-2023 16:34:59
------- converged at time : 0.866667                   27-Apr-2023 16:34:59
    number of iterations   : 5                         27-Apr-2023 16:35:00
    number of reformations : 5                         27-Apr-2023 16:35:00
------- converged at time : 0.933333                   27-Apr-2023 16:35:00
    number of iterations   : 5                         27-Apr-2023 16:35:01
    number of reformations : 5                         27-Apr-2023 16:35:01
------- converged at time : 1                          27-Apr-2023 16:35:01
 Elapsed time : 0:00:12                                27-Apr-2023 16:35:01
 N O R M A L   T E R M I N A T I O N
# Done                                                 27-Apr-2023 16:35:01
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
</pre><h2 id="58">Import FEBio results</h2><pre class="codeinput"><span class="keyword">if</span> runFlag==1 <span class="comment">%i.e. a succesful run</span>
</pre><p>Importing nodal displacements from a log file</p><pre class="codeinput">    dataStruct=importFEBio_logfile(fullfile(savePath,febioLogFileName_disp),0,1);

    <span class="comment">%Access data</span>
    N_disp_mat=dataStruct.data; <span class="comment">%Displacement</span>
    timeVec=dataStruct.time; <span class="comment">%Time</span>

    <span class="comment">%Create deformed coordinate set</span>
    V_DEF=N_disp_mat+repmat(V,[1 1 size(N_disp_mat,3)]);
</pre><p>Importing element strain energies from a log file</p><pre class="codeinput">    dataStruct=importFEBio_logfile(fullfile(savePath,febioLogFileName_strainEnergy),0,1); <span class="comment">%Element strain energy</span>

    <span class="comment">%Access data</span>
    E_sed_mat=dataStruct.data;
</pre><p>Plotting the simulated results using <tt>anim8</tt> to visualize and animate deformations</p><pre class="codeinput">    cMap_c=gjet(250);
    cMap=[linspacen([1 1 1],cMap_c(1,:),50)'; cMap_c];

    [CV]=faceToVertexMeasure(E_face,V,E_sed_mat(:,:,end));

    <span class="comment">% Create basic view and store graphics handle to initiate animation</span>
    hf=cFigure; <span class="comment">%Open figure</span>
    gtitle([febioFebFileNamePart,<span class="string">': Press play to animate'</span>]);

    gpatch(Ffc,Vf,cMap(1,:),<span class="string">'none'</span>,1)
    hp1=gpatch(Fb(Cb==1,:),V_DEF(:,:,end),CV,<span class="string">'none'</span>,1); <span class="comment">%Add graphics object to animate</span>
    hp1.FaceColor=<span class="string">'Interp'</span>;
    hp2=gpatch(Fb_rim,V_DEF(:,:,end),<span class="string">'w'</span>,<span class="string">'none'</span>,0.25); <span class="comment">%Add graphics object to animate</span>
    hp3=gpatch(F_mask,V_mask,<span class="string">'w'</span>,<span class="string">'none'</span>,0.25);

    axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;
    colormap(cMap); colorbar;
    caxis([0 max(E_sed_mat(:))/10]);
    axis(axisLim(V_DEF)); <span class="comment">%Set axis limits statically</span>
    axis <span class="string">tight</span>;

    <span class="comment">% Set up animation features</span>
    animStruct.Time=timeVec; <span class="comment">%The time vector</span>
    <span class="keyword">for</span> qt=1:1:size(N_disp_mat,3) <span class="comment">%Loop over time increments</span>
        [CV]=faceToVertexMeasure(E_face,V,E_sed_mat(:,:,qt));

        DN=N_disp_mat(:,:,qt); <span class="comment">%Current displacement</span>
        u=mean(DN(bcPrescribeList,:),1);
        V_mask_def=V_mask+u(ones(size(V_mask,1),1),:);

        <span class="comment">%Set entries in animation structure</span>
        animStruct.Handles{qt}=[hp1 hp1 hp2 hp3]; <span class="comment">%Handles of objects to animate</span>
        animStruct.Props{qt}={<span class="string">'Vertices'</span>,<span class="string">'CData'</span>,<span class="string">'Vertices'</span>,<span class="string">'Vertices'</span>}; <span class="comment">%Properties of objects to animate</span>
        animStruct.Set{qt}={V_DEF(:,:,qt),CV,V_DEF(:,:,qt),V_mask_def}; <span class="comment">%Property values for to set in order to animate</span>
    <span class="keyword">end</span>
    anim8(hf,animStruct); <span class="comment">%Initiate animation feature</span>
    drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0059_face_mask_loading_26.jpg" alt=""> <pre class="codeinput"><span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">function</span> [varargout]=traceToSurf(V1,N1,F2,V2,optionStructRayTrace)

<span class="keyword">if</span> size(N1,1)==1
    N1=N1(ones(size(V1,1),1),:);
<span class="keyword">end</span>

numPoints=size(V1,1);
indFacesIntersect=nan(size(V1,1),2);
<span class="keyword">for</span> q=1:1:numPoints
    [P,indFaceIntersect,~,~]=triSurfRayTrace(V1(q,:),N1(q,:),F2,V2,optionStructRayTrace);
    <span class="keyword">if</span> size(P,1)&gt;1
        [~,indMin]=minDist(V1(q,:),P);
        <span class="comment">%         [~,indMin]=min(d);</span>
        P=P(indMin,:);
        indFaceIntersect=indFaceIntersect(indMin,:);
    <span class="keyword">end</span>
    <span class="keyword">if</span> ~isempty(P)
        V1(q,:)=P;
        indFacesIntersect(q,:)=indFaceIntersect;
    <span class="keyword">end</span>
<span class="keyword">end</span>

varargout{1}=V1;
varargout{2}=indFacesIntersect;

<span class="keyword">end</span>

<span class="keyword">function</span> [Fr,Vr]=roundMesh(indCurve,Vm,Nm,nc,stripRadius)

E=[indCurve(1:end)' [indCurve(2:end) indCurve(1)]'];
ind1=indCurve(1:end)';
ind2=[indCurve(2:end) indCurve(1)]';
ind3=[indCurve(end) indCurve(1:end-1)]';

N1f=Vm(ind2,:)-Vm(ind1,:);
N1b=Vm(ind1,:)-Vm(ind3,:);
Ne=vecnormalize((N1f+N1b)/2);

<span class="comment">% Ne=vecnormalize(edgeVec(E,Vm));</span>
Nf=-Nm(E(:,1),:);<span class="comment">% -vecnormalize((Nm(E(:,1),:)+Nm(E(:,2),:))/2);</span>
Ne2=vecnormalize(cross(Nf,Ne));

X=repmat(Vm(E(:,1),1),1,nc);
Y=repmat(Vm(E(:,1),2),1,nc);
Z=repmat(Vm(E(:,1),3),1,nc);

t=repmat(linspace(0,pi/2,nc),size(Z,1),1);

X=X+stripRadius.*sin(t).*repmat(Ne2(:,1),1,nc)-stripRadius.*cos(t).*repmat(Nf(:,1),1,nc)+stripRadius.*repmat(Nf(:,1),1,nc);
Y=Y+stripRadius.*sin(t).*repmat(Ne2(:,2),1,nc)-stripRadius.*cos(t).*repmat(Nf(:,2),1,nc)+stripRadius.*repmat(Nf(:,2),1,nc);
Z=Z+stripRadius.*sin(t).*repmat(Ne2(:,3),1,nc)-stripRadius.*cos(t).*repmat(Nf(:,3),1,nc)+stripRadius.*repmat(Nf(:,3),1,nc);

<span class="keyword">for</span> q=2:1:size(X,2)
   v=evenlySampleCurve([X(:,q) Y(:,q) Z(:,q)],size(X,1),<span class="string">'pchip'</span>,1);
   X(:,q)=v(:,1);
   Y(:,q)=v(:,2);
   Z(:,q)=v(:,3);
<span class="keyword">end</span>

[Fr,Vr]=grid2patch(X,Y,Z,[],[1 0 0]);

<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">function</span> [F,V,X,Y,Z]=bezierLoft(P1,P4,N1,N4,pointSpacing,f)

D12=sqrt(sum((P1-P4).^2,2));
numPoints=ceil(max(D12)./pointSpacing);
<span class="keyword">if</span> numPoints&lt;2
    numPoints=2;
<span class="keyword">end</span>

P2=P1+D12.*f.*N1;
P3=P4-D12.*f.*N4;

X=zeros(numPoints,size(P1,1));
Y=zeros(numPoints,size(P1,1));
Z=zeros(numPoints,size(P1,1));
<span class="keyword">for</span> q=1:1:size(P1,1)
    p=[P1(q,:); P2(q,:); P3(q,:); P4(q,:)]; <span class="comment">%Control points</span>
    V_bezier=bezierCurve(p,numPoints*2); <span class="comment">%Compute bezier curve</span>
    V_bezier=evenlySampleCurve(V_bezier,numPoints,<span class="string">'pchip'</span>); <span class="comment">%resample evenly</span>
    X(:,q)=V_bezier(:,1);
    Y(:,q)=V_bezier(:,2);
    Z(:,q)=V_bezier(:,3);
<span class="keyword">end</span>

<span class="comment">%Create quad patch data</span>
[F,V] = surf2patch(X,Y,Z);
I=[(1:size(Z,1)-1)' (1:size(Z,1)-1)' (2:size(Z,1))' (2:size(Z,1))' ];
J=[size(Z,2).*ones(size(Z,1)-1,1) ones(size(Z,1)-1,1) ones(size(Z,1)-1,1) size(Z,2).*ones(size(Z,1)-1,1)];
F_sub=sub2ind(size(Z),I,J);
F=[F;F_sub];
F=fliplr(F);

<span class="keyword">end</span>
</pre><p><img vspace="5" hspace="5" src="gibbVerySmall.gif" alt=""> </p><p><i><b>GIBBON</b></i> <a href="www.gibboncode.org">www.gibboncode.org</a></p><p><i>Kevin Mattheus Moerman</i>, <a href="gibbon.toolbox@gmail.com">gibbon.toolbox@gmail.com</a></p><p><i><b>GIBBON footer text</b></i></p><p>License: <a href="https://github.com/gibbonCode/GIBBON/blob/master/LICENSE">https://github.com/gibbonCode/GIBBON/blob/master/LICENSE</a></p><p>GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for image segmentation, image-based modeling, meshing, and finite element analysis.</p><p>Copyright (C) 2006-2022 Kevin Mattheus Moerman and the GIBBON contributors</p><p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p><p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p><p>You should have received a copy of the GNU General Public License along with this program.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2022b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% DEMO_febio_0059_face_mask_loading
% Below is a demonstration for:
%
% * Building triangulated surface geometry for a face
% * Meshing the face using pentahedral elements
% * Building model of a tube
% * Defining the boundary conditions
% * Coding the febio structure
% * Running the model
% * Importing and visualizing results

%% Keywords
%
% * febio_spec version 4.0
% * febio, FEBio
% * face
% * contact, sliding, friction
% * pentahedral elements, penta6
% * static, solid
% * hyperelastic, Ogden
% * displacement logfile

%%

clear; close all; clc;

%%
% Plot settings
fontSize=15;
faceAlpha1=1;
faceAlpha2=0.3;
markerSize1=15;
markerSize2=10;
lineWidth=2;
cMap=spectral(250);

%% Control parameters

% Path names
defaultFolder = fileparts(fileparts(mfilename('fullpath')));
savePath=fullfile(defaultFolder,'data','temp');

% Defining file names
febioFebFileNamePart='tempModel';
febioFebFileName=fullfile(savePath,[febioFebFileNamePart,'.feb']); %FEB file name
febioLogFileName=fullfile(savePath,[febioFebFileNamePart,'.txt']); %FEBio log file name
febioLogFileName_disp=[febioFebFileNamePart,'_disp_out.txt']; %Log file name for exporting displacement
febioLogFileName_force=[febioFebFileNamePart,'_force_out.txt']; %Log file name for exporting force
febioLogFileName_strainEnergy=[febioFebFileNamePart,'_energy_out.txt']; %Log file name for exporting strain energy density

% Geometry parameters
pointSpacingTissue=6;
faceTissueThickness=6;
pointSpacingMask=pointSpacingTissue/2;
maskRimWidth=5; 
maskRimFilletRadius=6; 
maskDiscRadius1=25;
maskDiscRadius2=maskDiscRadius1+4;
maskDiscOffset=25; 
bezierTangency=0.1; 

distInclude=40; %Distance from mask to include face in FEA

%Ray tracing parameters
optionStructRayTrace.tolEps        = 1e-6;
optionStructRayTrace.triSide       = 0;
optionStructRayTrace.rayType       = 'ray';
optionStructRayTrace.exclusionType = 'inclusive';
optionStructRayTrace.paired        = 0; 

%Material parameters
c1_tissue=1e-3; %Shear-modulus-like parameter
m1_tissue=2; %Material parameter setting degree of non-linearity
k_tissue=c1_tissue*100; %Bulk modulus

c1_rim=c1_tissue*5; %Shear-modulus-like parameter
m1_rim=2; %Material parameter setting degree of non-linearity
k_rim=c1_rim*10; %Bulk modulus

% FEA control settings
numTimeSteps=15; %Number of time steps desired
max_refs=35; %Max reforms
max_ups=0; %Set to zero to use full-Newton iterations
opt_iter=10; %Optimum number of iterations
max_retries=5; %Maximum number of retires
dtmin=(1/numTimeSteps)/100; %Minimum time step size
dtmax=(1/numTimeSteps); %Maximum time step size
symmetric_stiffness=0;
min_residual=1e-20;
runMode='external';

%Boundary condition parameters
initialOffset=0;
displacementMagnitude_z=-2-initialOffset; %Displacement applied

%Contact parameters
contactPenalty=10;
laugon=0;
minaug=1;
maxaug=10;
fric_coeff=0.5;

%% Load face geometry

testCase=1;
switch testCase
    case 1
        %Load surface model
        [Ff,Vf]=graphicsModels(9);
        
        %Surface markers
        V_markers=[65.51,49.94,217.14;... %Tip of the nose
            66.44,54.79,259.81;... %Nose between eyes
            53.81,115,263.39;... %Right eye outer corner
            126.5,46.62,269.75;... %Left eye outer corner
            85.67,69.44,194.1;... %Middle of mounth
            98.39,80.38,158]; %Bottom of chin
    case 2
        %Load surface model
        [Ff,Vf]=graphicsModels(13);
        
        %Surface markers       
        V_markers=[3.50162,-181.107,-8.09110;...  %Tip of the nose
                   1.51627,-159.171,30.4679;... %Nose between eyes
                   -43.2473,-139.003,24.6407;... %Right eye outer corner
                   48.4245,-136.490,25.3913;... %Left eye outer corner
                   4.11905,-167.594,-36.9600;... %Middle of mounth
                   2.85290,-161.802,-73.4644]; %Bottom of chin
end

distEyes=sqrt(sum((V_markers(3,:)-V_markers(4,:)).^2,2));

%% Remeshing surface 
optionStruct_remesh.pointSpacing=pointSpacingTissue; %Set desired point spacing
optionStruct_remesh.disp_on=0; % Turn off command window text display
[Ff,Vf]=ggremesh(Ff,Vf,optionStruct_remesh);

%%

ny=vecnormalize(V_markers(2,:)-V_markers(6,:));
nx=vecnormalize(V_markers(4,:)-V_markers(3,:));
nz=vecnormalize(cross(nx,ny));
nx=vecnormalize(cross(ny,nz));

Q=[nx;ny;nz]';

%%

% cFigure; hold on;
% gpatch(Ff,Vf,'w','none',1);
% % plotV(V_markers,'r.','MarkerSize',35);
% % text(V_markers(:,1)+4,V_markers(:,2),V_markers(:,3),{'1','2','3','4','5','6'},'FontSize',25);
% % quiverTriad(V_markers(1,:),Q,100);
% axisGeom; camlight headlight;
% colormap(spectral(250))
% gdrawnow; 

%%

cFigure; hold on;
gpatch(Ff,Vf,'w','none',0.5);
plotV(V_markers,'r.','MarkerSize',35);
text(V_markers(:,1)+4,V_markers(:,2),V_markers(:,3),{'1','2','3','4','5','6'},'FontSize',25);
quiverTriad(V_markers(1,:),Q,100);
axisGeom; camlight headlight;
colormap(spectral(250))
gdrawnow; 

%% Centre on nose and rotate to face face looking down Z-axis

Vf=Vf-V_markers(1,:);
Vf=Vf*Q;
V_markers=V_markers-V_markers(1,:);
V_markers=V_markers*Q;
nz=[0 0 1];%nz*Q;

%%

cFigure; hold on;
gpatch(Ff,Vf,'w','none',0.5);
plotV(V_markers,'r.','MarkerSize',35);
text(V_markers(:,1)+6,V_markers(:,2),V_markers(:,3)+15,{'1','2','3','4','5','6'},'FontSize',25);
axisGeom; camlight headlight;
colormap(spectral(250))
gdrawnow;

%% Construct mask rim curve

V1=V_markers(1,[1 2]);
V2=V_markers(2,[1 2]);
V3=V_markers(3,[1 2]);
V4=V_markers(4,[1 2]);
V5=V_markers(5,[1 2]);
V6=V_markers(6,[1 2]);

pp1=0.4*V1+0.6*V2;
pp2=0.6*V1+0.4*V3;
pp3=V3-[0 V3(2)]+[0 0.5*V5(2)+0.5*V1(2)];
pp4=[0.3*V2(1)+0.8*V3(1) 0.5*V5(2)+0.5*V6(2)];
pp5=V6;
pp6=[0.3*V2(1)+0.8*V4(1) 0.5*V5(2)+0.5*V6(2)];
pp7=V4-[0 V4(2)]+[0 0.5*V5(2)+0.5*V1(2)];
pp8=0.6*V1+0.4*V4;

V_rim_points=[pp1;pp2;pp3;pp4;pp5;pp6;pp7;pp8];
V_rim_points(:,3)=0;

[V_rim_points,indFaceIntersect]=traceToSurf(V_rim_points,-nz,Ff,Vf,optionStructRayTrace);
numRimControlPoints=size(V_rim_points,1);

V_rim_curve=evenlySpaceCurve(V_rim_points,pointSpacingMask,'pchip',1);
V_rim_curve=traceToSurf(V_rim_curve,-nz,Ff,Vf,optionStructRayTrace);
numPointsRimCurve=size(V_rim_curve,1);


Ne1=vecnormalize([V_rim_points(2:end,:); V_rim_points(1,:)]-V_rim_points(1:end,:));
Ne2=vecnormalize(V_rim_points - [V_rim_points(end,:); V_rim_points(1:end-1,:)]);
Ne=vecnormalize(0.5*Ne1+0.5*Ne2);

Nf=patchNormal(Ff,Vf); %Normal directions
Nff=Nf(indFaceIntersect(:,2),:);
N_rim_points=vecnormalize(cross(Nff,Ne));

V_rim_points1=V_rim_points-N_rim_points.*maskRimWidth/2;
V_rim_points2=V_rim_points+N_rim_points.*maskRimWidth/2;

%%

cFigure; hold on;
gpatch(Ff,Vf,'w','none',0.5);
plotV(V_markers,'r.','MarkerSize',25);
text(V_markers(:,1)+4,V_markers(:,2),V_markers(:,3),{'1','2','3','4','5','6'},'FontSize',25);

plotV(V_rim_points,'k.','MarkerSize',25);
plotV(V_rim_points1,'b.','MarkerSize',25);
plotV(V_rim_points2,'g.','MarkerSize',25);

quiverVec(V_rim_points,N_rim_points,maskRimWidth/2,'y');
quiverVec(V_rim_points,-N_rim_points,maskRimWidth/2,'y');
axisGeom; camlight headlight;
view(2);
gdrawnow; 

%%       

[~,indClose]=minDist(V_markers,Vf);
d=meshDistMarch(Ff,Vf,indClose([1 5]));

[~,indClose]=minDist(V_rim_curve,Vf);
d_rim_curve=meshDistMarch(Ff,Vf,indClose);
d_markers_max=max(d(indClose));

logicCloseVertices= d<=d_markers_max | d_rim_curve<distInclude;

logicCloseFaces= any(logicCloseVertices(Ff),2);
logicCloseFaces=triSurfLogicSharpFix(Ff,logicCloseFaces);

[Fs,Vs]=patchCleanUnused(Ff(logicCloseFaces,:),Vf);

ns=vecnormalize(mean(patchNormal(Fs,Vs)));

[Q]=pointSetPrincipalDir(Vs);
nz=Q(:,3)';
if dot(nz,ns)<1
    nz=-nz;
end

ny=vecnormalize(V_markers(2,:)-V_markers(1,:));
nx=cross(ny,nz);
ny=cross(nz,nx);
Q=[nx;ny;nz]';

Ffc=Ff(~logicCloseFaces,:);

%%

cFigure;  hold on;
gpatch(Ff,Vf,d,'k',0.5);
gpatch(Ff(logicCloseFaces,:),Vf,'none','b',1,2);
plotV(V_markers,'r.','MarkerSize',25);
plotV(V_rim_points,'k.','MarkerSize',15);
plotV(V_rim_curve,'k-','LineWidth',3);

axisGeom; camlight headlight;
colormap(spectral(250))
gdrawnow;

%%

cFigure;  hold on;
gpatch(Ff,Vf,'w','none',0.5);
% gpatch(Ff(logicCloseFaces,:),Vf,'none','b',1,2);
plotV(V_markers,'r.','MarkerSize',25);
plotV(V_rim_points,'k.','MarkerSize',15);
plotV(V_rim_curve,'k-','LineWidth',3);

axisGeom; camlight headlight;
colormap(spectral(250))
gdrawnow;

%%

cFigure;  hold on;
gpatch(Ff,Vf,'w','none');
gpatch(Fs,Vs,'w','b');
% patchNormPlot(Fs,Vs);
plotV(V_markers,'r.','MarkerSize',25);
% quiverTriad(V_markers(1,:),Q,50);
axisGeom;
camlight headlight;
% colormap(viridis(2)); icolorbar; 
gdrawnow;

%%

Ebs=patchBoundary(Fs); 
indBoundaryCurve=edgeListToCurve(Ebs);
indBoundaryCurve=indBoundaryCurve(1:end-1)';

[~,~,Ns]=patchNormal(Fs,Vs);

Vs2=Vs-Ns*faceTissueThickness; 
Fs2=Fs;

Vsc=Vs2(indBoundaryCurve,:);%-Ns(indBoundaryCurve,:)*layerThickness;
[Fs2t,Vs2t]=regionTriMesh3D({Vsc},pointSpacingMask,0,'natural');
Vs2t_ori=Vs2t;
indBoundary=unique(patchBoundary(Fs2t));

[~,indMap]=minDist(Vsc,Vs2t(indBoundary,:));
indBoundaryCurve_2t=indBoundary(indMap);
indBoundaryCurve_2t=indBoundaryCurve_2t(:);

Vs2t=traceToSurf(Vs2t,-nz,Fs2,Vs2,optionStructRayTrace);

cParSmooth.n=3;
cParSmooth.Method='HC';
cParSmooth.RigidConstraints=indBoundaryCurve_2t;
Vs2t=patchSmooth(Fs2t,Vs2t,[],cParSmooth);

numNodesThickness=ceil(faceTissueThickness./pointSpacingTissue);
if numNodesThickness<2
    numNodesThickness=2;
end

cParLoft.numSteps=numNodesThickness; 
cParLoft.closeLoopOpt=1; 
cParLoft.patchType='tri';
[Fss,Vss,ind1,ind2]=polyLoftLinear(Vs(indBoundaryCurve,:),Vs2t(indBoundaryCurve_2t,:),cParLoft);

[Fb,Vb,Cb]=joinElementSets({Fs,Fs2t,Fss},{Vs,Vs2t,Vss});
[Fb,Vb]=mergeVertices(Fb,Vb);

%%

cFigure; hold on; 
gpatch(Ffc,Vf,'w','none',0.5);
gpatch(Fb,Vb,Cb,'k',0.5);

% gpatch(Fs,Vs,'bw','k',1);
% % gpatch(Fs2t,Vs2t_ori,'gw','g',0.5);
% gpatch(Fs2t,Vs2t,'rw','k',1);
% gpatch(Fss,Vss,'gw','k',1);

% patchNormPlot(Fb,Vb);
axisGeom; camlight headlight;
colormap(spectral); icolorbar;
gdrawnow;

%%
% Get inner mesh point between top and bottom at nose
Pn=triSurfRayTrace(V_markers(1,:),-nz,Fb,Vb,optionStructRayTrace);
Pn=mean(Pn,1);
    
%%

cFigure; hold on; 
%gpatch(Ffc,Vf,'w','none',0.5);
gpatch(Fb,Vb,Cb,'k',1);
plotV(Pn,'r.','MarkerSize',25);

% patchNormPlot(Fb,Vb);
axisGeom; camlight headlight;
colormap(spectral); icolorbar;
gdrawnow;

%%

%Create tetgen input structure
inputStruct.stringOpt='-pq1.2AaY'; %Options for tetgen
inputStruct.Faces=Fb; %Boundary faces
inputStruct.Nodes=Vb; %Nodes of boundary
inputStruct.faceBoundaryMarker=Cb; 
inputStruct.regionPoints=Pn; %Interior points for regions
inputStruct.holePoints=[]; %Interior points for holes
inputStruct.regionA=tetVolMeanEst(Fb,Vb); %Desired tetrahedral volume for each region

% Mesh model using tetrahedral elements using tetGen 
[meshOutput]=runTetGen(inputStruct); %Run tetGen 

%% 
% Access mesh output structure

E_face=meshOutput.elements; %The elements
V=meshOutput.nodes; %The vertices or nodes
F=meshOutput.faces; %Element faces (all)
CE=meshOutput.elementMaterialID; %Element material or region id
Fb=meshOutput.facesBoundary; %The boundary faces
Cb=meshOutput.boundaryMarker; %The boundary markers

%%
% Visualization

hf=cFigure; 
subplot(1,2,1); hold on;
title('Input boundaries','FontSize',fontSize);
hp(1)=gpatch(Fb,V,Cb,'k',faceAlpha1);
hp(2)=plotV(Pn,'r.','MarkerSize',markerSize1);
legend(hp,{'Input mesh','Interior point(s)'},'Location','NorthWestOutside');
axisGeom(gca,fontSize); camlight headlight;
colormap(cMap); icolorbar;

hs=subplot(1,2,2); hold on;
title('Tetrahedral mesh','FontSize',fontSize);

% Visualizing using |meshView|
optionStruct.hFig=[hf,hs];

meshView(meshOutput,optionStruct);
hold on; plotV(Pn,'r.','MarkerSize',25);
axisGeom(gca,fontSize); 
gdrawnow;

%%

pp9=V_markers(5,:);% (0.1*V_markers(1,:)+0.9*V_markers(5,:));

t=linspace(0.5*pi,2.5*pi,numPointsRimCurve+1)';
t=t(1:end-1);
Vcd1=maskDiscRadius1*[cos(t) sin(t) zeros(size(t))];
Vcd1=Vcd1+pp9;
Vcd1(:,3)=maskDiscOffset;

Vcd2=maskDiscRadius2*[cos(t) sin(t) zeros(size(t))];
Vcd2=Vcd2+pp9;
Vcd2(:,3)=maskDiscOffset;

%
cFigure; hold on;
gpatch(Fb,V,'w','none',0.5);
plotV(V_markers,'r.','MarkerSize',50);
text(V_markers(:,1)+4,V_markers(:,2),V_markers(:,3)+10,{'1','2','3','4','5','6'},'FontSize',25);

plotV(V_rim_points,'k.','MarkerSize',35);
plotV(V_rim_curve,'k-','LineWidth',6);
plotV(Vcd1,'b-','LineWidth',6);
plotV(Vcd2,'b-','LineWidth',6);
axisGeom;
camlight headlight;
view(2);
drawnow;

%%

V_rim_curve1=evenlySampleCurve(V_rim_points1,numPointsRimCurve,'pchip',1);
V_rim_curve2=evenlySampleCurve(V_rim_points2,numPointsRimCurve,'pchip',1);

V_rim_curve1=traceToSurf(V_rim_curve1,[0 0 -1],Fb(Cb==1,:),V,optionStructRayTrace);
V_rim_curve2=traceToSurf(V_rim_curve2,[0 0 -1],Fb(Cb==1,:),V,optionStructRayTrace);

%%
cFigure; hold on;
gpatch(Fb(Cb==1,:),Vb,'kw','none',0.5);

% patchNormPlot(Fm,Vm);
plotV(V_markers,'r.','MarkerSize',50);
text(V_markers(:,1)+2,V_markers(:,2),V_markers(:,3),{'1','2','3','4','5','6'},'FontSize',25);
plotV(V_rim_points,'k.','MarkerSize',35,'LineWidth',3);
plotV(V_rim_curve,'k-','LineWidth',3);

plotV(V_rim_points1,'g.','MarkerSize',35,'LineWidth',3);
plotV(V_rim_curve1,'g-','LineWidth',3);

plotV(V_rim_points2,'b.','MarkerSize',35,'LineWidth',3);
plotV(V_rim_curve2,'b-','LineWidth',3);

axisGeom; camlight headlight;
view(2);
drawnow;

%%

pointSpacingNow=mean(diff(pathLength(V_rim_curve1)));
numNodStrip=ceil(maskRimWidth./pointSpacingNow); 
if numNodStrip<2
    numNodStrip=2;
end
if iseven(numNodStrip)
    numNodStrip=numNodStrip+1;
end

cParLoft.numSteps=numNodStrip; 
cParLoft.closeLoopOpt=1; 
cParLoft.patchType='tri';
[Fm,Vm,indStart_Vm,indEnd_Vm]=polyLoftLinear(V_rim_curve1,V_rim_curve2,cParLoft);
Fm=fliplr(Fm);
indStart_Vm=fliplr(indStart_Vm);
indEnd_Vm=fliplr(indEnd_Vm);

[~,~,Nm]=patchNormal(Fm,Vm);
Vm=traceToSurf(Vm,Nm,Fb(Cb==1,:),V,optionStructRayTrace);

%%
cFigure; hold on;
gpatch(Fb(Cb==1,:),Vb,'kw','none',0.5);
gpatch(Fm,Vm,'rw','k',1,1);
% patchNormPlot(Fm,Vm);
% plotV(V_markers,'r.','MarkerSize',50);
% text(V_markers(:,1)+4,V_markers(:,2),V_markers(:,3),{'1','2','3','4','5','6'},'FontSize',25);
plotV(V_rim_points,'k.','MarkerSize',35,'LineWidth',3);
plotV(Vm(indStart_Vm,:),'g-','LineWidth',3);
plotV(Vm(indEnd_Vm,:),'b-','LineWidth',3);
axisGeom; camlight headlight;
view(2);
drawnow;

%%

[~,~,Nm]=patchNormal(Fm,Vm);

pointSpacingNow=mean(diff(pathLength(Vm(indStart_Vm,:))));
nRim=ceil((pi/2*maskRimFilletRadius)/pointSpacingNow)+1;
if nRim<4
    nRim=4; 
end

[Fr1,Vr1]=roundMesh(indStart_Vm,Vm,Nm,nRim,maskRimFilletRadius);
[Fr2,Vr2]=roundMesh(indEnd_Vm,Vm,Nm,nRim,maskRimFilletRadius);
indEnd_Vr1=size(Vr1)-numPointsRimCurve+1:1:size(Vr1);
indEnd_Vr2=fliplr(indEnd_Vr1);
[Fr1,Vr1]=quad2tri(Fr1,Vr1,'a');
[Fr2,Vr2]=quad2tri(Fr2,Vr2,'a');

%%

cFigure; hold on;
gpatch(Fb,V,'kw','none',0.5);
gpatch(Fm,Vm,'rw','k',1,1);
gpatch(Fr1,Vr1,'gw','k',1,1);
gpatch(Fr2,Vr2,'bw','k',1,1);
plotV(Vr1(indEnd_Vr1,:),'r-','LineWidth',3);
plotV(Vr2(indEnd_Vr2,:),'b-','LineWidth',3);
axisGeom; camlight headlight;
view(2);
drawnow;


%%

pointSpacingNow=mean(diff(pathLength(Vr1(indEnd_Vr1,:))));
numNodStripTop=ceil((maskRimWidth+2*maskRimFilletRadius)./pointSpacingNow); 
if numNodStripTop<2
    numNodStripTop=2;
end
if iseven(numNodStripTop)
    numNodStripTop=numNodStripTop+1;
end

cParLoft.numSteps=numNodStripTop; 
cParLoft.closeLoopOpt=1; 
cParLoft.patchType='tri';
[Ft,Vt,indCurve1_Vt,indCurve2_Vt]=polyLoftLinear(Vr1(indEnd_Vr1,:),Vr2(indEnd_Vr2,:),cParLoft);
Ft=fliplr(Ft);
indCurve1_Vt=flipud(indCurve1_Vt(:));
% indCurve2_Vt=flipud(indCurve2_Vt(:));
[~,~,Nt]=patchNormal(Ft,Vt);

%%

cFigure; hold on;
gpatch(Fb,V,'w','none',1);
gpatch(Fm,Vm,'y','k',0,1);
gpatch(Ft,Vt,'gw','k',1,1);
gpatch(Fr1,Vr1,'rw','k',1,1);
gpatch(Fr2,Vr2,'bw','k',1,1);
plotV(Vr1(indEnd_Vr1,:),'r-','LineWidth',3);
plotV(Vr2(indEnd_Vr1,:),'b-','LineWidth',3);
axisGeom; camlight headlight;
view(2);
drawnow;

%% Join and merge rim surfaces

[F_rim,V_rim,C_rim]=joinElementSets({Fm,Fr1,Fr2,Ft},{Vm,Vr1,Vr2,Vt});
[F_rim,V_rim]=mergeVertices(F_rim,V_rim);
[F_rim,V_rim]=patchCleanUnused(F_rim,V_rim);

%%

cFigure; hold on;
gpatch(Fb(Cb==1,:),V,'w','none',1);
gpatch(F_rim,V_rim,C_rim,'none',1);
% patchNormPlot(F_rim,V_rim);
axisGeom; camlight headlight;
colormap spectral; icolorbar; 
drawnow;

%%

V_loft1=Vt(indCurve1_Vt,:);
V_loft2=Vcd2;

V_loft3=Vt(indCurve2_Vt,:);
V_loft4=Vcd1;

[~,indMax]=max(V_loft4(:,1));
if indMax<numPointsRimCurve/2
    V_loft4=flipud(V_loft4);
end

[~,indMax]=max(V_loft2(:,1));
if indMax<numPointsRimCurve/2
    V_loft2=flipud(V_loft2);
end

N1=Nt(indCurve1_Vt,:);
N3=Nt(indCurve2_Vt,:);
N4=ones(size(V_loft4,1),1)*[0 0 1];

N2e=vecnormalize([V_loft2(2:end,:); V_loft2(1,:)]-V_loft2(1:end,:));
N2=vecnormalize(cross(N4,N2e));

[Fd1,Vd1,X,Y,Z]=bezierLoft(V_loft1,V_loft2,N1,N2,pointSpacingMask,bezierTangency);
[Fd1,Vd1]=quad2tri(Fd1,Vd1);
[Fd2,Vd2,X,Y,Z]=bezierLoft(V_loft3,V_loft4,N3,N4,pointSpacingMask,bezierTangency);
[Fd2,Vd2]=quad2tri(Fd2,Vd2);

pointSpacingNow=mean(diff(pathLength(V_loft2)));
n=ceil((maskDiscRadius2-maskDiscRadius1)./pointSpacingNow);
if n<2
    n=2;
end
if iseven(n)
    n=n+1;
end

cParLoft.numSteps=n; 
cParLoft.closeLoopOpt=1; 
cParLoft.patchType='tri';
[Fdt,Vdt]=polyLoftLinear(V_loft2,V_loft4,cParLoft);

[Fc,Vc]=regionTriMesh2D({V_loft4(:,[1 2])},pointSpacingNow,0,0);
Vc(:,3)=maskDiscOffset;

%%

cFigure; hold on;
gpatch(Fb(Cb==1,:),V,'kw','none',0.5);
gpatch(F_rim,V_rim,'kw','none',1);

gpatch(Fd1,Vd1,'rw','none',0.5);
gpatch(Fd2,Vd2,'bw','none',0.5);
gpatch(Fdt,Vdt,'gw','none',0.5);
gpatch(Fc,Vc,'yw','none',0.5);

plotV(V_loft1,'r-','LineWidth',3);
quiverVec(V_loft1,N1,5,'k');

plotV(V_loft4,'b-','LineWidth',2);
quiverVec(V_loft4,N4,5,'k');

plotV(V_loft3,'b-','LineWidth',3);
quiverVec(V_loft3,N3,5,'k');

plotV(V_loft2,'r-','LineWidth',2);

quiverVec(V_loft2,N2,5,'k');

axisGeom; camlight headlight;
drawnow;

%% Join and merge mask body components

[F_mask,V_mask,C_mask]=joinElementSets({Ft,Fd1,Fd2,Fdt,Fc},{Vt,Vd1,Vd2,Vdt,Vc});
[F_mask,V_mask]=mergeVertices(F_mask,V_mask);
[F_mask,V_mask]=patchCleanUnused(F_mask,V_mask);

%%
cFigure; hold on;
gpatch(Ff,Vf,'w','none',1);
% gpatch(Fb,V,'w','none',1);
gpatch(F_mask,V_mask,'bw','none',1);
gpatch(F_rim,V_rim,'kw','none',1);
axisGeom; camlight headlight;
view(2);
% colormap spectral; icolorbar; 
drawnow;

%%
cFigure; hold on;
gpatch(Ff,Vf,'w','none',1);
% gpatch(Fb,V,'w','none',1);
% gpatch(F_mask,V_mask,'gw','none',0.5);
gpatch(F_rim,V_rim,'kw','none',1);
axisGeom; camlight headlight;
drawnow;

%%

cFigure; hold on;
% gpatch(Fp1,V,'w','none',1);
gpatch(F_mask,V_mask,'bw','none',1);
gpatch(F_rim,V_rim,'gw','none',1);
axisGeom;
camlight headlight;
view(2);
drawnow;

%%

cFigure; hold on;
% gpatch(Fb,V,'w','none',0.9);
gpatch(F_rim,V_rim,C_rim,'k',1);
% patchNormPlot(F_rim,V_rim);
axisGeom;
camlight headlight;
view(2);
colormap gjet; icolorbar;
drawnow;

%%

[V_regions]=getInnerPoint(F_rim,V_rim); % Define region points

%%

cFigure; hold on;
gpatch(F_rim,V_rim,C_rim,'k',1);
% plotV(V_regions,'r.','MarkerSize',markerSize1)
axisGeom;
camlight headlight; view(2);
drawnow;

%%

[regionA]=tetVolMeanEst(F_rim,V_rim); %Volume for regular tets

inputStruct.stringOpt='-pq1.2AaY';
inputStruct.Faces=F_rim;
inputStruct.Nodes=V_rim;
inputStruct.holePoints=[];
inputStruct.faceBoundaryMarker=C_rim; %Face boundary markers
inputStruct.regionPoints=V_regions; %region points
inputStruct.regionA=regionA;

% Mesh model using tetrahedral elements using tetGen
[meshOutput]=runTetGen(inputStruct); %Run tetGen

%%
% Access model element and patch data
Fb_rim=meshOutput.facesBoundary;
Cb_rim=meshOutput.boundaryMarker;
V_rim=meshOutput.nodes;
E_rim=meshOutput.elements;

% Visualizing mesh using |meshView|, see also |anim8|
meshView(meshOutput);

%% Join node sets
V_rim(:,3)=V_rim(:,3)+initialOffset;
Fb_rim=Fb_rim+size(V,1);
E_rim=E_rim+size(V,1);
V=[V;V_rim];

%%
cFigure;
gpatch(F,V,'w','k',1);
gpatch(Fb_rim,V,Cb_rim,'k',1);
axisGeom;
colormap gjet; icolorbar;
camlight headlight;
drawnow;

%% Define contact surfaces

% The rigid primary surface of the sphere
F_contact_primary=fliplr(Fb_rim(Cb_rim~=4,:));

% The deformable secondary surface of the slab
Fb_contact=Fb(Cb==1,:);
V_Fb_centre=patchCentre(Fb_contact,V);
D=minDist(V_Fb_centre,V_rim);
logicSecondary=D<=(2*pointSpacingTissue);
logicSecondary=triSurfLogicSharpFix(Fb_contact,logicSecondary,3);
F_contact_secondary=fliplr(Fb_contact(logicSecondary,:));

%%
% Visualize contact surfaces

cFigure; hold on;
title('Contact sets and normal directions','FontSize',fontSize);

gpatch(Fb,V,'kw','none',0.5);

hl(1)=gpatch(F_contact_primary,V,'gw','k',1);
patchNormPlot(F_contact_primary,V);
hl(2)=gpatch(F_contact_secondary,V,'rw','k',1);
patchNormPlot(F_contact_secondary,V);

legend(hl,{'Primary','secondary'});

axisGeom(gca,fontSize);
camlight headlight;
drawnow;

%% Define boundary conditions

%Supported nodes
bcSupportList=unique(Fb(Cb==2,:));

%Prescribed displacement nodes
bcPrescribeList=unique(Fb_rim(Cb_rim==4,:));

%%
% Visualize BC's

hf=cFigure; hold on;
% title('Boundary conditions model','FontSize',fontSize);
gpatch(Fb,V,'kw','none',faceAlpha2);
gpatch(Fb_rim(Cb_rim~=4,:),V,'kw','none',faceAlpha2);
gpatch(Fb_rim(Cb_rim==4,:),V,'rw','none',1);
gpatch(Fb(Cb==2,:),V,'kw','none',1);
hl2(1)=plotV(V(bcPrescribeList,:),'r.','MarkerSize',markerSize2);
hl2(2)=plotV(V(bcSupportList,:),'k.','MarkerSize',markerSize2);
legend(hl2,{'BC prescribe','BC support'});
axisGeom(gca,fontSize); camlight headlight;
drawnow;

%% Defining the FEBio input structure
% See also |febioStructTemplate| and |febioStruct2xml| and the FEBio user
% manual.

%Get a template with default settings 
[febio_spec]=febioStructTemplate;

%febio_spec version 
febio_spec.ATTR.version='4.0'; 

%Module section
febio_spec.Module.ATTR.type='solid'; 

%Control section
febio_spec.Control.analysis='STATIC';
febio_spec.Control.time_steps=numTimeSteps;
febio_spec.Control.step_size=1/numTimeSteps;
febio_spec.Control.solver.max_refs=max_refs;
febio_spec.Control.solver.qn_method.max_ups=max_ups;
febio_spec.Control.solver.symmetric_stiffness=symmetric_stiffness;
febio_spec.Control.time_stepper.dtmin=dtmin;
febio_spec.Control.time_stepper.dtmax=dtmax; 
febio_spec.Control.time_stepper.max_retries=max_retries;
febio_spec.Control.time_stepper.opt_iter=opt_iter;

%Material section
materialName1='Material1';
febio_spec.Material.material{1}.ATTR.name=materialName1;
febio_spec.Material.material{1}.ATTR.type='Ogden unconstrained';
febio_spec.Material.material{1}.ATTR.id=1;
febio_spec.Material.material{1}.c1=c1_tissue;
febio_spec.Material.material{1}.m1=m1_tissue;
febio_spec.Material.material{1}.c2=c1_tissue;
febio_spec.Material.material{1}.m2=-m1_tissue;
febio_spec.Material.material{1}.cp=k_tissue;

materialName2='Material2';
febio_spec.Material.material{2}.ATTR.name=materialName2;
febio_spec.Material.material{2}.ATTR.type='Ogden unconstrained';
febio_spec.Material.material{2}.ATTR.id=2;
febio_spec.Material.material{2}.c1=c1_rim;
febio_spec.Material.material{2}.m1=m1_rim;
febio_spec.Material.material{2}.c2=c1_rim;
febio_spec.Material.material{2}.m2=-m1_rim;
febio_spec.Material.material{2}.cp=k_rim;

% Mesh section
% -> Nodes
febio_spec.Mesh.Nodes{1}.ATTR.name='All'; %The node set name
febio_spec.Mesh.Nodes{1}.node.ATTR.id=(1:size(V,1))'; %The node id's
febio_spec.Mesh.Nodes{1}.node.VAL=V; %The nodel coordinates

% -> Elements
partName1='Part1';
febio_spec.Mesh.Elements{1}.ATTR.name=partName1; %Name of this part
febio_spec.Mesh.Elements{1}.ATTR.type='tet4'; %Element type
febio_spec.Mesh.Elements{1}.elem.ATTR.id=(1:1:size(E_face,1))'; %Element id's
febio_spec.Mesh.Elements{1}.elem.VAL=E_face; %The element matrix

partName2='Part2';
febio_spec.Mesh.Elements{2}.ATTR.name=partName2; %Name of this part
febio_spec.Mesh.Elements{2}.ATTR.type='tet4'; %Element type
febio_spec.Mesh.Elements{2}.elem.ATTR.id=size(E_face,1)+(1:1:size(E_rim,1))'; %Element id's
febio_spec.Mesh.Elements{2}.elem.VAL=E_rim; %The element matrix

% -> NodeSets
nodeSetName1='bcSupportList';
febio_spec.Mesh.NodeSet{1}.ATTR.name=nodeSetName1;
febio_spec.Mesh.NodeSet{1}.VAL=mrow(bcSupportList);

nodeSetName2='bcPrescribeList';
febio_spec.Mesh.NodeSet{2}.ATTR.name=nodeSetName2;
febio_spec.Mesh.NodeSet{2}.VAL=mrow(bcPrescribeList);

%MeshDomains section
febio_spec.MeshDomains.SolidDomain{1}.ATTR.name=partName1;
febio_spec.MeshDomains.SolidDomain{1}.ATTR.mat=materialName1;

febio_spec.MeshDomains.SolidDomain{2}.ATTR.name=partName2;
febio_spec.MeshDomains.SolidDomain{2}.ATTR.mat=materialName2;

% -> Surfaces
surfaceName1='contactSurface1';
febio_spec.Mesh.Surface{1}.ATTR.name=surfaceName1;
febio_spec.Mesh.Surface{1}.tri3.ATTR.id=(1:1:size(F_contact_primary,1))';
febio_spec.Mesh.Surface{1}.tri3.VAL=F_contact_primary;

surfaceName2='contactSurface2';
febio_spec.Mesh.Surface{2}.ATTR.name=surfaceName2;
febio_spec.Mesh.Surface{2}.tri3.ATTR.id=(1:1:size(F_contact_secondary,1))';
febio_spec.Mesh.Surface{2}.tri3.VAL=F_contact_secondary;

% -> Surface pairs
contactPairName='Contact1';
febio_spec.Mesh.SurfacePair{1}.ATTR.name=contactPairName;
febio_spec.Mesh.SurfacePair{1}.primary=surfaceName1;
febio_spec.Mesh.SurfacePair{1}.secondary=surfaceName2;


%Boundary condition section 
% -> Fix boundary conditions
febio_spec.Boundary.bc{1}.ATTR.name='zero_displacement_xyz';
febio_spec.Boundary.bc{1}.ATTR.type='zero displacement';
febio_spec.Boundary.bc{1}.ATTR.node_set=nodeSetName1;
febio_spec.Boundary.bc{1}.x_dof=1;
febio_spec.Boundary.bc{1}.y_dof=1;
febio_spec.Boundary.bc{1}.z_dof=1;

febio_spec.Boundary.bc{2}.ATTR.name='zero_displacement_xy';
febio_spec.Boundary.bc{2}.ATTR.type='zero displacement';
febio_spec.Boundary.bc{2}.ATTR.node_set=nodeSetName2;
febio_spec.Boundary.bc{2}.x_dof=1;
febio_spec.Boundary.bc{2}.y_dof=1;
febio_spec.Boundary.bc{2}.z_dof=0;

febio_spec.Boundary.bc{3}.ATTR.name='prescibed_displacement_z';
febio_spec.Boundary.bc{3}.ATTR.type='prescribed displacement';
febio_spec.Boundary.bc{3}.ATTR.node_set=nodeSetName2;
febio_spec.Boundary.bc{3}.dof='z';
febio_spec.Boundary.bc{3}.value.ATTR.lc=1;
febio_spec.Boundary.bc{3}.value.VAL=displacementMagnitude_z;
febio_spec.Boundary.bc{3}.relative=0;

%Contact section
febio_spec.Contact.contact{1}.ATTR.type='sliding-elastic';
febio_spec.Contact.contact{1}.ATTR.surface_pair=contactPairName;
febio_spec.Contact.contact{1}.two_pass=0;
febio_spec.Contact.contact{1}.laugon=laugon;
febio_spec.Contact.contact{1}.tolerance=0.2;
febio_spec.Contact.contact{1}.gaptol=0;
febio_spec.Contact.contact{1}.minaug=minaug;
febio_spec.Contact.contact{1}.maxaug=maxaug;
febio_spec.Contact.contact{1}.search_tol=0.01;
febio_spec.Contact.contact{1}.search_radius=0.1*sqrt(sum((max(V,[],1)-min(V,[],1)).^2,2)); 
febio_spec.Contact.contact{1}.symmetric_stiffness=0;
febio_spec.Contact.contact{1}.auto_penalty=1;
febio_spec.Contact.contact{1}.penalty=contactPenalty;
febio_spec.Contact.contact{1}.fric_coeff=fric_coeff;

%LoadData section
% -> load_controller
febio_spec.LoadData.load_controller{1}.ATTR.name='LC_1';
febio_spec.LoadData.load_controller{1}.ATTR.id=1;
febio_spec.LoadData.load_controller{1}.ATTR.type='loadcurve';
febio_spec.LoadData.load_controller{1}.interpolate='LINEAR';
%febio_spec.LoadData.load_controller{1}.extend='CONSTANT';
febio_spec.LoadData.load_controller{1}.points.pt.VAL=[0 0; 1 1];

%Output section 
% -> log file
febio_spec.Output.logfile.ATTR.file=febioLogFileName;
febio_spec.Output.logfile.node_data{1}.ATTR.file=febioLogFileName_disp;
febio_spec.Output.logfile.node_data{1}.ATTR.data='ux;uy;uz';
febio_spec.Output.logfile.node_data{1}.ATTR.delim=',';

febio_spec.Output.logfile.node_data{2}.ATTR.file=febioLogFileName_force;
febio_spec.Output.logfile.node_data{2}.ATTR.data='Rx;Ry;Rz';
febio_spec.Output.logfile.node_data{2}.ATTR.delim=',';

febio_spec.Output.logfile.element_data{1}.ATTR.file=febioLogFileName_strainEnergy;
febio_spec.Output.logfile.element_data{1}.ATTR.data='sed';
febio_spec.Output.logfile.element_data{1}.ATTR.delim=',';
febio_spec.Output.logfile.element_data{1}.VAL=1:1:size(E_face,1);

% Plotfile section
febio_spec.Output.plotfile.compression=0;

%% Quick viewing of the FEBio input file structure
% The |febView| function can be used to view the xml structure in a MATLAB
% figure window. 

%%
% |febView(febio_spec); %Viewing the febio file|

%% Exporting the FEBio input file
% Exporting the febio_spec structure to an FEBio input file is done using
% the |febioStruct2xml| function. 

febioStruct2xml(febio_spec,febioFebFileName); %Exporting to file and domNode
%system(['gedit ',febioFebFileName,' &']);

%% Running the FEBio analysis
% To run the analysis defined by the created FEBio input file the
% |runMonitorFEBio| function is used. The input for this function is a
% structure defining job settings e.g. the FEBio input file name. The
% optional output runFlag informs the user if the analysis was run
% succesfully. 

febioAnalysis.run_filename=febioFebFileName; %The input file name
febioAnalysis.run_logname=febioLogFileName; %The name for the log file
febioAnalysis.disp_on=1; %Display information on the command window
febioAnalysis.runMode=runMode;
febioAnalysis.maxLogCheckTime=10; %Max log file checking time

[runFlag]=runMonitorFEBio(febioAnalysis);%START FEBio NOW!!!!!!!!

%% Import FEBio results

if runFlag==1 %i.e. a succesful run
    
    %%     
    % Importing nodal displacements from a log file
    dataStruct=importFEBio_logfile(fullfile(savePath,febioLogFileName_disp),0,1);
    
    %Access data
    N_disp_mat=dataStruct.data; %Displacement
    timeVec=dataStruct.time; %Time
    
    %Create deformed coordinate set
    V_DEF=N_disp_mat+repmat(V,[1 1 size(N_disp_mat,3)]);
    
    %%
    % Importing element strain energies from a log file
    dataStruct=importFEBio_logfile(fullfile(savePath,febioLogFileName_strainEnergy),0,1); %Element strain energy
        
    %Access data
    E_sed_mat=dataStruct.data;

    %%
    % Plotting the simulated results using |anim8| to visualize and animate
    % deformations
    cMap_c=gjet(250);
    cMap=[linspacen([1 1 1],cMap_c(1,:),50)'; cMap_c];

    [CV]=faceToVertexMeasure(E_face,V,E_sed_mat(:,:,end));

    % Create basic view and store graphics handle to initiate animation
    hf=cFigure; %Open figure
    gtitle([febioFebFileNamePart,': Press play to animate']);
       
    gpatch(Ffc,Vf,cMap(1,:),'none',1)
    hp1=gpatch(Fb(Cb==1,:),V_DEF(:,:,end),CV,'none',1); %Add graphics object to animate
    hp1.FaceColor='Interp';
    hp2=gpatch(Fb_rim,V_DEF(:,:,end),'w','none',0.25); %Add graphics object to animate
    hp3=gpatch(F_mask,V_mask,'w','none',0.25);
    
    axisGeom(gca,fontSize); camlight headlight;
    colormap(cMap); colorbar;
    caxis([0 max(E_sed_mat(:))/10]);
    axis(axisLim(V_DEF)); %Set axis limits statically    
    axis tight; 
    
    % Set up animation features
    animStruct.Time=timeVec; %The time vector
    for qt=1:1:size(N_disp_mat,3) %Loop over time increments                
        [CV]=faceToVertexMeasure(E_face,V,E_sed_mat(:,:,qt));
        
        DN=N_disp_mat(:,:,qt); %Current displacement
        u=mean(DN(bcPrescribeList,:),1);
        V_mask_def=V_mask+u(ones(size(V_mask,1),1),:);
        
        %Set entries in animation structure
        animStruct.Handles{qt}=[hp1 hp1 hp2 hp3]; %Handles of objects to animate
        animStruct.Props{qt}={'Vertices','CData','Vertices','Vertices'}; %Properties of objects to animate
        animStruct.Set{qt}={V_DEF(:,:,qt),CV,V_DEF(:,:,qt),V_mask_def}; %Property values for to set in order to animate
    end
    anim8(hf,animStruct); %Initiate animation feature
    drawnow;    
    
end

%%
function [varargout]=traceToSurf(V1,N1,F2,V2,optionStructRayTrace)

if size(N1,1)==1
    N1=N1(ones(size(V1,1),1),:);
end

numPoints=size(V1,1);
indFacesIntersect=nan(size(V1,1),2);
for q=1:1:numPoints    
    [P,indFaceIntersect,~,~]=triSurfRayTrace(V1(q,:),N1(q,:),F2,V2,optionStructRayTrace);    
    if size(P,1)>1
        [~,indMin]=minDist(V1(q,:),P);
        %         [~,indMin]=min(d);
        P=P(indMin,:);        
        indFaceIntersect=indFaceIntersect(indMin,:);
    end    
    if ~isempty(P)
        V1(q,:)=P;
        indFacesIntersect(q,:)=indFaceIntersect;
    end    
end

varargout{1}=V1;
varargout{2}=indFacesIntersect;

end

function [Fr,Vr]=roundMesh(indCurve,Vm,Nm,nc,stripRadius)

E=[indCurve(1:end)' [indCurve(2:end) indCurve(1)]'];
ind1=indCurve(1:end)';
ind2=[indCurve(2:end) indCurve(1)]';
ind3=[indCurve(end) indCurve(1:end-1)]';

N1f=Vm(ind2,:)-Vm(ind1,:);
N1b=Vm(ind1,:)-Vm(ind3,:);
Ne=vecnormalize((N1f+N1b)/2);

% Ne=vecnormalize(edgeVec(E,Vm));
Nf=-Nm(E(:,1),:);% -vecnormalize((Nm(E(:,1),:)+Nm(E(:,2),:))/2);
Ne2=vecnormalize(cross(Nf,Ne));

X=repmat(Vm(E(:,1),1),1,nc);
Y=repmat(Vm(E(:,1),2),1,nc);
Z=repmat(Vm(E(:,1),3),1,nc);

t=repmat(linspace(0,pi/2,nc),size(Z,1),1);

X=X+stripRadius.*sin(t).*repmat(Ne2(:,1),1,nc)-stripRadius.*cos(t).*repmat(Nf(:,1),1,nc)+stripRadius.*repmat(Nf(:,1),1,nc);
Y=Y+stripRadius.*sin(t).*repmat(Ne2(:,2),1,nc)-stripRadius.*cos(t).*repmat(Nf(:,2),1,nc)+stripRadius.*repmat(Nf(:,2),1,nc);
Z=Z+stripRadius.*sin(t).*repmat(Ne2(:,3),1,nc)-stripRadius.*cos(t).*repmat(Nf(:,3),1,nc)+stripRadius.*repmat(Nf(:,3),1,nc);

for q=2:1:size(X,2)    
   v=evenlySampleCurve([X(:,q) Y(:,q) Z(:,q)],size(X,1),'pchip',1);  
   X(:,q)=v(:,1);
   Y(:,q)=v(:,2);
   Z(:,q)=v(:,3);
end

[Fr,Vr]=grid2patch(X,Y,Z,[],[1 0 0]);

end
%%

function [F,V,X,Y,Z]=bezierLoft(P1,P4,N1,N4,pointSpacing,f)

D12=sqrt(sum((P1-P4).^2,2));
numPoints=ceil(max(D12)./pointSpacing);
if numPoints<2
    numPoints=2;
end

P2=P1+D12.*f.*N1;
P3=P4-D12.*f.*N4;

X=zeros(numPoints,size(P1,1));
Y=zeros(numPoints,size(P1,1));
Z=zeros(numPoints,size(P1,1));
for q=1:1:size(P1,1)
    p=[P1(q,:); P2(q,:); P3(q,:); P4(q,:)]; %Control points    
    V_bezier=bezierCurve(p,numPoints*2); %Compute bezier curve
    V_bezier=evenlySampleCurve(V_bezier,numPoints,'pchip'); %resample evenly
    X(:,q)=V_bezier(:,1);
    Y(:,q)=V_bezier(:,2);
    Z(:,q)=V_bezier(:,3);
end

%Create quad patch data
[F,V] = surf2patch(X,Y,Z);
I=[(1:size(Z,1)-1)' (1:size(Z,1)-1)' (2:size(Z,1))' (2:size(Z,1))' ];
J=[size(Z,2).*ones(size(Z,1)-1,1) ones(size(Z,1)-1,1) ones(size(Z,1)-1,1) size(Z,2).*ones(size(Z,1)-1,1)];
F_sub=sub2ind(size(Z),I,J);
F=[F;F_sub];
F=fliplr(F);

end

%%
%
% <<gibbVerySmall.gif>>
%
% _*GIBBON*_
% <www.gibboncode.org>
%
% _Kevin Mattheus Moerman_, <gibbon.toolbox@gmail.com>

%% 
% _*GIBBON footer text*_ 
% 
% License: <https://github.com/gibbonCode/GIBBON/blob/master/LICENSE>
% 
% GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for
% image segmentation, image-based modeling, meshing, and finite element
% analysis.
% 
% Copyright (C) 2006-2022 Kevin Mattheus Moerman and the GIBBON contributors
% 
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

##### SOURCE END #####
--></body></html>
