
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>DEMO_febio_0022_multigen_interface_band</title><meta name="generator" content="MATLAB 9.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-04-20"><meta name="DC.source" content="DEMO_febio_0022_multigen_interface_band.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>DEMO_febio_0022_multigen_interface_band</h1><!--introduction--><p>Below is a demonstration for:</p><div><ul><li>Building geometry for limb-like segment with an elastic band wrapped around it</li><li>Defining the boundary conditions</li><li>Coding the febio structure</li><li>Running the model</li><li>Importing and visualizing the displacement results</li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Keywords</a></li><li><a href="#3">Plot settings</a></li><li><a href="#4">Control parameters</a></li><li><a href="#5">Build tissue skin surface top</a></li><li><a href="#6">Build tissue skin surface bottom</a></li><li><a href="#7">Build tissue skin surface middle</a></li><li><a href="#8">Build wrap outer surface</a></li><li><a href="#9">Build bone surface</a></li><li><a href="#10">Capping tissue top</a></li><li><a href="#11">Capping tissue bottom</a></li><li><a href="#12">Capping wrap top</a></li><li><a href="#13">Capping wrap bottom</a></li><li><a href="#14">Visualizing surface geometry</a></li><li><a href="#15">Joining and merging geometry sets</a></li><li><a href="#17">Find solid mesh region interior points</a></li><li><a href="#19">Mesh solid using tetgen</a></li><li><a href="#21">Visualizing mesh</a></li><li><a href="#24">Define boundary condition node sets</a></li><li><a href="#25">Define pressure surface</a></li><li><a href="#27">Create element sets and material indices</a></li><li><a href="#28">Defining the FEBio input structure</a></li><li><a href="#29">Quick viewing of the FEBio input file structure</a></li><li><a href="#31">Exporting the FEBio input file</a></li><li><a href="#32">Running the FEBio analysis</a></li><li><a href="#33">Import FEBio results</a></li></ul></div><h2 id="1">Keywords</h2><div><ul><li>febio_spec version 3.0</li><li>febio, FEBio</li><li>indentation</li><li>contact, sliding, sticky, friction</li><li>rigid body constraints</li><li>tetrahedral elements, tet4</li><li>static, solid</li><li>multi-generational</li><li>hyperelastic, Ogden</li><li>displacement logfile</li><li>stress logfile</li></ul></div><pre class="codeinput">clear; close <span class="string">all</span>; clc;
</pre><h2 id="3">Plot settings</h2><pre class="codeinput">fontSize=15;
faceAlpha1=0.8;
faceAlpha2=0.3;
markerSize=40;
lineWidth=3;
plotColors=gjet(9);
lineWidth1=2;
markerSize1=25;
</pre><h2 id="4">Control parameters</h2><pre class="codeinput"><span class="comment">% Path names</span>
defaultFolder = fileparts(fileparts(mfilename(<span class="string">'fullpath'</span>)));
savePath=fullfile(defaultFolder,<span class="string">'data'</span>,<span class="string">'temp'</span>);

<span class="comment">% Defining file names</span>
febioFebFileNamePart=<span class="string">'tempModel'</span>;
febioFebFileName=fullfile(savePath,[febioFebFileNamePart,<span class="string">'.feb'</span>]); <span class="comment">%FEB file name</span>
febioLogFileName=[febioFebFileNamePart,<span class="string">'.txt'</span>]; <span class="comment">%FEBio log file name</span>
febioLogFileName_disp=[febioFebFileNamePart,<span class="string">'_disp_out.txt'</span>]; <span class="comment">%Log file name for exporting displacement</span>
febioLogFileName_strainEnergy=[febioFebFileNamePart,<span class="string">'_energy_out.txt'</span>]; <span class="comment">%Log file name for exporting strain energy density</span>

<span class="comment">%Material parameter set</span>
c1=1e-3; <span class="comment">%Shear-modulus-like parameter</span>
m1=2; <span class="comment">%Material parameter setting degree of non-linearity</span>
k_factor=1e2; <span class="comment">%Bulk modulus factor</span>
k=c1*k_factor; <span class="comment">%Bulk modulus</span>

<span class="comment">%Multi-generational properties of band</span>
c1_g=[c1/1000 c1*100];
k_g=c1_g*k_factor;

<span class="comment">% FEA control settings</span>
numTimeSteps=6; <span class="comment">%Number of time steps desired</span>
max_refs=25; <span class="comment">%Max reforms</span>
max_ups=0; <span class="comment">%Set to zero to use full-Newton iterations</span>
opt_iter=10; <span class="comment">%Optimum number of iterations</span>
max_retries=5; <span class="comment">%Maximum number of retires</span>
dtmin=(1/numTimeSteps)/100; <span class="comment">%Minimum time step size</span>
dtmax=1/numTimeSteps; <span class="comment">%Maximum time step size</span>

runMode=<span class="string">'external'</span>;<span class="comment">% 'internal' or 'external'</span>

appliedPressure=3e-3; <span class="comment">%pressure value</span>

<span class="comment">% Geometry parameters</span>
tissueRadius=35;
tissueHeight=150;
boneRadius=10;
wrapHeight=24;
wrapThickness=5;
pointSpacing=6; <span class="comment">% Aproximate node spacing</span>
</pre><h2 id="5">Build tissue skin surface top</h2><pre class="codeinput"><span class="comment">%Sketching profile</span>
ns=150;
t=linspace(0,2*pi,ns);
t=t(1:end-1);

x=tissueRadius*cos(t);
y=tissueRadius*sin(t);
z=zeros(size(x));
Vc=[x(:) y(:) z(:)];
np=ceil(max(pathLength(Vc))./pointSpacing);
[Vc]=evenlySampleCurve(Vc,np,<span class="string">'pchip'</span>,1);

<span class="comment">% Extruding model</span>
h=(tissueHeight/2)-wrapHeight/2;
cPar.numSteps=round(h/pointSpacing);
cPar.numSteps=cPar.numSteps+iseven(cPar.numSteps);
cPar.depth=h;
cPar.patchType=<span class="string">'tri'</span>;
cPar.dir=-1;
cPar.closeLoopOpt=1;
[Fg1,Vg1]=polyExtrude(Vc,cPar);
Vg1(:,3)=Vg1(:,3)+tissueHeight/2;

[T,R] = cart2pol(Vg1(:,1),Vg1(:,2));
R=R-(tissueRadius/2*((Vg1(:,3)-(wrapHeight/2))/(tissueHeight/2)).^2);
[Vg1(:,1),Vg1(:,2)] = pol2cart(T,R);

Vg1b=Vg1(cPar.numSteps:cPar.numSteps:end,:);
Vg1t=Vg1(1:cPar.numSteps:end,:);
</pre><h2 id="6">Build tissue skin surface bottom</h2><pre class="codeinput">Fg2=Fg1;
Fg2=fliplr(Fg2);
Vg2=Vg1;
Vg2(:,3)=-Vg2(:,3);
Vg2b=Vg2(cPar.numSteps:cPar.numSteps:end,:);
Vg2t=Vg2(1:cPar.numSteps:end,:);
</pre><h2 id="7">Build tissue skin surface middle</h2><pre class="codeinput"><span class="comment">% Extruding model</span>
h=wrapHeight;
cPar.numSteps=round(h/pointSpacing);
cPar.numSteps=cPar.numSteps+iseven(cPar.numSteps);
cPar.depth=h;
cPar.patchType=<span class="string">'tri'</span>;
cPar.closeLoopOpt=1;

Vc_start=Vg1b;
Vc_end=Vg2b;
[Fg3,Vg3]=polyLoftLinear(Vc_start,Vc_end,cPar);

<span class="comment">% Vg3(:,3)=Vg3(:,3)+tissueHeight/2;</span>
Vg3b=Vg3(cPar.numSteps:cPar.numSteps:end,:);
Vg3t=Vg3(1:cPar.numSteps:end,:);
</pre><h2 id="8">Build wrap outer surface</h2><pre class="codeinput">ns=150;
t=linspace(0,2*pi,ns);
t=t(1:end-1);

x=(tissueRadius+wrapThickness)*cos(t);
y=(tissueRadius+wrapThickness)*sin(t);
z=zeros(size(x));
Vc=[x(:) y(:) z(:)];
np=ceil(max(pathLength(Vc))./pointSpacing);
[Vwt]=evenlySampleCurve(Vc,np,<span class="string">'pchip'</span>,1);
Vwt(:,3)=mean(Vg3t(:,3));
Vwb=Vwt;
Vwb(:,3)=Vwt(:,3)-wrapHeight;

h=wrapHeight;
cPar.numSteps=round(h/pointSpacing);
cPar.numSteps=cPar.numSteps+iseven(cPar.numSteps);
cPar.depth=h;
cPar.patchType=<span class="string">'tri'</span>;
cPar.closeLoopOpt=1;

Vc_start=Vwt;
Vc_end=Vwb;
[Fw1,Vw1]=polyLoftLinear(Vc_start,Vc_end,cPar);
</pre><h2 id="9">Build bone surface</h2><pre class="codeinput">x=boneRadius*cos(t);
y=boneRadius*sin(t);
z=zeros(size(x));
Vc=[x(:) y(:) z(:)];
np=ceil(max(pathLength(Vc))./pointSpacing);
[Vc]=evenlySampleCurve(Vc,np,<span class="string">'pchip'</span>,1);

<span class="comment">% Extruding model</span>
cPar.numSteps=round(tissueHeight/pointSpacing);
cPar.numSteps=cPar.numSteps+iseven(cPar.numSteps);
cPar.depth=tissueHeight;
cPar.patchType=<span class="string">'tri'</span>;
cPar.dir=-1;
cPar.closeLoopOpt=1;
[Fb,Vb]=polyExtrude(Vc,cPar);
Fb=fliplr(Fb);
Vb(:,3)=Vb(:,3)+tissueHeight/2;

Vbb=Vb(cPar.numSteps:cPar.numSteps:end,:);
Vbt=Vb(1:cPar.numSteps:end,:);
</pre><h2 id="10">Capping tissue top</h2><pre class="codeinput">regionCell={Vg1t(:,[1 2]),Vbt(:,[1 2])};
[Ft,Vt]=regionTriMesh2D(regionCell,pointSpacing,0,0);
Vt(:,3)=mean(Vg1t(:,3));
Ft=fliplr(Ft);
</pre><h2 id="11">Capping tissue bottom</h2><pre class="codeinput">regionCell={Vg2t(:,[1 2]),Vbb(:,[1 2])};
[Fgb,Vgb]=regionTriMesh2D(regionCell,pointSpacing,0,0);
Vgb(:,3)=mean(Vg2t(:,3));
</pre><h2 id="12">Capping wrap top</h2><pre class="codeinput">regionCell={Vwt(:,[1 2]),Vg1b(:,[1 2])};
[Fwtt,Vwtt]=regionTriMesh2D(regionCell,pointSpacing,0,0);
Vwtt(:,3)=mean(Vwt(:,3));
Fwtt=fliplr(Fwtt);
</pre><h2 id="13">Capping wrap bottom</h2><pre class="codeinput">regionCell={Vwb(:,[1 2]),Vg2b(:,[1 2])};
[Fwbb,Vwbb]=regionTriMesh2D(regionCell,pointSpacing,0,0);
Vwbb(:,3)=mean(Vwb(:,3));
</pre><h2 id="14">Visualizing surface geometry</h2><pre class="codeinput">cFigure;
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize)
hold <span class="string">on</span>;

gpatch(Fg1,Vg1,plotColors(1,:),<span class="string">'k'</span>);
patchNormPlot(Fg1,Vg1);
plotV(Vg1t,<span class="string">'r.-'</span>,<span class="string">'lineWidth'</span>,lineWidth1,<span class="string">'MarkerSize'</span>,markerSize1);
plotV(Vg1b,<span class="string">'y.-'</span>,<span class="string">'lineWidth'</span>,lineWidth1,<span class="string">'MarkerSize'</span>,markerSize1);

gpatch(Fg2,Vg2,plotColors(2,:),<span class="string">'k'</span>);
patchNormPlot(Fg2,Vg2);
plotV(Vg2t,<span class="string">'r.-'</span>,<span class="string">'lineWidth'</span>,lineWidth1,<span class="string">'MarkerSize'</span>,markerSize1);
plotV(Vg2b,<span class="string">'y.-'</span>,<span class="string">'lineWidth'</span>,lineWidth1,<span class="string">'MarkerSize'</span>,markerSize1);

gpatch(Fg3,Vg3,plotColors(3,:),<span class="string">'k'</span>);
patchNormPlot(Fg3,Vg3);
plotV(Vg3t,<span class="string">'r.-'</span>,<span class="string">'lineWidth'</span>,lineWidth1,<span class="string">'MarkerSize'</span>,markerSize1);
plotV(Vg3b,<span class="string">'y.-'</span>,<span class="string">'lineWidth'</span>,lineWidth1,<span class="string">'MarkerSize'</span>,markerSize1);

gpatch(Fw1,Vw1,plotColors(4,:),<span class="string">'k'</span>);
patchNormPlot(Fw1,Vw1);
plotV(Vwt,<span class="string">'g.-'</span>,<span class="string">'lineWidth'</span>,lineWidth1,<span class="string">'MarkerSize'</span>,markerSize1);
plotV(Vwb,<span class="string">'g.-'</span>,<span class="string">'lineWidth'</span>,lineWidth1,<span class="string">'MarkerSize'</span>,markerSize1);

gpatch(Fb,Vb,plotColors(5,:),<span class="string">'k'</span>);
patchNormPlot(Fb,Vb);
plotV(Vbt,<span class="string">'r.-'</span>,<span class="string">'lineWidth'</span>,lineWidth1,<span class="string">'MarkerSize'</span>,markerSize1);
plotV(Vbb,<span class="string">'y.-'</span>,<span class="string">'lineWidth'</span>,lineWidth1,<span class="string">'MarkerSize'</span>,markerSize1);

gpatch(Ft,Vt,plotColors(6,:),<span class="string">'k'</span>);
patchNormPlot(Ft,Vt);

gpatch(Fgb,Vgb,plotColors(7,:),<span class="string">'k'</span>);
patchNormPlot(Fgb,Vgb);

gpatch(Fwtt,Vwtt,plotColors(8,:),<span class="string">'k'</span>);
patchNormPlot(Fwtt,Vwtt);

gpatch(Fwbb,Vwbb,plotColors(9,:),<span class="string">'k'</span>);
patchNormPlot(Fwbb,Vwbb);

axisGeom;
colormap(plotColors); colorbar;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0022_multigen_interface_band_01.jpg" alt=""> <h2 id="15">Joining and merging geometry sets</h2><pre class="codeinput"><span class="comment">%Joining sets</span>

<span class="comment">%Creating color information</span>
Cg1=1*ones(size(Fg1,1),1); <span class="comment">%Tissue top cylinder</span>
Cg2=2*ones(size(Fg2,1),1); <span class="comment">%Tissue bottom cylinder</span>
Cg3=3*ones(size(Fg3,1),1); <span class="comment">%Tissue middle cylinder</span>
Cw1=4*ones(size(Fw1,1),1); <span class="comment">%Wrap outer cylinder</span>
Cb=5*ones(size(Fb,1),1); <span class="comment">%Bone cylinder</span>
Ct=6*ones(size(Ft,1),1); <span class="comment">%Tissue top</span>
Cgb=7*ones(size(Fgb,1),1); <span class="comment">%Tissue bottom</span>
Cwtt=8*ones(size(Fwtt,1),1); <span class="comment">%Wrap top</span>
Cwbb=9*ones(size(Fwbb,1),1); <span class="comment">%Wrap bottom</span>

[F,V,C]=joinElementSets({Fg1,Fg2,Fg3,Fw1,Fb,Ft,Fgb,Fwtt,Fwbb},{Vg1,Vg2,Vg3,Vw1,Vb,Vt,Vgb,Vwtt,Vwbb},{Cg1,Cg2,Cg3,Cw1,Cb,Ct,Cgb,Cwtt,Cwbb}); <span class="comment">%joining sets together</span>

<span class="comment">%merging sets</span>
[F,V]=mergeVertices(F,V);
</pre><pre class="codeinput">cFigure;
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize)
hold <span class="string">on</span>;

gpatch(F,V,C,<span class="string">'none'</span>,0.5);
<span class="comment">% patchNormPlot(F,V);</span>

axisGeom;
colormap(plotColors); icolorbar;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0022_multigen_interface_band_02.jpg" alt=""> <h2 id="17">Find solid mesh region interior points</h2><pre class="codeinput">logicRegion=ismember(C,[3 4 8 9]);
[V_in_1]=getInnerPoint(F(logicRegion,:),V);

logicRegion=ismember(C,[1 2 3 5 6 7 ]);
[V_in_2]=getInnerPoint(F(logicRegion,:),V);

V_regions=[V_in_1;V_in_2];
</pre><pre class="codeinput">cFigure;
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize)
hold <span class="string">on</span>;

gpatch(F,V,C,<span class="string">'none'</span>,0.2);
plotV(V_in_1,<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,25);
plotV(V_in_2,<span class="string">'b.'</span>,<span class="string">'MarkerSize'</span>,25);

axisGeom;
colormap(plotColors); colorbar;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0022_multigen_interface_band_03.jpg" alt=""> <h2 id="19">Mesh solid using tetgen</h2><pre class="codeinput"><span class="comment">% Create tetgen meshing input structure</span>
modelName=fullfile(savePath,<span class="string">'tempModel'</span>);

<span class="comment">% Regional mesh volume parameter</span>
[regionA]=tetVolMeanEst(F,V); <span class="comment">%Volume for a regular tet based on edge lengths</span>
volumeFactors=(regionA.*ones(size(V_regions,1),1));

inputStruct.stringOpt=<span class="string">'-pq1.2AaY'</span>;
inputStruct.Faces=F;
inputStruct.Nodes=V;
inputStruct.holePoints=[];
inputStruct.faceBoundaryMarker=C; <span class="comment">%Face boundary markers</span>
inputStruct.regionPoints=V_regions; <span class="comment">%region points</span>
inputStruct.regionA=volumeFactors; <span class="comment">%Desired volume for tets</span>
inputStruct.minRegionMarker=2; <span class="comment">%Minimum region marker</span>
inputStruct.modelName=modelName;
</pre><p>Mesh model using tetrahedral elements using tetGen (see: <a href="http://wias-berlin.de/software/tetgen/">http://wias-berlin.de/software/tetgen/</a>)</p><pre class="codeinput">[meshOutput]=runTetGen(inputStruct); <span class="comment">%Run tetGen</span>
</pre><pre class="codeoutput"> 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- TETGEN Tetrahedral meshing --- 20-Apr-2023 10:44:35
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- Writing SMESH file --- 20-Apr-2023 10:44:35
----&gt; Adding node field
----&gt; Adding facet field
----&gt; Adding holes specification
----&gt; Adding region specification
--- Done --- 20-Apr-2023 10:44:35
--- Running TetGen to mesh input boundary--- 20-Apr-2023 10:44:35
Opening /mnt/data/MATLAB/GIBBON/data/temp/tempModel.smesh.
Delaunizing vertices...
Delaunay seconds:  0.014849
Creating surface mesh ...
Surface mesh seconds:  0.002311
Recovering boundaries...
Boundary recovery seconds:  0.00435
Removing exterior tetrahedra ...
Spreading region attributes.
Exterior tets removal seconds:  0.001671
Recovering Delaunayness...
Delaunay recovery seconds:  0.002409
Refining mesh...
  1956 insertions, added 1569 points, 47341 tetrahedra in queue.
  651 insertions, added 477 points, 56522 tetrahedra in queue.
  868 insertions, added 552 points, 62664 tetrahedra in queue.
  1157 insertions, added 444 points, 40125 tetrahedra in queue.
  1542 insertions, added 162 points, 1308 tetrahedra in queue.
Refinement seconds:  0.087088
Smoothing vertices...
Mesh smoothing seconds:  0.130497
Improving mesh...
Mesh improvement seconds:  0.005233

Writing /mnt/data/MATLAB/GIBBON/data/temp/tempModel.1.node.
Writing /mnt/data/MATLAB/GIBBON/data/temp/tempModel.1.ele.
Writing /mnt/data/MATLAB/GIBBON/data/temp/tempModel.1.face.
Writing /mnt/data/MATLAB/GIBBON/data/temp/tempModel.1.edge.

Output seconds:  0.049115
Total running seconds:  0.297754

Statistics:

  Input points: 1468
  Input facets: 3010
  Input segments: 4478
  Input holes: 0
  Input regions: 2

  Mesh points: 4712
  Mesh tetrahedra: 24781
  Mesh faces: 50919
  Mesh faces on exterior boundary: 2714
  Mesh faces on input facets: 3010
  Mesh edges on input segments: 4478
  Steiner points inside domain: 3244

--- Done --- 20-Apr-2023 10:44:36
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- Importing TetGen files --- 20-Apr-2023 10:44:36
--- Done --- 20-Apr-2023 10:44:36
</pre><h2 id="21">Visualizing mesh</h2><pre class="codeinput">meshView(meshOutput);
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0022_multigen_interface_band_04.jpg" alt=""> <p>Access model element and patch data</p><pre class="codeinput">F=meshOutput.faces;
V=meshOutput.nodes;
C=meshOutput.faceMaterialID;
E=meshOutput.elements;
CE=meshOutput.elementMaterialID;

Fb=meshOutput.facesBoundary;
Cb=meshOutput.boundaryMarker;
</pre><pre class="codeinput">cFigure;
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize)
hold <span class="string">on</span>;

gpatch(Fb,V,Cb);

axisGeom;
colormap(plotColors)
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0022_multigen_interface_band_05.jpg" alt=""> <h2 id="24">Define boundary condition node sets</h2><pre class="codeinput">logicRigid=ismember(Cb,[5 6 7]);
bcSupportList=Fb(logicRigid,:);
bcSupportList=unique(bcSupportList(:));
</pre><h2 id="25">Define pressure surface</h2><pre class="codeinput">F_pressure=fliplr(Fb(Cb==3,:));
</pre><p>Plot boundary condition nodes</p><pre class="codeinput">cFigure;
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize)
hold <span class="string">on</span>;

gpatch(Fb,V,Cb,<span class="string">'none'</span>,0.5);
plotV(V(bcSupportList,:),<span class="string">'k.'</span>,<span class="string">'lineWidth'</span>,lineWidth1,<span class="string">'MarkerSize'</span>,markerSize1);
gpatch(F_pressure,V,0.5*ones(1,3),<span class="string">'k'</span>);

axisGeom;
colormap(plotColors);
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0022_multigen_interface_band_06.jpg" alt=""> <h2 id="27">Create element sets and material indices</h2><pre class="codeinput"><span class="comment">%Create material indices</span>
elementMaterialIndices=CE;
elementMaterialIndices(elementMaterialIndices==-3)=1;
elementMaterialIndices(elementMaterialIndices==-2)=2;

<span class="comment">%Order material sets</span>
E1=E(elementMaterialIndices==1,:); <span class="comment">%Tissue material</span>
E2=E(elementMaterialIndices==2,:); <span class="comment">%Wrap material</span>
E=[E1;E2];
</pre><h2 id="28">Defining the FEBio input structure</h2><p>See also <tt>febioStructTemplate</tt> and <tt>febioStruct2xml</tt> and the FEBio user manual.</p><pre class="codeinput"><span class="comment">%Get a template with default settings</span>
[febio_spec]=febioStructTemplate;

<span class="comment">%febio_spec version</span>
febio_spec.ATTR.version=<span class="string">'4.0'</span>;

<span class="comment">%Module section</span>
febio_spec.Module.ATTR.type=<span class="string">'solid'</span>;

<span class="comment">%Create control structure for use by all steps</span>
stepStruct.Control.time_steps=numTimeSteps;
stepStruct.Control.step_size=1/numTimeSteps;
stepStruct.Control.solver.max_refs=max_refs;
stepStruct.Control.time_stepper.dtmin=dtmin;
stepStruct.Control.time_stepper.dtmax=dtmax;
stepStruct.Control.time_stepper.max_retries=max_retries;
stepStruct.Control.time_stepper.opt_iter=opt_iter;

<span class="comment">%Add template based default settings to proposed control section</span>
[stepStruct.Control]=structComplete(stepStruct.Control,febio_spec.Control,1); <span class="comment">%Complement provided with default if missing</span>

<span class="comment">%Remove control field (part of template) since step specific control sections are used</span>
febio_spec=rmfield(febio_spec,<span class="string">'Control'</span>);

febio_spec.Step.step{1}.Control=stepStruct.Control;
febio_spec.Step.step{1}.ATTR.id=1;
febio_spec.Step.step{2}.Control=stepStruct.Control;
febio_spec.Step.step{2}.ATTR.id=2;

<span class="comment">%Material section</span>
materialName1=<span class="string">'Normal_material'</span>;
febio_spec.Material.material{1}.ATTR.name=materialName1;
febio_spec.Material.material{1}.ATTR.id=1;
febio_spec.Material.material{1}.ATTR.type=<span class="string">'Ogden unconstrained'</span>;
febio_spec.Material.material{1}.c1=c1;
febio_spec.Material.material{1}.m1=m1;
febio_spec.Material.material{1}.c2=c1;
febio_spec.Material.material{1}.m2=-m1;
febio_spec.Material.material{1}.cp=k;

materialName2=<span class="string">'Multigen_material'</span>;
febio_spec.Material.material{2}.ATTR.name=materialName2;
febio_spec.Material.material{2}.ATTR.id=2;
febio_spec.Material.material{2}.ATTR.type=<span class="string">'multigeneration'</span>;

febio_spec.Material.material{2}.generation{1}.ATTR.id=1;
febio_spec.Material.material{2}.generation{1}.start_time=0;
febio_spec.Material.material{2}.generation{1}.solid{1}.ATTR.type=<span class="string">'Ogden unconstrained'</span>;
febio_spec.Material.material{2}.generation{1}.solid{1}.c1=c1_g(1);
febio_spec.Material.material{2}.generation{1}.solid{1}.m1=m1;
febio_spec.Material.material{2}.generation{1}.solid{1}.c2=c1_g(1);
febio_spec.Material.material{2}.generation{1}.solid{1}.m2=-m1;
febio_spec.Material.material{2}.generation{1}.solid{1}.cp=k_g(1);

febio_spec.Material.material{2}.generation{2}.ATTR.id=2;
febio_spec.Material.material{2}.generation{2}.start_time=1;
febio_spec.Material.material{2}.generation{2}.solid{1}.ATTR.type=<span class="string">'Ogden unconstrained'</span>;
febio_spec.Material.material{2}.generation{2}.solid{1}.c1=c1_g(2);
febio_spec.Material.material{2}.generation{2}.solid{1}.m1=m1;
febio_spec.Material.material{2}.generation{2}.solid{1}.c2=c1_g(2);
febio_spec.Material.material{2}.generation{2}.solid{1}.m2=-m1;
febio_spec.Material.material{2}.generation{2}.solid{1}.cp=k_g(2);

<span class="comment">%Mesh section</span>
<span class="comment">% -&gt; Nodes</span>
febio_spec.Mesh.Nodes{1}.ATTR.name=<span class="string">'nodeSet_all'</span>; <span class="comment">%The node set name</span>
febio_spec.Mesh.Nodes{1}.node.ATTR.id=(1:size(V,1))'; <span class="comment">%The node id's</span>
febio_spec.Mesh.Nodes{1}.node.VAL=V; <span class="comment">%The nodel coordinates</span>

<span class="comment">% -&gt; Elements</span>
partName1=<span class="string">'Part1'</span>;
febio_spec.Mesh.Elements{1}.ATTR.name=partName1; <span class="comment">%Name of this part</span>
febio_spec.Mesh.Elements{1}.ATTR.type=<span class="string">'tet4'</span>; <span class="comment">%Element type</span>
febio_spec.Mesh.Elements{1}.elem.ATTR.id=(1:1:size(E1,1))'; <span class="comment">%Element id's</span>
febio_spec.Mesh.Elements{1}.elem.VAL=E1;

partName2=<span class="string">'Part2'</span>;
febio_spec.Mesh.Elements{2}.ATTR.name=partName2; <span class="comment">%Name of this part</span>
febio_spec.Mesh.Elements{2}.ATTR.type=<span class="string">'tet4'</span>; <span class="comment">%Element type</span>
febio_spec.Mesh.Elements{2}.elem.ATTR.id=size(E1,1)+(1:1:size(E2,1))'; <span class="comment">%Element id's</span>
febio_spec.Mesh.Elements{2}.elem.VAL=E2;

<span class="comment">% -&gt; NodeSets</span>
nodeSetName1=<span class="string">'bcSupportList'</span>;
febio_spec.Mesh.NodeSet{1}.ATTR.name=nodeSetName1;
febio_spec.Mesh.NodeSet{1}.VAL=mrow(bcSupportList);

<span class="comment">% -&gt; Surfaces</span>
surfaceName1=<span class="string">'LoadedSurface'</span>;
febio_spec.Mesh.Surface{1}.ATTR.name=surfaceName1;
febio_spec.Mesh.Surface{1}.tri3.ATTR.id=(1:1:size(F_pressure,1))';
febio_spec.Mesh.Surface{1}.tri3.VAL=F_pressure;

<span class="comment">%MeshDomains section</span>
febio_spec.MeshDomains.SolidDomain{1}.ATTR.name=partName1;
febio_spec.MeshDomains.SolidDomain{1}.ATTR.mat=materialName1;

febio_spec.MeshDomains.SolidDomain{2}.ATTR.name=partName2;
febio_spec.MeshDomains.SolidDomain{2}.ATTR.mat=materialName2;

<span class="comment">%Boundary condition section</span>
<span class="comment">% -&gt; Fix boundary conditions</span>
febio_spec.Boundary.bc{1}.ATTR.name=<span class="string">'zero_displacement_xyz'</span>;
febio_spec.Boundary.bc{1}.ATTR.type=<span class="string">'zero displacement'</span>;
febio_spec.Boundary.bc{1}.ATTR.node_set=nodeSetName1;
febio_spec.Boundary.bc{1}.x_dof=1;
febio_spec.Boundary.bc{1}.y_dof=1;
febio_spec.Boundary.bc{1}.z_dof=1;

<span class="comment">%Loads section</span>
<span class="comment">% -&gt; Surface load</span>
febio_spec.Loads.surface_load{1}.ATTR.type=<span class="string">'pressure'</span>;
febio_spec.Loads.surface_load{1}.ATTR.surface=surfaceName1;
febio_spec.Loads.surface_load{1}.pressure.ATTR.lc=1;
febio_spec.Loads.surface_load{1}.pressure.VAL=appliedPressure;
febio_spec.Loads.surface_load{1}.symmetric_stiffness=1;

<span class="comment">%LoadData section</span>
<span class="comment">% -&gt; load_controller</span>
febio_spec.LoadData.load_controller{1}.ATTR.name=<span class="string">'LC_1'</span>;
febio_spec.LoadData.load_controller{1}.ATTR.id=1;
febio_spec.LoadData.load_controller{1}.ATTR.type=<span class="string">'loadcurve'</span>;
febio_spec.LoadData.load_controller{1}.interpolate=<span class="string">'LINEAR'</span>;
<span class="comment">%febio_spec.LoadData.load_controller{1}.extend='CONSTANT';</span>
febio_spec.LoadData.load_controller{1}.points.pt.VAL=[0 0; 1 1; 2 0];

<span class="comment">%Output section</span>
<span class="comment">% -&gt; log file</span>
febio_spec.Output.logfile.ATTR.file=febioLogFileName;
febio_spec.Output.logfile.node_data{1}.ATTR.file=febioLogFileName_disp;
febio_spec.Output.logfile.node_data{1}.ATTR.data=<span class="string">'ux;uy;uz'</span>;
febio_spec.Output.logfile.node_data{1}.ATTR.delim=<span class="string">','</span>;

febio_spec.Output.logfile.element_data{1}.ATTR.file=febioLogFileName_strainEnergy;
febio_spec.Output.logfile.element_data{1}.ATTR.data=<span class="string">'sed'</span>;
febio_spec.Output.logfile.element_data{1}.ATTR.delim=<span class="string">','</span>;
</pre><h2 id="29">Quick viewing of the FEBio input file structure</h2><p>The <tt>febView</tt> function can be used to view the xml structure in a MATLAB figure window.</p><p>febView(febio_spec); %Viewing the febio file</p><h2 id="31">Exporting the FEBio input file</h2><p>Exporting the febio_spec structure to an FEBio input file is done using the <tt>febioStruct2xml</tt> function.</p><pre class="codeinput">febioStruct2xml(febio_spec,febioFebFileName); <span class="comment">%Exporting to file and domNode</span>
</pre><h2 id="32">Running the FEBio analysis</h2><p>To run the analysis defined by the created FEBio input file the <tt>runMonitorFEBio</tt> function is used. The input for this function is a structure defining job settings e.g. the FEBio input file name. The optional output runFlag informs the user if the analysis was run succesfully.</p><pre class="codeinput">febioAnalysis.run_filename=febioFebFileName; <span class="comment">%The input file name</span>
febioAnalysis.run_logname=febioLogFileName; <span class="comment">%The name for the log file</span>
febioAnalysis.disp_on=1; <span class="comment">%Display information on the command window</span>
febioAnalysis.runMode=runMode;

[runFlag]=runMonitorFEBio(febioAnalysis);<span class="comment">%START FEBio NOW!!!!!!!!</span>
</pre><pre class="codeoutput"> 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--------&gt;    RUNNING/MONITORING FEBIO JOB    &lt;-------- 20-Apr-2023 10:44:43
FEBio path: /home/kevin/FEBioStudio2/bin/febio4
# Attempt removal of existing log files                20-Apr-2023 10:44:43
 * Removal succesful                                   20-Apr-2023 10:44:43
# Attempt removal of existing .xplt files              20-Apr-2023 10:44:43
 * Removal succesful                                   20-Apr-2023 10:44:43
# Starting FEBio...                                    20-Apr-2023 10:44:43
  Max. total analysis time is: Inf s
 * Waiting for log file creation                       20-Apr-2023 10:44:43
   Max. wait time: 30 s
 * Log file found.                                     20-Apr-2023 10:44:43
# Parsing log file...                                  20-Apr-2023 10:44:43
    number of iterations   : 4                         20-Apr-2023 10:44:45
    number of reformations : 4                         20-Apr-2023 10:44:45
------- converged at time : 0.166667                   20-Apr-2023 10:44:45
    number of iterations   : 4                         20-Apr-2023 10:44:45
    number of reformations : 4                         20-Apr-2023 10:44:45
------- converged at time : 0.333333                   20-Apr-2023 10:44:45
    number of iterations   : 5                         20-Apr-2023 10:44:46
    number of reformations : 5                         20-Apr-2023 10:44:46
------- converged at time : 0.5                        20-Apr-2023 10:44:46
    number of iterations   : 6                         20-Apr-2023 10:44:48
    number of reformations : 6                         20-Apr-2023 10:44:48
------- converged at time : 0.666667                   20-Apr-2023 10:44:48
    number of iterations   : 6                         20-Apr-2023 10:44:49
    number of reformations : 6                         20-Apr-2023 10:44:49
------- converged at time : 0.833333                   20-Apr-2023 10:44:49
    number of iterations   : 4                         20-Apr-2023 10:44:50
    number of reformations : 4                         20-Apr-2023 10:44:50
------- converged at time : 1                          20-Apr-2023 10:44:50
    number of iterations   : 4                         20-Apr-2023 10:44:51
    number of reformations : 4                         20-Apr-2023 10:44:51
------- converged at time : 1.16667                    20-Apr-2023 10:44:51
    number of iterations   : 4                         20-Apr-2023 10:44:52
    number of reformations : 4                         20-Apr-2023 10:44:52
------- converged at time : 1.33333                    20-Apr-2023 10:44:52
    number of iterations   : 4                         20-Apr-2023 10:44:53
    number of reformations : 4                         20-Apr-2023 10:44:53
------- converged at time : 1.5                        20-Apr-2023 10:44:53
    number of iterations   : 3                         20-Apr-2023 10:44:53
    number of reformations : 3                         20-Apr-2023 10:44:53
------- converged at time : 1.66667                    20-Apr-2023 10:44:53
    number of iterations   : 3                         20-Apr-2023 10:44:54
    number of reformations : 3                         20-Apr-2023 10:44:54
------- converged at time : 1.83333                    20-Apr-2023 10:44:54
    number of iterations   : 3                         20-Apr-2023 10:44:55
    number of reformations : 3                         20-Apr-2023 10:44:55
------- converged at time : 2                          20-Apr-2023 10:44:55
 Elapsed time : 0:00:12                                20-Apr-2023 10:44:55
 N O R M A L   T E R M I N A T I O N
# Done                                                 20-Apr-2023 10:44:55
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
</pre><h2 id="33">Import FEBio results</h2><pre class="codeinput"><span class="keyword">if</span> runFlag==1 <span class="comment">%i.e. a succesful run</span>
</pre><p>Importing nodal displacements from a log file</p><pre class="codeinput">    dataStruct=importFEBio_logfile(fullfile(savePath,febioLogFileName_disp),0,1);

    <span class="comment">%Access data</span>
    N_disp_mat=dataStruct.data; <span class="comment">%Displacement</span>
    timeVec=dataStruct.time; <span class="comment">%Time</span>

    <span class="comment">%Create deformed coordinate set</span>
    V_DEF=N_disp_mat+repmat(V,[1 1 size(N_disp_mat,3)]);
</pre><p>Importing element stress from a log file</p><pre class="codeinput">    dataStruct=importFEBio_logfile(fullfile(savePath,febioLogFileName_strainEnergy),0,1);

    <span class="comment">%Access data</span>
    E_energy=dataStruct.data;
</pre><p>Plotting the simulated results using <tt>anim8</tt> to visualize and animate deformations</p><pre class="codeinput">    c1_plot=c1*ones(size(timeVec));
    cg_plot=c1_g(1)*ones(size(timeVec));
    cg_plot(timeVec&gt;=1)=c1_g(2);

    [CV]=faceToVertexMeasure(E,V,E_energy(:,:,end));

    <span class="comment">% Create basic view and store graphics handle to initiate animation</span>
    hf=cFigure; <span class="comment">%Open figure</span>
    gtitle([febioFebFileNamePart,<span class="string">': Press play to animate'</span>]);

    subplot(1,2,1); hold <span class="string">on</span>;
    title(<span class="string">'Ogden parameter c_1'</span>);
    xlabel(<span class="string">'Time'</span>); ylabel(<span class="string">'c_1'</span>);
    plot(timeVec,c1_plot,<span class="string">'b-'</span>,<span class="string">'lineWidth'</span>,2);
    plot(timeVec,cg_plot,<span class="string">'r-'</span>,<span class="string">'lineWidth'</span>,2);
    hp1=plot(timeVec(1),c1_plot(1),<span class="string">'b.'</span>,<span class="string">'MarkerSize'</span>,50);
    hp2=plot(timeVec(1),cg_plot(1),<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,50);
    legend([hp1 hp2],<span class="string">'Material 1'</span>,<span class="string">'Material 2'</span>);
    axis <span class="string">tight</span>; axis <span class="string">square</span>; set(gca,<span class="string">'fontsize'</span>,fontSize);
    grid <span class="string">on</span>;

    subplot(1,2,2); hold <span class="string">on</span>;
    hp3=gpatch(Fb,V_DEF(:,:,end),CV,<span class="string">'k'</span>,1); <span class="comment">%Add graphics object to animate</span>
    hp3.FaceColor=<span class="string">'interp'</span>;
    colormap(gjet(250)); hc=colorbar;
    caxis([0 max(E_energy(:))]/10);
    axisGeom(gca,fontSize);
    axis(axisLim(V_DEF)); <span class="comment">%Set axis limits statically</span>
    axis <span class="string">manual</span>;
    camlight <span class="string">headlight</span>;
    drawnow;

    <span class="comment">% Set up animation features</span>
    animStruct.Time=timeVec; <span class="comment">%The time vector</span>
    <span class="keyword">for</span> qt=1:1:size(N_disp_mat,3) <span class="comment">%Loop over time increments</span>
        DN=N_disp_mat(:,:,qt); <span class="comment">%Current displacement</span>
        DN_magnitude=sqrt(sum(DN.^2,2)); <span class="comment">%Current displacement magnitude</span>

        [CV]=faceToVertexMeasure(E,V,E_energy(:,:,qt));

        <span class="comment">%Set entries in animation structure</span>
        animStruct.Handles{qt}=[hp3 hp3 hp1 hp1 hp2 hp2]; <span class="comment">%Handles of objects to animate</span>
        animStruct.Props{qt}={<span class="string">'Vertices'</span>,<span class="string">'CData'</span>,<span class="string">'XData'</span>,<span class="string">'YData'</span>,<span class="string">'XData'</span>,<span class="string">'YData'</span>}; <span class="comment">%Properties of objects to animate</span>
        animStruct.Set{qt}={V_DEF(:,:,qt),CV,timeVec(qt),c1_plot(qt),timeVec(qt),cg_plot(qt)}; <span class="comment">%Property values for to set in order to animate</span>
    <span class="keyword">end</span>
    anim8(hf,animStruct); <span class="comment">%Initiate animation feature</span>
    drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0022_multigen_interface_band_07.jpg" alt=""> <pre class="codeinput"><span class="keyword">end</span>
</pre><p><img vspace="5" hspace="5" src="gibbVerySmall.gif" alt=""> </p><p><i><b>GIBBON</b></i> <a href="www.gibboncode.org">www.gibboncode.org</a></p><p><i>Kevin Mattheus Moerman</i>, <a href="gibbon.toolbox@gmail.com">gibbon.toolbox@gmail.com</a></p><p><i><b>GIBBON footer text</b></i></p><p>License: <a href="https://github.com/gibbonCode/GIBBON/blob/master/LICENSE">https://github.com/gibbonCode/GIBBON/blob/master/LICENSE</a></p><p>GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for image segmentation, image-based modeling, meshing, and finite element analysis.</p><p>Copyright (C) 2006-2022 Kevin Mattheus Moerman and the GIBBON contributors</p><p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p><p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p><p>You should have received a copy of the GNU General Public License along with this program.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2022b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% DEMO_febio_0022_multigen_interface_band
% Below is a demonstration for:
% 
% * Building geometry for limb-like segment with an elastic band wrapped around it
% * Defining the boundary conditions 
% * Coding the febio structure
% * Running the model
% * Importing and visualizing the displacement results

%% Keywords
%
% * febio_spec version 3.0
% * febio, FEBio
% * indentation
% * contact, sliding, sticky, friction
% * rigid body constraints
% * tetrahedral elements, tet4
% * static, solid
% * multi-generational
% * hyperelastic, Ogden
% * displacement logfile
% * stress logfile

%%

clear; close all; clc;

%% Plot settings
fontSize=15;
faceAlpha1=0.8;
faceAlpha2=0.3;
markerSize=40;
lineWidth=3;
plotColors=gjet(9);
lineWidth1=2; 
markerSize1=25; 

%% Control parameters

% Path names
defaultFolder = fileparts(fileparts(mfilename('fullpath')));
savePath=fullfile(defaultFolder,'data','temp');

% Defining file names
febioFebFileNamePart='tempModel';
febioFebFileName=fullfile(savePath,[febioFebFileNamePart,'.feb']); %FEB file name
febioLogFileName=[febioFebFileNamePart,'.txt']; %FEBio log file name
febioLogFileName_disp=[febioFebFileNamePart,'_disp_out.txt']; %Log file name for exporting displacement
febioLogFileName_strainEnergy=[febioFebFileNamePart,'_energy_out.txt']; %Log file name for exporting strain energy density

%Material parameter set
c1=1e-3; %Shear-modulus-like parameter
m1=2; %Material parameter setting degree of non-linearity
k_factor=1e2; %Bulk modulus factor 
k=c1*k_factor; %Bulk modulus

%Multi-generational properties of band
c1_g=[c1/1000 c1*100]; 
k_g=c1_g*k_factor;

% FEA control settings
numTimeSteps=6; %Number of time steps desired
max_refs=25; %Max reforms
max_ups=0; %Set to zero to use full-Newton iterations
opt_iter=10; %Optimum number of iterations
max_retries=5; %Maximum number of retires
dtmin=(1/numTimeSteps)/100; %Minimum time step size
dtmax=1/numTimeSteps; %Maximum time step size

runMode='external';% 'internal' or 'external'

appliedPressure=3e-3; %pressure value

% Geometry parameters
tissueRadius=35;
tissueHeight=150;
boneRadius=10;
wrapHeight=24;
wrapThickness=5;
pointSpacing=6; % Aproximate node spacing 

%% Build tissue skin surface top

%Sketching profile
ns=150;
t=linspace(0,2*pi,ns);
t=t(1:end-1);

x=tissueRadius*cos(t);
y=tissueRadius*sin(t);
z=zeros(size(x));
Vc=[x(:) y(:) z(:)];
np=ceil(max(pathLength(Vc))./pointSpacing);
[Vc]=evenlySampleCurve(Vc,np,'pchip',1);
 
% Extruding model
h=(tissueHeight/2)-wrapHeight/2;
cPar.numSteps=round(h/pointSpacing);
cPar.numSteps=cPar.numSteps+iseven(cPar.numSteps); 
cPar.depth=h; 
cPar.patchType='tri'; 
cPar.dir=-1;
cPar.closeLoopOpt=1; 
[Fg1,Vg1]=polyExtrude(Vc,cPar);
Vg1(:,3)=Vg1(:,3)+tissueHeight/2;

[T,R] = cart2pol(Vg1(:,1),Vg1(:,2));
R=R-(tissueRadius/2*((Vg1(:,3)-(wrapHeight/2))/(tissueHeight/2)).^2);
[Vg1(:,1),Vg1(:,2)] = pol2cart(T,R);

Vg1b=Vg1(cPar.numSteps:cPar.numSteps:end,:); 
Vg1t=Vg1(1:cPar.numSteps:end,:); 


%% Build tissue skin surface bottom

Fg2=Fg1; 
Fg2=fliplr(Fg2);
Vg2=Vg1;
Vg2(:,3)=-Vg2(:,3);
Vg2b=Vg2(cPar.numSteps:cPar.numSteps:end,:); 
Vg2t=Vg2(1:cPar.numSteps:end,:); 

%% Build tissue skin surface middle

% Extruding model
h=wrapHeight;
cPar.numSteps=round(h/pointSpacing);
cPar.numSteps=cPar.numSteps+iseven(cPar.numSteps); 
cPar.depth=h; 
cPar.patchType='tri'; 
cPar.closeLoopOpt=1; 

Vc_start=Vg1b;
Vc_end=Vg2b;
[Fg3,Vg3]=polyLoftLinear(Vc_start,Vc_end,cPar);

% Vg3(:,3)=Vg3(:,3)+tissueHeight/2;
Vg3b=Vg3(cPar.numSteps:cPar.numSteps:end,:); 
Vg3t=Vg3(1:cPar.numSteps:end,:); 

%% Build wrap outer surface

ns=150;
t=linspace(0,2*pi,ns);
t=t(1:end-1);

x=(tissueRadius+wrapThickness)*cos(t);
y=(tissueRadius+wrapThickness)*sin(t);
z=zeros(size(x));
Vc=[x(:) y(:) z(:)];
np=ceil(max(pathLength(Vc))./pointSpacing);
[Vwt]=evenlySampleCurve(Vc,np,'pchip',1);
Vwt(:,3)=mean(Vg3t(:,3));
Vwb=Vwt;
Vwb(:,3)=Vwt(:,3)-wrapHeight;

h=wrapHeight;
cPar.numSteps=round(h/pointSpacing);
cPar.numSteps=cPar.numSteps+iseven(cPar.numSteps); 
cPar.depth=h; 
cPar.patchType='tri'; 
cPar.closeLoopOpt=1; 

Vc_start=Vwt;
Vc_end=Vwb;
[Fw1,Vw1]=polyLoftLinear(Vc_start,Vc_end,cPar);

%% Build bone surface

x=boneRadius*cos(t);
y=boneRadius*sin(t);
z=zeros(size(x));
Vc=[x(:) y(:) z(:)];
np=ceil(max(pathLength(Vc))./pointSpacing);
[Vc]=evenlySampleCurve(Vc,np,'pchip',1);

% Extruding model
cPar.numSteps=round(tissueHeight/pointSpacing);
cPar.numSteps=cPar.numSteps+iseven(cPar.numSteps); 
cPar.depth=tissueHeight; 
cPar.patchType='tri'; 
cPar.dir=-1;
cPar.closeLoopOpt=1; 
[Fb,Vb]=polyExtrude(Vc,cPar);
Fb=fliplr(Fb);
Vb(:,3)=Vb(:,3)+tissueHeight/2;

Vbb=Vb(cPar.numSteps:cPar.numSteps:end,:); 
Vbt=Vb(1:cPar.numSteps:end,:); 

%% Capping tissue top

regionCell={Vg1t(:,[1 2]),Vbt(:,[1 2])};
[Ft,Vt]=regionTriMesh2D(regionCell,pointSpacing,0,0);
Vt(:,3)=mean(Vg1t(:,3));
Ft=fliplr(Ft);

%% Capping tissue bottom

regionCell={Vg2t(:,[1 2]),Vbb(:,[1 2])};
[Fgb,Vgb]=regionTriMesh2D(regionCell,pointSpacing,0,0);
Vgb(:,3)=mean(Vg2t(:,3));

%% Capping wrap top

regionCell={Vwt(:,[1 2]),Vg1b(:,[1 2])};
[Fwtt,Vwtt]=regionTriMesh2D(regionCell,pointSpacing,0,0);
Vwtt(:,3)=mean(Vwt(:,3));
Fwtt=fliplr(Fwtt);

%% Capping wrap bottom

regionCell={Vwb(:,[1 2]),Vg2b(:,[1 2])};
[Fwbb,Vwbb]=regionTriMesh2D(regionCell,pointSpacing,0,0);
Vwbb(:,3)=mean(Vwb(:,3));

%% Visualizing surface geometry

cFigure;
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize)
hold on;

gpatch(Fg1,Vg1,plotColors(1,:),'k');
patchNormPlot(Fg1,Vg1);
plotV(Vg1t,'r.-','lineWidth',lineWidth1,'MarkerSize',markerSize1);
plotV(Vg1b,'y.-','lineWidth',lineWidth1,'MarkerSize',markerSize1);

gpatch(Fg2,Vg2,plotColors(2,:),'k');
patchNormPlot(Fg2,Vg2);
plotV(Vg2t,'r.-','lineWidth',lineWidth1,'MarkerSize',markerSize1);
plotV(Vg2b,'y.-','lineWidth',lineWidth1,'MarkerSize',markerSize1);

gpatch(Fg3,Vg3,plotColors(3,:),'k');
patchNormPlot(Fg3,Vg3);
plotV(Vg3t,'r.-','lineWidth',lineWidth1,'MarkerSize',markerSize1);
plotV(Vg3b,'y.-','lineWidth',lineWidth1,'MarkerSize',markerSize1);

gpatch(Fw1,Vw1,plotColors(4,:),'k');
patchNormPlot(Fw1,Vw1);
plotV(Vwt,'g.-','lineWidth',lineWidth1,'MarkerSize',markerSize1);
plotV(Vwb,'g.-','lineWidth',lineWidth1,'MarkerSize',markerSize1);

gpatch(Fb,Vb,plotColors(5,:),'k');
patchNormPlot(Fb,Vb);
plotV(Vbt,'r.-','lineWidth',lineWidth1,'MarkerSize',markerSize1);
plotV(Vbb,'y.-','lineWidth',lineWidth1,'MarkerSize',markerSize1);

gpatch(Ft,Vt,plotColors(6,:),'k');
patchNormPlot(Ft,Vt);

gpatch(Fgb,Vgb,plotColors(7,:),'k');
patchNormPlot(Fgb,Vgb);

gpatch(Fwtt,Vwtt,plotColors(8,:),'k');
patchNormPlot(Fwtt,Vwtt);

gpatch(Fwbb,Vwbb,plotColors(9,:),'k');
patchNormPlot(Fwbb,Vwbb);

axisGeom; 
colormap(plotColors); colorbar;
drawnow; 

%% Joining and merging geometry sets

%Joining sets 

%Creating color information
Cg1=1*ones(size(Fg1,1),1); %Tissue top cylinder
Cg2=2*ones(size(Fg2,1),1); %Tissue bottom cylinder
Cg3=3*ones(size(Fg3,1),1); %Tissue middle cylinder
Cw1=4*ones(size(Fw1,1),1); %Wrap outer cylinder
Cb=5*ones(size(Fb,1),1); %Bone cylinder
Ct=6*ones(size(Ft,1),1); %Tissue top
Cgb=7*ones(size(Fgb,1),1); %Tissue bottom
Cwtt=8*ones(size(Fwtt,1),1); %Wrap top
Cwbb=9*ones(size(Fwbb,1),1); %Wrap bottom

[F,V,C]=joinElementSets({Fg1,Fg2,Fg3,Fw1,Fb,Ft,Fgb,Fwtt,Fwbb},{Vg1,Vg2,Vg3,Vw1,Vb,Vt,Vgb,Vwtt,Vwbb},{Cg1,Cg2,Cg3,Cw1,Cb,Ct,Cgb,Cwtt,Cwbb}); %joining sets together

%merging sets
[F,V]=mergeVertices(F,V);

%%

cFigure;
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize)
hold on;

gpatch(F,V,C,'none',0.5);
% patchNormPlot(F,V);

axisGeom; 
colormap(plotColors); icolorbar;
drawnow; 

%% Find solid mesh region interior points

logicRegion=ismember(C,[3 4 8 9]);
[V_in_1]=getInnerPoint(F(logicRegion,:),V);

logicRegion=ismember(C,[1 2 3 5 6 7 ]);
[V_in_2]=getInnerPoint(F(logicRegion,:),V);

V_regions=[V_in_1;V_in_2];

%%

cFigure;
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize)
hold on;

gpatch(F,V,C,'none',0.2);
plotV(V_in_1,'r.','MarkerSize',25);
plotV(V_in_2,'b.','MarkerSize',25);

axisGeom; 
colormap(plotColors); colorbar;
drawnow; 

%% Mesh solid using tetgen

% Create tetgen meshing input structure
modelName=fullfile(savePath,'tempModel');

% Regional mesh volume parameter
[regionA]=tetVolMeanEst(F,V); %Volume for a regular tet based on edge lengths
volumeFactors=(regionA.*ones(size(V_regions,1),1));

inputStruct.stringOpt='-pq1.2AaY';
inputStruct.Faces=F;
inputStruct.Nodes=V;
inputStruct.holePoints=[];
inputStruct.faceBoundaryMarker=C; %Face boundary markers
inputStruct.regionPoints=V_regions; %region points
inputStruct.regionA=volumeFactors; %Desired volume for tets
inputStruct.minRegionMarker=2; %Minimum region marker
inputStruct.modelName=modelName;

%% 
% Mesh model using tetrahedral elements using tetGen (see:
% <http://wias-berlin.de/software/tetgen/>)

[meshOutput]=runTetGen(inputStruct); %Run tetGen 

%% Visualizing mesh
meshView(meshOutput);

%% 
% Access model element and patch data 
F=meshOutput.faces;
V=meshOutput.nodes;
C=meshOutput.faceMaterialID;
E=meshOutput.elements;
CE=meshOutput.elementMaterialID;

Fb=meshOutput.facesBoundary;
Cb=meshOutput.boundaryMarker;

%%

cFigure;
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize)
hold on;

gpatch(Fb,V,Cb);

axisGeom;
colormap(plotColors)
drawnow; 

%% Define boundary condition node sets

logicRigid=ismember(Cb,[5 6 7]);
bcSupportList=Fb(logicRigid,:);
bcSupportList=unique(bcSupportList(:));

%% Define pressure surface

F_pressure=fliplr(Fb(Cb==3,:));

%%
% Plot boundary condition nodes
cFigure;
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize)
hold on;

gpatch(Fb,V,Cb,'none',0.5);
plotV(V(bcSupportList,:),'k.','lineWidth',lineWidth1,'MarkerSize',markerSize1);
gpatch(F_pressure,V,0.5*ones(1,3),'k');

axisGeom;
colormap(plotColors); 
drawnow; 

%% Create element sets and material indices

%Create material indices
elementMaterialIndices=CE;
elementMaterialIndices(elementMaterialIndices==-3)=1; 
elementMaterialIndices(elementMaterialIndices==-2)=2; 

%Order material sets
E1=E(elementMaterialIndices==1,:); %Tissue material
E2=E(elementMaterialIndices==2,:); %Wrap material
E=[E1;E2];


%% Defining the FEBio input structure
% See also |febioStructTemplate| and |febioStruct2xml| and the FEBio user
% manual.

%Get a template with default settings 
[febio_spec]=febioStructTemplate;

%febio_spec version 
febio_spec.ATTR.version='4.0'; 

%Module section
febio_spec.Module.ATTR.type='solid'; 

%Create control structure for use by all steps
stepStruct.Control.time_steps=numTimeSteps;
stepStruct.Control.step_size=1/numTimeSteps;
stepStruct.Control.solver.max_refs=max_refs;
stepStruct.Control.time_stepper.dtmin=dtmin;
stepStruct.Control.time_stepper.dtmax=dtmax; 
stepStruct.Control.time_stepper.max_retries=max_retries;
stepStruct.Control.time_stepper.opt_iter=opt_iter;

%Add template based default settings to proposed control section
[stepStruct.Control]=structComplete(stepStruct.Control,febio_spec.Control,1); %Complement provided with default if missing

%Remove control field (part of template) since step specific control sections are used
febio_spec=rmfield(febio_spec,'Control'); 

febio_spec.Step.step{1}.Control=stepStruct.Control;
febio_spec.Step.step{1}.ATTR.id=1;
febio_spec.Step.step{2}.Control=stepStruct.Control;
febio_spec.Step.step{2}.ATTR.id=2;

%Material section
materialName1='Normal_material';
febio_spec.Material.material{1}.ATTR.name=materialName1;
febio_spec.Material.material{1}.ATTR.id=1;
febio_spec.Material.material{1}.ATTR.type='Ogden unconstrained';
febio_spec.Material.material{1}.c1=c1;
febio_spec.Material.material{1}.m1=m1;
febio_spec.Material.material{1}.c2=c1;
febio_spec.Material.material{1}.m2=-m1;
febio_spec.Material.material{1}.cp=k;

materialName2='Multigen_material';
febio_spec.Material.material{2}.ATTR.name=materialName2;
febio_spec.Material.material{2}.ATTR.id=2;
febio_spec.Material.material{2}.ATTR.type='multigeneration';

febio_spec.Material.material{2}.generation{1}.ATTR.id=1; 
febio_spec.Material.material{2}.generation{1}.start_time=0;
febio_spec.Material.material{2}.generation{1}.solid{1}.ATTR.type='Ogden unconstrained';
febio_spec.Material.material{2}.generation{1}.solid{1}.c1=c1_g(1);
febio_spec.Material.material{2}.generation{1}.solid{1}.m1=m1;
febio_spec.Material.material{2}.generation{1}.solid{1}.c2=c1_g(1);
febio_spec.Material.material{2}.generation{1}.solid{1}.m2=-m1;
febio_spec.Material.material{2}.generation{1}.solid{1}.cp=k_g(1);

febio_spec.Material.material{2}.generation{2}.ATTR.id=2; 
febio_spec.Material.material{2}.generation{2}.start_time=1;
febio_spec.Material.material{2}.generation{2}.solid{1}.ATTR.type='Ogden unconstrained';
febio_spec.Material.material{2}.generation{2}.solid{1}.c1=c1_g(2);
febio_spec.Material.material{2}.generation{2}.solid{1}.m1=m1;
febio_spec.Material.material{2}.generation{2}.solid{1}.c2=c1_g(2);
febio_spec.Material.material{2}.generation{2}.solid{1}.m2=-m1;
febio_spec.Material.material{2}.generation{2}.solid{1}.cp=k_g(2);

%Mesh section
% -> Nodes
febio_spec.Mesh.Nodes{1}.ATTR.name='nodeSet_all'; %The node set name
febio_spec.Mesh.Nodes{1}.node.ATTR.id=(1:size(V,1))'; %The node id's
febio_spec.Mesh.Nodes{1}.node.VAL=V; %The nodel coordinates

% -> Elements
partName1='Part1';
febio_spec.Mesh.Elements{1}.ATTR.name=partName1; %Name of this part
febio_spec.Mesh.Elements{1}.ATTR.type='tet4'; %Element type 
febio_spec.Mesh.Elements{1}.elem.ATTR.id=(1:1:size(E1,1))'; %Element id's
febio_spec.Mesh.Elements{1}.elem.VAL=E1;

partName2='Part2';
febio_spec.Mesh.Elements{2}.ATTR.name=partName2; %Name of this part
febio_spec.Mesh.Elements{2}.ATTR.type='tet4'; %Element type 
febio_spec.Mesh.Elements{2}.elem.ATTR.id=size(E1,1)+(1:1:size(E2,1))'; %Element id's
febio_spec.Mesh.Elements{2}.elem.VAL=E2;

% -> NodeSets
nodeSetName1='bcSupportList';
febio_spec.Mesh.NodeSet{1}.ATTR.name=nodeSetName1;
febio_spec.Mesh.NodeSet{1}.VAL=mrow(bcSupportList);

% -> Surfaces
surfaceName1='LoadedSurface';
febio_spec.Mesh.Surface{1}.ATTR.name=surfaceName1;
febio_spec.Mesh.Surface{1}.tri3.ATTR.id=(1:1:size(F_pressure,1))';
febio_spec.Mesh.Surface{1}.tri3.VAL=F_pressure;

%MeshDomains section
febio_spec.MeshDomains.SolidDomain{1}.ATTR.name=partName1;
febio_spec.MeshDomains.SolidDomain{1}.ATTR.mat=materialName1;

febio_spec.MeshDomains.SolidDomain{2}.ATTR.name=partName2;
febio_spec.MeshDomains.SolidDomain{2}.ATTR.mat=materialName2;

%Boundary condition section 
% -> Fix boundary conditions
febio_spec.Boundary.bc{1}.ATTR.name='zero_displacement_xyz';
febio_spec.Boundary.bc{1}.ATTR.type='zero displacement';
febio_spec.Boundary.bc{1}.ATTR.node_set=nodeSetName1;
febio_spec.Boundary.bc{1}.x_dof=1;
febio_spec.Boundary.bc{1}.y_dof=1;
febio_spec.Boundary.bc{1}.z_dof=1;

%Loads section
% -> Surface load
febio_spec.Loads.surface_load{1}.ATTR.type='pressure';
febio_spec.Loads.surface_load{1}.ATTR.surface=surfaceName1;
febio_spec.Loads.surface_load{1}.pressure.ATTR.lc=1;
febio_spec.Loads.surface_load{1}.pressure.VAL=appliedPressure;
febio_spec.Loads.surface_load{1}.symmetric_stiffness=1;
        
%LoadData section
% -> load_controller
febio_spec.LoadData.load_controller{1}.ATTR.name='LC_1';
febio_spec.LoadData.load_controller{1}.ATTR.id=1;
febio_spec.LoadData.load_controller{1}.ATTR.type='loadcurve';
febio_spec.LoadData.load_controller{1}.interpolate='LINEAR';
%febio_spec.LoadData.load_controller{1}.extend='CONSTANT';
febio_spec.LoadData.load_controller{1}.points.pt.VAL=[0 0; 1 1; 2 0];

%Output section 
% -> log file
febio_spec.Output.logfile.ATTR.file=febioLogFileName;
febio_spec.Output.logfile.node_data{1}.ATTR.file=febioLogFileName_disp;
febio_spec.Output.logfile.node_data{1}.ATTR.data='ux;uy;uz';
febio_spec.Output.logfile.node_data{1}.ATTR.delim=',';

febio_spec.Output.logfile.element_data{1}.ATTR.file=febioLogFileName_strainEnergy;
febio_spec.Output.logfile.element_data{1}.ATTR.data='sed';
febio_spec.Output.logfile.element_data{1}.ATTR.delim=',';

%% Quick viewing of the FEBio input file structure
% The |febView| function can be used to view the xml structure in a MATLAB
% figure window. 

%%
% febView(febio_spec); %Viewing the febio file

%% Exporting the FEBio input file
% Exporting the febio_spec structure to an FEBio input file is done using
% the |febioStruct2xml| function. 

febioStruct2xml(febio_spec,febioFebFileName); %Exporting to file and domNode

%% Running the FEBio analysis
% To run the analysis defined by the created FEBio input file the
% |runMonitorFEBio| function is used. The input for this function is a
% structure defining job settings e.g. the FEBio input file name. The
% optional output runFlag informs the user if the analysis was run
% succesfully. 

febioAnalysis.run_filename=febioFebFileName; %The input file name
febioAnalysis.run_logname=febioLogFileName; %The name for the log file
febioAnalysis.disp_on=1; %Display information on the command window
febioAnalysis.runMode=runMode;

[runFlag]=runMonitorFEBio(febioAnalysis);%START FEBio NOW!!!!!!!!

%% Import FEBio results 

if runFlag==1 %i.e. a succesful run
    
    %% 
    % Importing nodal displacements from a log file
    dataStruct=importFEBio_logfile(fullfile(savePath,febioLogFileName_disp),0,1);
    
    %Access data
    N_disp_mat=dataStruct.data; %Displacement
    timeVec=dataStruct.time; %Time
    
    %Create deformed coordinate set
    V_DEF=N_disp_mat+repmat(V,[1 1 size(N_disp_mat,3)]);
    
    %%
    % Importing element stress from a log file
    dataStruct=importFEBio_logfile(fullfile(savePath,febioLogFileName_strainEnergy),0,1);
    
    %Access data
    E_energy=dataStruct.data;
          
    %% 
    % Plotting the simulated results using |anim8| to visualize and animate
    % deformations 
    
    c1_plot=c1*ones(size(timeVec));
    cg_plot=c1_g(1)*ones(size(timeVec));
    cg_plot(timeVec>=1)=c1_g(2);
    
    [CV]=faceToVertexMeasure(E,V,E_energy(:,:,end));
    
    % Create basic view and store graphics handle to initiate animation
    hf=cFigure; %Open figure  
    gtitle([febioFebFileNamePart,': Press play to animate']);
    
    subplot(1,2,1); hold on;
    title('Ogden parameter c_1');
    xlabel('Time'); ylabel('c_1');
    plot(timeVec,c1_plot,'b-','lineWidth',2);
    plot(timeVec,cg_plot,'r-','lineWidth',2);
    hp1=plot(timeVec(1),c1_plot(1),'b.','MarkerSize',50);
    hp2=plot(timeVec(1),cg_plot(1),'r.','MarkerSize',50);
    legend([hp1 hp2],'Material 1','Material 2');
    axis tight; axis square; set(gca,'fontsize',fontSize);
    grid on;
    
    subplot(1,2,2); hold on;
    hp3=gpatch(Fb,V_DEF(:,:,end),CV,'k',1); %Add graphics object to animate
    hp3.FaceColor='interp';
    colormap(gjet(250)); hc=colorbar;
    caxis([0 max(E_energy(:))]/10);
    axisGeom(gca,fontSize);
    axis(axisLim(V_DEF)); %Set axis limits statically    
    axis manual; 
    camlight headlight;   
    drawnow;     
        
    % Set up animation features
    animStruct.Time=timeVec; %The time vector    
    for qt=1:1:size(N_disp_mat,3) %Loop over time increments        
        DN=N_disp_mat(:,:,qt); %Current displacement
        DN_magnitude=sqrt(sum(DN.^2,2)); %Current displacement magnitude

        [CV]=faceToVertexMeasure(E,V,E_energy(:,:,qt));        
        
        %Set entries in animation structure
        animStruct.Handles{qt}=[hp3 hp3 hp1 hp1 hp2 hp2]; %Handles of objects to animate
        animStruct.Props{qt}={'Vertices','CData','XData','YData','XData','YData'}; %Properties of objects to animate
        animStruct.Set{qt}={V_DEF(:,:,qt),CV,timeVec(qt),c1_plot(qt),timeVec(qt),cg_plot(qt)}; %Property values for to set in order to animate        
    end        
    anim8(hf,animStruct); %Initiate animation feature    
    drawnow;
       
end

%% 
%
% <<gibbVerySmall.gif>>
% 
% _*GIBBON*_ 
% <www.gibboncode.org>
% 
% _Kevin Mattheus Moerman_, <gibbon.toolbox@gmail.com>
 
%% 
% _*GIBBON footer text*_ 
% 
% License: <https://github.com/gibbonCode/GIBBON/blob/master/LICENSE>
% 
% GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for
% image segmentation, image-based modeling, meshing, and finite element
% analysis.
% 
% Copyright (C) 2006-2022 Kevin Mattheus Moerman and the GIBBON contributors
% 
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

##### SOURCE END #####
--></body></html>
