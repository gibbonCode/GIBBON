
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>DEMO_febio_0020_vessel_balloon_inflate</title><meta name="generator" content="MATLAB 9.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-04-20"><meta name="DC.source" content="DEMO_abaqus_0003_cylinder_inflate.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>DEMO_febio_0020_vessel_balloon_inflate</h1><!--introduction--><p>Below is a demonstration for:</p><div><ul><li>Building geometry for a cylindrical vessel with tetrahedral elements</li><li>Defining the boundary conditions</li><li>Coding the febio structure</li><li>Running the model</li><li>Importing and visualizing the displacement results</li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Keywords</a></li><li><a href="#3">Plot settings</a></li><li><a href="#4">Control parameters</a></li><li><a href="#5">Creating model boundary polygons</a></li><li><a href="#7">Creating model boundary surfaces</a></li><li><a href="#9">Defining the boundary conditions</a></li><li><a href="#14">Create node set for a ring at the centre</a></li><li><a href="#16">Setup structure to define an Abaqus inp file</a></li><li><a href="#17">Run the job using Abaqus</a></li><li><a href="#18">Creating the INP file</a></li><li><a href="#19">Run the job using Abaqus</a></li><li><a href="#21">Import and visualize abaqus results</a></li><li><a href="#23">Calculate segment area change as a function of time and pressure</a></li></ul></div><h2 id="1">Keywords</h2><div><ul><li>febio_spec version 2.5</li><li>febio, FEBio</li><li>vessel, cylinder, balloon</li><li>prescribed displacement</li><li>contact, sliding</li><li>hexahedral elements, hex8</li><li>tube, cylindrical</li><li>static, solid, multistep</li><li>hyperelastic, Ogden</li><li>displacement logfile</li><li>stress logfile</li></ul></div><pre class="codeinput">clear; close <span class="string">all</span>; clc;
</pre><h2 id="3">Plot settings</h2><pre class="codeinput">fontSize=20;
faceAlpha1=0.8;
markerSize=40;
lineWidth=3;
</pre><h2 id="4">Control parameters</h2><pre class="codeinput"><span class="comment">% Path names</span>
defaultFolder = fileparts(fileparts(mfilename(<span class="string">'fullpath'</span>)));
savePath=fullfile(defaultFolder,<span class="string">'data'</span>,<span class="string">'temp'</span>);

<span class="comment">% Defining file names</span>
abaqusInpFileNamePart=<span class="string">'tempModel'</span>;
abaqusInpFileName=fullfile(savePath,[abaqusInpFileNamePart,<span class="string">'.inp'</span>]); <span class="comment">%INP file name</span>
abaqusDATFileName=fullfile(savePath,[abaqusInpFileNamePart,<span class="string">'.dat'</span>]); <span class="comment">%DAT file name</span>

<span class="comment">%Specifying geometry parameters vessel (mm)***</span>
pointSpacing=2;
radiusOuter1=14;
radiusInner1=12;
radiusOuter2=14;
radiusInner2=12;
vesselLength=100;

<span class="comment">%Loads</span>
pressureValue=5e-3;

<span class="comment">%Material</span>
materialName=<span class="string">'Ogden'</span>;
kFactor=25;
muOgden_1=0.06/2;
alphaOgden_1=36;
k=muOgden_1*kFactor;
D1=2/k;
a=2;

<span class="comment">%Time stepping settings</span>
numTimeSteps=20;
totalTime=1;
timeStepInitial=totalTime/numTimeSteps;
timeStepMinimum=timeStepInitial/100;
timeStepMaximum=timeStepInitial;
</pre><h2 id="5">Creating model boundary polygons</h2><pre class="codeinput">nRad=round((2*pi*max([radiusOuter1 radiusOuter2]))/pointSpacing); <span class="comment">%Number of radial steps</span>

t=linspace(0,2*pi,nRad)'; <span class="comment">%Angles</span>
t=t(1:end-1); <span class="comment">%take away last which equals start</span>
v1_Outer=[-(vesselLength/2)*ones(size(t)) radiusOuter1*sin(t) radiusOuter1*cos(t)]; <span class="comment">%Circular coordinates</span>

t=linspace(0,2*pi,nRad)'; <span class="comment">%Angles</span>
t=t(1:end-1); <span class="comment">%take away last which equals start</span>
v2_Outer=[(vesselLength/2)*ones(size(t)) radiusOuter2*sin(t) radiusOuter2*cos(t)]; <span class="comment">%Circular coordinates</span>

t=linspace(0,2*pi,nRad)'; <span class="comment">%Angles</span>
t=t(1:end-1); <span class="comment">%take away last which equals start</span>
v1_Inner=[-(vesselLength/2)*ones(size(t)) radiusInner1*sin(t) radiusInner1*cos(t)]; <span class="comment">%Circular coordinates</span>

t=linspace(0,2*pi,nRad)'; <span class="comment">%Angles</span>
t=t(1:end-1); <span class="comment">%take away last which equals start</span>
v2_Inner=[(vesselLength/2)*ones(size(t)) radiusInner2*sin(t) radiusInner2*cos(t)]; <span class="comment">%Circular coordinates</span>
</pre><p>Plotting model boundary polygons</p><pre class="codeinput">cFigure;
hold <span class="string">on</span>;
title(<span class="string">'Model boundary polygons'</span>,<span class="string">'FontSize'</span>,fontSize);
plotV(v1_Outer,<span class="string">'r.-'</span>)
plotV(v1_Inner,<span class="string">'g.-'</span>)
plotV(v2_Outer,<span class="string">'b.-'</span>)
plotV(v2_Inner,<span class="string">'y.-'</span>)
axisGeom(gca,fontSize);
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_abaqus_0003_cylinder_inflate_01.jpg" alt=""> <h2 id="7">Creating model boundary surfaces</h2><pre class="codeinput">numSteps=round(vesselLength/pointSpacing);
numSteps=numSteps + iseven(numSteps);

controlStructLoft.numSteps=ceil(vesselLength./pointSpacing);
controlStructLoft.closeLoopOpt=1;
controlStructLoft.patchType=<span class="string">'quad'</span>;
controlStructLoft.numSteps=numSteps;

<span class="comment">%Meshing outer surface</span>
[F1,V1,indStart1,indEnd1]=polyLoftLinear(v1_Outer,v2_Outer,controlStructLoft);

<span class="comment">%Meshing inner surface</span>
[F2,V2,indStart2,indEnd2]=polyLoftLinear(v1_Inner,v2_Inner,controlStructLoft);

<span class="comment">%Compose hexahedral elements</span>
indStart2=indStart2+size(V1,1);
indEnd2=indEnd2+size(V1,1);
F2=F2+size(V1,1);
ET=[F1 F2]; <span class="comment">%hexahedral elements</span>
VT=[V1;V2]; <span class="comment">%Nodes</span>

[FT]=element2patch(ET,[],<span class="string">'hex8'</span>);
indBoundary=tesBoundary(FT);
Fb=FT(indBoundary,:);
</pre><p>Plotting model boundary surfaces</p><pre class="codeinput">cFigure;
hold <span class="string">on</span>;
title(<span class="string">'Model boundary surfaces'</span>,<span class="string">'FontSize'</span>,fontSize);

gpatch(Fb,VT,<span class="string">'rw'</span>,<span class="string">'none'</span>,0.25);
patchNormPlot(FT,VT);

gpatch(F1,VT,<span class="string">'bw'</span>);
patchNormPlot(F1,VT);

gpatch(F2,VT,<span class="string">'gw'</span>);
patchNormPlot(F2,VT);

colormap(gca,gjet(4));
<span class="comment">% icolorbar;</span>

axisGeom(gca,fontSize);
camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_abaqus_0003_cylinder_inflate_02.jpg" alt=""> <img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_abaqus_0003_cylinder_inflate_03.jpg" alt=""> <h2 id="9">Defining the boundary conditions</h2><p>The visualization of the model boundary shows colors for each side of the cube. These labels can be used to define boundary conditions.</p><pre class="codeinput"><span class="comment">%Define X supported node set</span>
bcSupportList_1=unique([indStart1(:);indStart2(:)]); <span class="comment">%Node set part of selected face</span>
bcSupportList_2=unique([indEnd1(:);indEnd2(:)]); <span class="comment">%Node set part of selected face</span>
indNodesFix=[bcSupportList_1(:); bcSupportList_2(:)];

<span class="comment">% %Define Y supported node set</span>
<span class="comment">% bcSupportList_Y=unique(Fb(Cb==4,:)); %Node set part of selected face</span>
</pre><p>Visualizing boundary conditions. Markers plotted on the semi-transparent model denote the nodes in the various boundary condition lists.</p><pre class="codeinput">cFigure;
title(<span class="string">'Boundary conditions'</span>,<span class="string">'FontSize'</span>,fontSize);
hold <span class="string">on</span>;

gpatch(Fb,VT,<span class="string">'kw'</span>,<span class="string">'none'</span>,0.5);

hl(1)=plotV(VT(bcSupportList_1,:),<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
hl(2)=plotV(VT(bcSupportList_2,:),<span class="string">'g.'</span>,<span class="string">'MarkerSize'</span>,markerSize);

legend(hl,{<span class="string">'BC support list 1'</span>,<span class="string">'BC support list 2'</span>});

axisGeom(gca,fontSize);
camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_abaqus_0003_cylinder_inflate_04.jpg" alt=""> <img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_abaqus_0003_cylinder_inflate_05.jpg" alt=""> <p>Visualizing boundary conditions. Markers plotted on the semi-transparent model denote the nodes in the various boundary condition lists.</p><pre class="codeinput">cFigure;
title(<span class="string">'Pressure surface'</span>,<span class="string">'FontSize'</span>,fontSize);
hold <span class="string">on</span>;

gpatch(Fb,VT,<span class="string">'kw'</span>,<span class="string">'none'</span>,0.5);

clear <span class="string">hl</span>;
hl(1)=gpatch(F2,VT,<span class="string">'rw'</span>,<span class="string">'k'</span>,1);
legend(hl,{<span class="string">'Pressure surface'</span>});

axisGeom(gca,fontSize);
camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_abaqus_0003_cylinder_inflate_06.jpg" alt=""> <img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_abaqus_0003_cylinder_inflate_07.jpg" alt=""> <pre class="codeinput">indicesNodesInner=unique(F2(:));
indicesElementsInner=1:1:size(ET,1); <span class="comment">%find(any(ismember(ET,indicesNodesInner),2));</span>

FT_inner=ET(:,5:8);
</pre><p>Visualizing inner surface</p><pre class="codeinput">cFigure;
title(<span class="string">'Pressure surface'</span>,<span class="string">'FontSize'</span>,fontSize);
hold <span class="string">on</span>;

gpatch(Fb,VT,<span class="string">'kw'</span>,<span class="string">'none'</span>,0.5);

clear <span class="string">hl</span>;
hl(1)=gpatch(FT_inner,VT,<span class="string">'rw'</span>,<span class="string">'k'</span>,1);

legend(hl,{<span class="string">'Pressure surface'</span>});

axisGeom(gca,fontSize);
camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_abaqus_0003_cylinder_inflate_08.jpg" alt=""> <img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_abaqus_0003_cylinder_inflate_09.jpg" alt=""> <h2 id="14">Create node set for a ring at the centre</h2><pre class="codeinput">logicLeft=VT(:,1)&lt;=(0+eps(0));
logicLeftFaces=all(logicLeft(F2),2);

F2_left=F2(logicLeftFaces,:);

Eb_left=patchBoundary(F2_left);
X=VT(:,1);
X_Eb_left=X(Eb_left);
logicKeep=all(X_Eb_left&gt;=(0-eps(0)),2);
E_segment=Eb_left(logicKeep,:);
indSegment=edgeListToCurve(E_segment); <span class="comment">%Convert to curve</span>
indSegment=indSegment(1:end-1); <span class="comment">%Remove double end point</span>

segmentCurve_cell={indSegment};
</pre><pre class="codeinput">cFigure;
title(<span class="string">'Middle segment for analysis'</span>,<span class="string">'FontSize'</span>,fontSize);
hold <span class="string">on</span>;

gpatch(Fb,VT,<span class="string">'kw'</span>,<span class="string">'none'</span>,0.5);

<span class="comment">% gpatch(F2_left,VT,'rw','k',1);</span>

clear <span class="string">hl</span>;
hl(1)=plotV(VT(indSegment,:),<span class="string">'b.-'</span>,<span class="string">'LineWidth'</span>,3,<span class="string">'MarkerSize'</span>,25);

legend(hl,{<span class="string">'Segment of interest'</span>});

axisGeom(gca,fontSize);
camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_abaqus_0003_cylinder_inflate_10.jpg" alt=""> <img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_abaqus_0003_cylinder_inflate_11.jpg" alt=""> <h2 id="16">Setup structure to define an Abaqus inp file</h2><pre class="codeinput"><span class="comment">%%--&gt; Heading</span>
abaqus_spec.Heading.COMMENT{1}=<span class="string">'Job name: AORTA'</span>;
abaqus_spec.Heading.COMMENT{2}=<span class="string">'Generated by: GIBBON'</span>;

<span class="comment">%%--&gt; Preprint</span>
abaqus_spec.Preprint.ATTR.echo=<span class="string">'NO'</span>;
abaqus_spec.Preprint.ATTR.model=<span class="string">'NO'</span>;
abaqus_spec.Preprint.ATTR.history=<span class="string">'NO'</span>;
abaqus_spec.Preprint.ATTR.contact=<span class="string">'NO'</span>;

<span class="comment">%--&gt; Part</span>
partName=<span class="string">'Aorta'</span>;

<span class="comment">% Node</span>
nodeIds=(1:1:size(VT,1))';
abaqus_spec.Part.COMMENT=<span class="string">'This section defines the part geometry in terms of nodes and elements'</span>;
abaqus_spec.Part.ATTR.name=partName;
abaqus_spec.Part.Node={nodeIds,VT};

<span class="comment">% Element</span>
elementIds=(1:1:size(ET,1))';
abaqus_spec.Part.Element{1}.ATTR.type=<span class="string">'C3D8'</span>;<span class="comment">%'C3D8R';</span>
abaqus_spec.Part.Element{1}.VAL={elementIds,ET};

<span class="comment">% Element sets</span>
abaqus_spec.Part.Elset{1}.ATTR.elset=<span class="string">'Set-1'</span>;
abaqus_spec.Part.Elset{1}.VAL=elementIds(:)';

surfaceElementSetName=<span class="string">'elementSetInnerSurface'</span>;
abaqus_spec.Part.Elset{2}.ATTR.elset=surfaceElementSetName;
abaqus_spec.Part.Elset{2}.ATTR.internal=<span class="string">''</span>; <span class="comment">%Remains hidden uppon import</span>
abaqus_spec.Part.Elset{2}.VAL=indicesElementsInner(:)';

<span class="comment">% Surfaces</span>
sidePick=2;
innerSurfaceName=[surfaceElementSetName,<span class="string">'_side'</span>,num2str(sidePick)];
abaqus_spec.Part.Surface{1}.ATTR.type=<span class="string">'ELEMENT'</span>;
abaqus_spec.Part.Surface{1}.ATTR.name=innerSurfaceName;
abaqus_spec.Part.Surface{1}.VAL={surfaceElementSetName,[<span class="string">'S'</span>,num2str(sidePick)]};

<span class="comment">% Sections</span>
abaqus_spec.Part.Solid_section.ATTR.elset=<span class="string">'Set-1'</span>;
abaqus_spec.Part.Solid_section.ATTR.material=materialName;

<span class="comment">%--&gt; Assembly</span>
instanceName=<span class="string">'Aorta-assembly'</span>;
abaqus_spec.Assembly.ATTR.name=<span class="string">'Assembly-1'</span>;
abaqus_spec.Assembly.Instance.ATTR.name=instanceName;
abaqus_spec.Assembly.Instance.ATTR.part=<span class="string">'Aorta'</span>;

abaqus_spec.Assembly.Nset{1}.ATTR.nset=<span class="string">'Set-1'</span>;
abaqus_spec.Assembly.Nset{1}.ATTR.instance=instanceName;
abaqus_spec.Assembly.Nset{1}.VAL=indicesNodesInner(:)';

<span class="comment">%Add segment curve node sets</span>
<span class="keyword">for</span> q=1:1:numel(segmentCurve_cell)
    indNow=numel(abaqus_spec.Assembly.Nset)+1;
    abaqus_spec.Assembly.Nset{indNow}.ATTR.nset=[<span class="string">'Set-'</span>,num2str(indNow)];
    abaqus_spec.Assembly.Nset{indNow}.ATTR.instance=instanceName;
    abaqus_spec.Assembly.Nset{indNow}.VAL=segmentCurve_cell{q};
<span class="keyword">end</span>

<span class="comment">%Add fix node set</span>
indNow=numel(abaqus_spec.Assembly.Nset)+1;
setNameFix=[<span class="string">'Set-'</span>,num2str(indNow)];
abaqus_spec.Assembly.Nset{indNow}.ATTR.nset=setNameFix;
abaqus_spec.Assembly.Nset{indNow}.ATTR.instance=instanceName;
abaqus_spec.Assembly.Nset{indNow}.VAL=indNodesFix(:)';

<span class="comment">%Add output node set</span>
outputNodeSetName=<span class="string">'all'</span>;
abaqus_spec.Assembly.Nset{5}.ATTR.nset=outputNodeSetName;
abaqus_spec.Assembly.Nset{5}.ATTR.instance=instanceName;
abaqus_spec.Assembly.Nset{5}.VAL=1:1:size(VT,1);

<span class="comment">% Create assembly level element set for surface</span>
surfaceElementSetName=<span class="string">'elementSetInnerSurface'</span>;
abaqus_spec.Assembly.Elset{1}.ATTR.elset=surfaceElementSetName;
abaqus_spec.Assembly.Elset{1}.ATTR.internal=<span class="string">''</span>; <span class="comment">%Remains hidden uppon import</span>
abaqus_spec.Assembly.Elset{1}.ATTR.instance=instanceName;
abaqus_spec.Assembly.Elset{1}.VAL=indicesElementsInner(:)';

<span class="comment">% Create assembly level surface from element set</span>
sidePick=2;
innerSurfaceName=[surfaceElementSetName,<span class="string">'_side'</span>,num2str(sidePick)];
abaqus_spec.Assembly.Surface{1}.ATTR.type=<span class="string">'ELEMENT'</span>;
abaqus_spec.Assembly.Surface{1}.ATTR.name=innerSurfaceName;
abaqus_spec.Assembly.Surface{1}.VAL={surfaceElementSetName,[<span class="string">'S'</span>,num2str(sidePick)]};

<span class="comment">%%--&gt; Material</span>
abaqus_spec.Material.ATTR.name=materialName;
<span class="comment">% abaqus_spec.Material.Hyperelastic.VAL=[muOgden_1 alphaOgden_1 D1]; %Single term Ogden</span>
abaqus_spec.Material.Hyperelastic.VAL=[muOgden_1 alphaOgden_1 muOgden_1 -alphaOgden_1 D1 D1]; <span class="comment">%Two term Ogden</span>
abaqus_spec.Material.Hyperelastic.ATTR.n=2;
abaqus_spec.Material.Hyperelastic.ATTR.ogden=<span class="string">''</span>;
<span class="comment">%%--&gt; Step</span>
abaqus_spec.Step.ATTR.name=<span class="string">'Step-1'</span>;
abaqus_spec.Step.ATTR.nlgeom=<span class="string">'YES'</span>;

abaqus_spec.Step.Static=[timeStepInitial totalTime timeStepMinimum timeStepMaximum];

<span class="comment">% Boundary</span>
setNameFix=abaqus_spec.Assembly.Nset{indNow}.ATTR.nset;
abaqus_spec.Step.Boundary{1}.VAL={setNameFix,[1,1]};
abaqus_spec.Step.Boundary{2}.VAL={setNameFix,[2,2]};
abaqus_spec.Step.Boundary{3}.VAL={setNameFix,[3,3]};

<span class="comment">% Loads</span>
<span class="comment">% ** LOADS</span>
<span class="comment">% **</span>
<span class="comment">% ** Name: Load-1   Type: Pressure</span>
<span class="comment">% *Dsload</span>
<span class="comment">% Surf-1, P, 0.00533</span>
<span class="comment">% **</span>
abaqus_spec.Step.Dsload{1}.VAL={innerSurfaceName,<span class="string">'P'</span>,pressureValue};

<span class="comment">%Output</span>
abaqus_spec.Step.Restart.ATTR.write=<span class="string">''</span>;
abaqus_spec.Step.Restart.ATTR.frequency=0;

abaqus_spec.Step.Output{1}.ATTR.field=<span class="string">''</span>;
abaqus_spec.Step.Output{1}.ATTR.variable=<span class="string">'PRESELECT'</span>;
abaqus_spec.Step.Output{2}.ATTR.history=<span class="string">''</span>;
abaqus_spec.Step.Output{2}.ATTR.variable=<span class="string">'PRESELECT'</span>;
abaqus_spec.Step.Node_print.ATTR.nset=outputNodeSetName;
abaqus_spec.Step.Node_print.ATTR.frequency = 1;
abaqus_spec.Step.Node_print.VAL=<span class="string">'COORD'</span>;
abaqus_spec.Step.El_print.VAL=<span class="string">'S'</span>;
</pre><h2 id="17">Run the job using Abaqus</h2><pre class="codeinput">lockFileName=fullfile(savePath,[abaqusInpFileNamePart,<span class="string">'.lck'</span>]);
<span class="keyword">if</span> exist(lockFileName,<span class="string">'file'</span>)
    warning(<span class="string">'Lockfile found and deleted'</span>)
    delete(lockFileName);
<span class="keyword">end</span>
</pre><h2 id="18">Creating the INP file</h2><p>You can use <tt>abaqusStruct2inp</tt> to write the structure data to a file.</p><pre class="codeinput">abaqusStruct2inp(abaqus_spec,abaqusInpFileName);
</pre><h2 id="19">Run the job using Abaqus</h2><pre class="codeinput">lockFileName=fullfile(savePath,[abaqusInpFileNamePart,<span class="string">'.lck'</span>]);
<span class="keyword">if</span> exist(lockFileName,<span class="string">'file'</span>)
    warning(<span class="string">'Lockfile found and deleted'</span>)
    delete(lockFileName);
<span class="keyword">end</span>
</pre><pre class="codeinput">oldPath=pwd; <span class="comment">%Get current working directory</span>
cd(savePath); <span class="comment">%Set new working directory to match save patch</span>

abaqusPath=<span class="string">'abaqus'</span>;<span class="comment">%'/usr/bin/abaqus'; %Abaqus excute command or path</span>
runFlag=system([abaqusPath,<span class="string">' inp='</span>,abaqusInpFileName,<span class="string">' job='</span>,abaqusInpFileNamePart,<span class="string">' interactive ask_delete=OFF'</span>]);

cd(oldPath); <span class="comment">%Restore working directory</span>
</pre><pre class="codeoutput">/bin/bash: line 1: abaqus: command not found
</pre><h2 id="21">Import and visualize abaqus results</h2><p>Importing the abaqus .dat file</p><pre class="codeinput">[abaqusData]=importAbaqusDat(abaqusDATFileName);
</pre><pre class="codeoutput error">Error using textscan
Invalid file identifier. Use fopen to generate a valid file identifier.

Error in txtfile2cell (line 16)
T=textscan(fid,'%s','delimiter', '\n','Whitespace','');

Error in importAbaqusDat (line 61)
T=txtfile2cell(fileName);

Error in DEMO_abaqus_0003_cylinder_inflate (line 430)
[abaqusData]=importAbaqusDat(abaqusDATFileName);
</pre><p>Plotting the simulated results using <tt>anim8</tt> to visualize and animate deformations</p><pre class="codeinput"><span class="comment">%Getting final nodal coordinates</span>
V_def=[abaqusData.STEP(1).INCREMENT(end).nodeOutput.data.COOR1<span class="keyword">...</span>
    abaqusData.STEP(1).INCREMENT(end).nodeOutput.data.COOR2<span class="keyword">...</span>
    abaqusData.STEP(1).INCREMENT(end).nodeOutput.data.COOR3];
U=V_def-VT; <span class="comment">%Displacements</span>

colorDataVertices=sqrt(sum(U.^2,2)); <span class="comment">%Displacement magnitude data for all vertices</span>
colorDataFaces=vertexToFaceMeasure(Fb,colorDataVertices); <span class="comment">%Same for selection of faces</span>

timeVec=[0 abaqusData.STEP(1).INCREMENT(:).TOTAL_TIME_COMPLETED];

<span class="comment">% Get limits for plotting</span>
minV=min([VT;V_def],[],1); <span class="comment">%Minima</span>
maxV=max([VT;V_def],[],1); <span class="comment">%Maxima</span>

indSegmentPlot=[indSegment(:);indSegment(1)];

<span class="comment">% Create basic view and store graphics handle to initiate animation</span>
hf=cFigure; <span class="comment">%Open figure</span>
hold <span class="string">on</span>;
gtitle([abaqusInpFileNamePart,<span class="string">': Press play to animate'</span>]);
hp=gpatch(Fb,V_def,colorDataFaces,<span class="string">'none'</span>,0.5); <span class="comment">%Add graphics object to animate</span>
hp2=plotV(V_def(indSegmentPlot,:),<span class="string">'k-'</span>,<span class="string">'LineWidth'</span>,3,<span class="string">'MarkerSize'</span>,25);
<span class="comment">% gpatch(Fb,VT,0.5*ones(1,3),'none',0.25); %A static graphics object</span>
axisGeom(gca,fontSize);
colormap(gjet(250)); colorbar;
<span class="comment">% caxis([0 max(colorDataVertices)]);</span>
axis([minV(1) maxV(1) minV(2) maxV(2) minV(3) maxV(3)]); <span class="comment">%Set axis limits statically</span>
view(130,25); <span class="comment">%Set view direction</span>
camlight <span class="string">headlight</span>;

<span class="comment">% Set up animation features</span>
animStruct.Time=timeVec; <span class="comment">%The time vector</span>
<span class="keyword">for</span> qt=1:1:numel(timeVec) <span class="comment">%Loop over time increments</span>
    <span class="keyword">if</span> qt&gt;1
        V_def=[abaqusData.STEP(1).INCREMENT(qt-1).nodeOutput.data.COOR1<span class="keyword">...</span>
               abaqusData.STEP(1).INCREMENT(qt-1).nodeOutput.data.COOR2<span class="keyword">...</span>
               abaqusData.STEP(1).INCREMENT(qt-1).nodeOutput.data.COOR3];
    <span class="keyword">else</span>
        V_def=VT;
    <span class="keyword">end</span>
    U=V_def-VT; <span class="comment">%Displacements</span>
    colorDataVertices=sqrt(sum(U.^2,2)); <span class="comment">%Displacement magnitude data for all vertices</span>
    colorDataFaces=vertexToFaceMeasure(Fb,colorDataVertices); <span class="comment">%Same for selection of faces</span>

    <span class="comment">%Set entries in animation structure</span>
    animStruct.Handles{qt}=[hp hp hp2 hp2 hp2]; <span class="comment">%Handles of objects to animate</span>
    animStruct.Props{qt}={<span class="string">'Vertices'</span>,<span class="string">'CData'</span>,<span class="string">'XData'</span>,<span class="string">'YData'</span>,<span class="string">'ZData'</span>}; <span class="comment">%Properties of objects to animate</span>
    animStruct.Set{qt}={V_def,colorDataFaces,V_def(indSegmentPlot,1),V_def(indSegmentPlot,2),V_def(indSegmentPlot,3)}; <span class="comment">%Property values for to set in order to animate</span>
<span class="keyword">end</span>
anim8(hf,animStruct); <span class="comment">%Initiate animation feature</span>
drawnow;
</pre><h2 id="23">Calculate segment area change as a function of time and pressure</h2><pre class="codeinput">nIncrements=numel(abaqusData.STEP(1).INCREMENT);
p=linspace(0,pressureValue,nIncrements+1);

A=NaN(size(p));
<span class="keyword">for</span> qt=1:1:numel(timeVec) <span class="comment">%Loop over time increments</span>
    <span class="keyword">if</span> qt&gt;1
        V_def=[abaqusData.STEP(1).INCREMENT(qt-1).nodeOutput.data.COOR1<span class="keyword">...</span>
               abaqusData.STEP(1).INCREMENT(qt-1).nodeOutput.data.COOR2<span class="keyword">...</span>
               abaqusData.STEP(1).INCREMENT(qt-1).nodeOutput.data.COOR3];
    <span class="keyword">else</span>
        V_def=VT;
    <span class="keyword">end</span>
    A(qt)=patch_area(1:1:numel(indSegmentPlot),V_def(indSegmentPlot,:));
<span class="keyword">end</span>
</pre><pre class="codeinput">cFigure;
subplot(1,2,1);
hl(1)=plot(timeVec,p,<span class="string">'b.-'</span>,<span class="string">'LineWidth'</span>,3,<span class="string">'MarkerSize'</span>,25);
hLegend=legend(hl,{<span class="string">'time vs pressure'</span>},<span class="string">'FontSize'</span>,fontSize);
hLegend.Location=<span class="string">'NorthWest'</span>;
set(gca,<span class="string">'FontSize'</span>,fontSize);
grid <span class="string">on</span>;

subplot(1,2,2);
hl(1)=plot(p,A,<span class="string">'r.-'</span>,<span class="string">'LineWidth'</span>,3,<span class="string">'MarkerSize'</span>,25);
hLegend=legend(hl,{<span class="string">'pressure vs area'</span>},<span class="string">'FontSize'</span>,fontSize);
hLegend.Location=<span class="string">'NorthWest'</span>;
set(gca,<span class="string">'FontSize'</span>,fontSize);
grid <span class="string">on</span>;

drawnow;
</pre><p><img vspace="5" hspace="5" src="gibbVerySmall.gif" alt=""> </p><p><i><b>GIBBON</b></i> <a href="www.gibboncode.org">www.gibboncode.org</a></p><p><i>Kevin Mattheus Moerman</i>, <a href="gibbon.toolbox@gmail.com">gibbon.toolbox@gmail.com</a></p><p><i><b>GIBBON footer text</b></i></p><p>License: <a href="https://github.com/gibbonCode/GIBBON/blob/master/LICENSE">https://github.com/gibbonCode/GIBBON/blob/master/LICENSE</a></p><p>GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for image segmentation, image-based modeling, meshing, and finite element analysis.</p><p>Copyright (C) 2006-2022 Kevin Mattheus Moerman and the GIBBON contributors</p><p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p><p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p><p>You should have received a copy of the GNU General Public License along with this program.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2022b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% DEMO_febio_0020_vessel_balloon_inflate
% Below is a demonstration for:
%
% * Building geometry for a cylindrical vessel with tetrahedral elements
% * Defining the boundary conditions
% * Coding the febio structure
% * Running the model
% * Importing and visualizing the displacement results

%% Keywords
%
% * febio_spec version 2.5
% * febio, FEBio
% * vessel, cylinder, balloon
% * prescribed displacement
% * contact, sliding
% * hexahedral elements, hex8
% * tube, cylindrical
% * static, solid, multistep
% * hyperelastic, Ogden
% * displacement logfile
% * stress logfile

%%

clear; close all; clc;

%% Plot settings
fontSize=20;
faceAlpha1=0.8;
markerSize=40;
lineWidth=3;

%% Control parameters

% Path names
defaultFolder = fileparts(fileparts(mfilename('fullpath')));
savePath=fullfile(defaultFolder,'data','temp');

% Defining file names
abaqusInpFileNamePart='tempModel';
abaqusInpFileName=fullfile(savePath,[abaqusInpFileNamePart,'.inp']); %INP file name
abaqusDATFileName=fullfile(savePath,[abaqusInpFileNamePart,'.dat']); %DAT file name

%Specifying geometry parameters vessel (mm)***
pointSpacing=2;
radiusOuter1=14;
radiusInner1=12;
radiusOuter2=14;
radiusInner2=12;
vesselLength=100;

%Loads
pressureValue=5e-3;

%Material 
materialName='Ogden';
kFactor=25;
muOgden_1=0.06/2;
alphaOgden_1=36; 
k=muOgden_1*kFactor;
D1=2/k; 
a=2; 

%Time stepping settings
numTimeSteps=20;
totalTime=1;
timeStepInitial=totalTime/numTimeSteps; 
timeStepMinimum=timeStepInitial/100;
timeStepMaximum=timeStepInitial;

%% Creating model boundary polygons
%

nRad=round((2*pi*max([radiusOuter1 radiusOuter2]))/pointSpacing); %Number of radial steps

t=linspace(0,2*pi,nRad)'; %Angles
t=t(1:end-1); %take away last which equals start
v1_Outer=[-(vesselLength/2)*ones(size(t)) radiusOuter1*sin(t) radiusOuter1*cos(t)]; %Circular coordinates

t=linspace(0,2*pi,nRad)'; %Angles
t=t(1:end-1); %take away last which equals start
v2_Outer=[(vesselLength/2)*ones(size(t)) radiusOuter2*sin(t) radiusOuter2*cos(t)]; %Circular coordinates

t=linspace(0,2*pi,nRad)'; %Angles
t=t(1:end-1); %take away last which equals start
v1_Inner=[-(vesselLength/2)*ones(size(t)) radiusInner1*sin(t) radiusInner1*cos(t)]; %Circular coordinates

t=linspace(0,2*pi,nRad)'; %Angles
t=t(1:end-1); %take away last which equals start
v2_Inner=[(vesselLength/2)*ones(size(t)) radiusInner2*sin(t) radiusInner2*cos(t)]; %Circular coordinates

%%
% Plotting model boundary polygons

cFigure;
hold on;
title('Model boundary polygons','FontSize',fontSize);
plotV(v1_Outer,'r.-')
plotV(v1_Inner,'g.-')
plotV(v2_Outer,'b.-')
plotV(v2_Inner,'y.-')
axisGeom(gca,fontSize);
drawnow;

%% Creating model boundary surfaces

numSteps=round(vesselLength/pointSpacing);
numSteps=numSteps + iseven(numSteps);

controlStructLoft.numSteps=ceil(vesselLength./pointSpacing);
controlStructLoft.closeLoopOpt=1;
controlStructLoft.patchType='quad';
controlStructLoft.numSteps=numSteps;

%Meshing outer surface
[F1,V1,indStart1,indEnd1]=polyLoftLinear(v1_Outer,v2_Outer,controlStructLoft);

%Meshing inner surface
[F2,V2,indStart2,indEnd2]=polyLoftLinear(v1_Inner,v2_Inner,controlStructLoft);

%Compose hexahedral elements
indStart2=indStart2+size(V1,1);
indEnd2=indEnd2+size(V1,1);
F2=F2+size(V1,1);
ET=[F1 F2]; %hexahedral elements
VT=[V1;V2]; %Nodes

[FT]=element2patch(ET,[],'hex8');
indBoundary=tesBoundary(FT);
Fb=FT(indBoundary,:);

%%
% Plotting model boundary surfaces

cFigure;
hold on;
title('Model boundary surfaces','FontSize',fontSize);

gpatch(Fb,VT,'rw','none',0.25);
patchNormPlot(FT,VT);

gpatch(F1,VT,'bw');
patchNormPlot(F1,VT);

gpatch(F2,VT,'gw');
patchNormPlot(F2,VT);

colormap(gca,gjet(4));
% icolorbar;

axisGeom(gca,fontSize);
camlight headlight;
drawnow;

%% Defining the boundary conditions
% The visualization of the model boundary shows colors for each side of the
% cube. These labels can be used to define boundary conditions.

%Define X supported node set
bcSupportList_1=unique([indStart1(:);indStart2(:)]); %Node set part of selected face
bcSupportList_2=unique([indEnd1(:);indEnd2(:)]); %Node set part of selected face
indNodesFix=[bcSupportList_1(:); bcSupportList_2(:)];

% %Define Y supported node set
% bcSupportList_Y=unique(Fb(Cb==4,:)); %Node set part of selected face

%%
% Visualizing boundary conditions. Markers plotted on the semi-transparent
% model denote the nodes in the various boundary condition lists.

cFigure;
title('Boundary conditions','FontSize',fontSize);
hold on;

gpatch(Fb,VT,'kw','none',0.5);

hl(1)=plotV(VT(bcSupportList_1,:),'r.','MarkerSize',markerSize);
hl(2)=plotV(VT(bcSupportList_2,:),'g.','MarkerSize',markerSize);

legend(hl,{'BC support list 1','BC support list 2'});

axisGeom(gca,fontSize);
camlight headlight;
drawnow;

%%
% Visualizing boundary conditions. Markers plotted on the semi-transparent
% model denote the nodes in the various boundary condition lists.

cFigure;
title('Pressure surface','FontSize',fontSize);
hold on;

gpatch(Fb,VT,'kw','none',0.5);

clear hl;
hl(1)=gpatch(F2,VT,'rw','k',1);
legend(hl,{'Pressure surface'});

axisGeom(gca,fontSize);
camlight headlight;
drawnow;

%%

indicesNodesInner=unique(F2(:));
indicesElementsInner=1:1:size(ET,1); %find(any(ismember(ET,indicesNodesInner),2));

FT_inner=ET(:,5:8); 

%%
% Visualizing inner surface
cFigure;
title('Pressure surface','FontSize',fontSize);
hold on;

gpatch(Fb,VT,'kw','none',0.5);

clear hl;
hl(1)=gpatch(FT_inner,VT,'rw','k',1);

legend(hl,{'Pressure surface'});

axisGeom(gca,fontSize);
camlight headlight;
drawnow;

%% Create node set for a ring at the centre

logicLeft=VT(:,1)<=(0+eps(0));
logicLeftFaces=all(logicLeft(F2),2);

F2_left=F2(logicLeftFaces,:);

Eb_left=patchBoundary(F2_left);
X=VT(:,1);
X_Eb_left=X(Eb_left);
logicKeep=all(X_Eb_left>=(0-eps(0)),2);
E_segment=Eb_left(logicKeep,:); 
indSegment=edgeListToCurve(E_segment); %Convert to curve
indSegment=indSegment(1:end-1); %Remove double end point

segmentCurve_cell={indSegment};

%%

cFigure;
title('Middle segment for analysis','FontSize',fontSize);
hold on;

gpatch(Fb,VT,'kw','none',0.5);

% gpatch(F2_left,VT,'rw','k',1);

clear hl;
hl(1)=plotV(VT(indSegment,:),'b.-','LineWidth',3,'MarkerSize',25);

legend(hl,{'Segment of interest'});

axisGeom(gca,fontSize);
camlight headlight;
drawnow;

%% Setup structure to define an Abaqus inp file

%%REPLACE_WITH_DASH_DASH> Heading
abaqus_spec.Heading.COMMENT{1}='Job name: AORTA';
abaqus_spec.Heading.COMMENT{2}='Generated by: GIBBON';

%%REPLACE_WITH_DASH_DASH> Preprint
abaqus_spec.Preprint.ATTR.echo='NO';
abaqus_spec.Preprint.ATTR.model='NO';
abaqus_spec.Preprint.ATTR.history='NO';
abaqus_spec.Preprint.ATTR.contact='NO';

%REPLACE_WITH_DASH_DASH> Part
partName='Aorta';

% Node
nodeIds=(1:1:size(VT,1))';
abaqus_spec.Part.COMMENT='This section defines the part geometry in terms of nodes and elements';
abaqus_spec.Part.ATTR.name=partName;
abaqus_spec.Part.Node={nodeIds,VT};

% Element
elementIds=(1:1:size(ET,1))';
abaqus_spec.Part.Element{1}.ATTR.type='C3D8';%'C3D8R';
abaqus_spec.Part.Element{1}.VAL={elementIds,ET};

% Element sets
abaqus_spec.Part.Elset{1}.ATTR.elset='Set-1';
abaqus_spec.Part.Elset{1}.VAL=elementIds(:)';

surfaceElementSetName='elementSetInnerSurface';
abaqus_spec.Part.Elset{2}.ATTR.elset=surfaceElementSetName;
abaqus_spec.Part.Elset{2}.ATTR.internal=''; %Remains hidden uppon import
abaqus_spec.Part.Elset{2}.VAL=indicesElementsInner(:)';

% Surfaces
sidePick=2;
innerSurfaceName=[surfaceElementSetName,'_side',num2str(sidePick)];
abaqus_spec.Part.Surface{1}.ATTR.type='ELEMENT';
abaqus_spec.Part.Surface{1}.ATTR.name=innerSurfaceName;
abaqus_spec.Part.Surface{1}.VAL={surfaceElementSetName,['S',num2str(sidePick)]};

% Sections
abaqus_spec.Part.Solid_section.ATTR.elset='Set-1';
abaqus_spec.Part.Solid_section.ATTR.material=materialName;

%REPLACE_WITH_DASH_DASH> Assembly
instanceName='Aorta-assembly';
abaqus_spec.Assembly.ATTR.name='Assembly-1';
abaqus_spec.Assembly.Instance.ATTR.name=instanceName;
abaqus_spec.Assembly.Instance.ATTR.part='Aorta';

abaqus_spec.Assembly.Nset{1}.ATTR.nset='Set-1';
abaqus_spec.Assembly.Nset{1}.ATTR.instance=instanceName;
abaqus_spec.Assembly.Nset{1}.VAL=indicesNodesInner(:)';

%Add segment curve node sets
for q=1:1:numel(segmentCurve_cell)
    indNow=numel(abaqus_spec.Assembly.Nset)+1;
    abaqus_spec.Assembly.Nset{indNow}.ATTR.nset=['Set-',num2str(indNow)];
    abaqus_spec.Assembly.Nset{indNow}.ATTR.instance=instanceName;
    abaqus_spec.Assembly.Nset{indNow}.VAL=segmentCurve_cell{q};
end

%Add fix node set
indNow=numel(abaqus_spec.Assembly.Nset)+1;
setNameFix=['Set-',num2str(indNow)];
abaqus_spec.Assembly.Nset{indNow}.ATTR.nset=setNameFix;
abaqus_spec.Assembly.Nset{indNow}.ATTR.instance=instanceName;
abaqus_spec.Assembly.Nset{indNow}.VAL=indNodesFix(:)';

%Add output node set
outputNodeSetName='all';
abaqus_spec.Assembly.Nset{5}.ATTR.nset=outputNodeSetName;
abaqus_spec.Assembly.Nset{5}.ATTR.instance=instanceName;
abaqus_spec.Assembly.Nset{5}.VAL=1:1:size(VT,1);

% Create assembly level element set for surface
surfaceElementSetName='elementSetInnerSurface';
abaqus_spec.Assembly.Elset{1}.ATTR.elset=surfaceElementSetName;
abaqus_spec.Assembly.Elset{1}.ATTR.internal=''; %Remains hidden uppon import
abaqus_spec.Assembly.Elset{1}.ATTR.instance=instanceName;
abaqus_spec.Assembly.Elset{1}.VAL=indicesElementsInner(:)';

% Create assembly level surface from element set
sidePick=2;
innerSurfaceName=[surfaceElementSetName,'_side',num2str(sidePick)];
abaqus_spec.Assembly.Surface{1}.ATTR.type='ELEMENT';
abaqus_spec.Assembly.Surface{1}.ATTR.name=innerSurfaceName;
abaqus_spec.Assembly.Surface{1}.VAL={surfaceElementSetName,['S',num2str(sidePick)]};

%%REPLACE_WITH_DASH_DASH> Material
abaqus_spec.Material.ATTR.name=materialName;
% abaqus_spec.Material.Hyperelastic.VAL=[muOgden_1 alphaOgden_1 D1]; %Single term Ogden
abaqus_spec.Material.Hyperelastic.VAL=[muOgden_1 alphaOgden_1 muOgden_1 -alphaOgden_1 D1 D1]; %Two term Ogden
abaqus_spec.Material.Hyperelastic.ATTR.n=2;
abaqus_spec.Material.Hyperelastic.ATTR.ogden='';
%%REPLACE_WITH_DASH_DASH> Step
abaqus_spec.Step.ATTR.name='Step-1';
abaqus_spec.Step.ATTR.nlgeom='YES';

abaqus_spec.Step.Static=[timeStepInitial totalTime timeStepMinimum timeStepMaximum];

% Boundary
setNameFix=abaqus_spec.Assembly.Nset{indNow}.ATTR.nset;
abaqus_spec.Step.Boundary{1}.VAL={setNameFix,[1,1]};
abaqus_spec.Step.Boundary{2}.VAL={setNameFix,[2,2]};
abaqus_spec.Step.Boundary{3}.VAL={setNameFix,[3,3]};

% Loads
% ** LOADS
% ** 
% ** Name: Load-1   Type: Pressure
% *Dsload
% Surf-1, P, 0.00533
% ** 
abaqus_spec.Step.Dsload{1}.VAL={innerSurfaceName,'P',pressureValue};

%Output
abaqus_spec.Step.Restart.ATTR.write='';
abaqus_spec.Step.Restart.ATTR.frequency=0;

abaqus_spec.Step.Output{1}.ATTR.field='';
abaqus_spec.Step.Output{1}.ATTR.variable='PRESELECT';
abaqus_spec.Step.Output{2}.ATTR.history='';
abaqus_spec.Step.Output{2}.ATTR.variable='PRESELECT';
abaqus_spec.Step.Node_print.ATTR.nset=outputNodeSetName;
abaqus_spec.Step.Node_print.ATTR.frequency = 1;
abaqus_spec.Step.Node_print.VAL='COORD';
abaqus_spec.Step.El_print.VAL='S';

%% Run the job using Abaqus

lockFileName=fullfile(savePath,[abaqusInpFileNamePart,'.lck']);
if exist(lockFileName,'file')
    warning('Lockfile found and deleted')
    delete(lockFileName);
end


%% Creating the INP file
% You can use |abaqusStruct2inp| to write the structure data to a file. 
abaqusStruct2inp(abaqus_spec,abaqusInpFileName);

%% Run the job using Abaqus

lockFileName=fullfile(savePath,[abaqusInpFileNamePart,'.lck']);
if exist(lockFileName,'file')
    warning('Lockfile found and deleted')
    delete(lockFileName);
end

%%

oldPath=pwd; %Get current working directory
cd(savePath); %Set new working directory to match save patch

abaqusPath='abaqus';%'/usr/bin/abaqus'; %Abaqus excute command or path
runFlag=system([abaqusPath,' inp=',abaqusInpFileName,' job=',abaqusInpFileNamePart,' interactive ask_delete=OFF']);

cd(oldPath); %Restore working directory

%% Import and visualize abaqus results
% Importing the abaqus .dat file 

[abaqusData]=importAbaqusDat(abaqusDATFileName);

%%
% Plotting the simulated results using |anim8| to visualize and animate
% deformations

%Getting final nodal coordinates
V_def=[abaqusData.STEP(1).INCREMENT(end).nodeOutput.data.COOR1...
    abaqusData.STEP(1).INCREMENT(end).nodeOutput.data.COOR2...
    abaqusData.STEP(1).INCREMENT(end).nodeOutput.data.COOR3];
U=V_def-VT; %Displacements

colorDataVertices=sqrt(sum(U.^2,2)); %Displacement magnitude data for all vertices
colorDataFaces=vertexToFaceMeasure(Fb,colorDataVertices); %Same for selection of faces

timeVec=[0 abaqusData.STEP(1).INCREMENT(:).TOTAL_TIME_COMPLETED];

% Get limits for plotting
minV=min([VT;V_def],[],1); %Minima
maxV=max([VT;V_def],[],1); %Maxima

indSegmentPlot=[indSegment(:);indSegment(1)];

% Create basic view and store graphics handle to initiate animation
hf=cFigure; %Open figure
hold on; 
gtitle([abaqusInpFileNamePart,': Press play to animate']);
hp=gpatch(Fb,V_def,colorDataFaces,'none',0.5); %Add graphics object to animate
hp2=plotV(V_def(indSegmentPlot,:),'k-','LineWidth',3,'MarkerSize',25);
% gpatch(Fb,VT,0.5*ones(1,3),'none',0.25); %A static graphics object
axisGeom(gca,fontSize);
colormap(gjet(250)); colorbar;
% caxis([0 max(colorDataVertices)]);
axis([minV(1) maxV(1) minV(2) maxV(2) minV(3) maxV(3)]); %Set axis limits statically
view(130,25); %Set view direction
camlight headlight;

% Set up animation features
animStruct.Time=timeVec; %The time vector
for qt=1:1:numel(timeVec) %Loop over time increments    
    if qt>1
        V_def=[abaqusData.STEP(1).INCREMENT(qt-1).nodeOutput.data.COOR1...
               abaqusData.STEP(1).INCREMENT(qt-1).nodeOutput.data.COOR2...
               abaqusData.STEP(1).INCREMENT(qt-1).nodeOutput.data.COOR3];
    else
        V_def=VT;
    end    
    U=V_def-VT; %Displacements
    colorDataVertices=sqrt(sum(U.^2,2)); %Displacement magnitude data for all vertices
    colorDataFaces=vertexToFaceMeasure(Fb,colorDataVertices); %Same for selection of faces
   
    %Set entries in animation structure
    animStruct.Handles{qt}=[hp hp hp2 hp2 hp2]; %Handles of objects to animate
    animStruct.Props{qt}={'Vertices','CData','XData','YData','ZData'}; %Properties of objects to animate
    animStruct.Set{qt}={V_def,colorDataFaces,V_def(indSegmentPlot,1),V_def(indSegmentPlot,2),V_def(indSegmentPlot,3)}; %Property values for to set in order to animate
end
anim8(hf,animStruct); %Initiate animation feature
drawnow;

%% Calculate segment area change as a function of time and pressure

nIncrements=numel(abaqusData.STEP(1).INCREMENT);
p=linspace(0,pressureValue,nIncrements+1);

A=NaN(size(p));
for qt=1:1:numel(timeVec) %Loop over time increments    
    if qt>1
        V_def=[abaqusData.STEP(1).INCREMENT(qt-1).nodeOutput.data.COOR1...
               abaqusData.STEP(1).INCREMENT(qt-1).nodeOutput.data.COOR2...
               abaqusData.STEP(1).INCREMENT(qt-1).nodeOutput.data.COOR3];
    else
        V_def=VT;
    end        
    A(qt)=patch_area(1:1:numel(indSegmentPlot),V_def(indSegmentPlot,:));
end

%%
cFigure; 
subplot(1,2,1);
hl(1)=plot(timeVec,p,'b.-','LineWidth',3,'MarkerSize',25); 
hLegend=legend(hl,{'time vs pressure'},'FontSize',fontSize);
hLegend.Location='NorthWest';
set(gca,'FontSize',fontSize);
grid on; 

subplot(1,2,2);
hl(1)=plot(p,A,'r.-','LineWidth',3,'MarkerSize',25); 
hLegend=legend(hl,{'pressure vs area'},'FontSize',fontSize);
hLegend.Location='NorthWest';
set(gca,'FontSize',fontSize);
grid on; 

drawnow; 


%%
%
% <<gibbVerySmall.gif>>
%
% _*GIBBON*_
% <www.gibboncode.org>
%
% _Kevin Mattheus Moerman_, <gibbon.toolbox@gmail.com>

%% 
% _*GIBBON footer text*_ 
% 
% License: <https://github.com/gibbonCode/GIBBON/blob/master/LICENSE>
% 
% GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for
% image segmentation, image-based modeling, meshing, and finite element
% analysis.
% 
% Copyright (C) 2006-2022 Kevin Mattheus Moerman and the GIBBON contributors
% 
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

##### SOURCE END #####
--></body></html>
