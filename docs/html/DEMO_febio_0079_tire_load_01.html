
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>DEMO_febio_0078_actuator_perfect_osmometer_01</title><meta name="generator" content="MATLAB 9.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-05-01"><meta name="DC.source" content="DEMO_febio_0079_tire_load_01.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>DEMO_febio_0078_actuator_perfect_osmometer_01</h1><!--introduction--><p>Below is a demonstration for:</p><div><ul><li>Building geometry for a cube with hexahedral elements</li><li>Defining the boundary conditions</li><li>Coding the febio structure</li><li>Running the model</li><li>Importing and visualizing the displacement and stress results</li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Keywords</a></li><li><a href="#4">Control parameters</a></li><li><a href="#26">Joining node sets</a></li><li><a href="#28">Define contact surfaces</a></li><li><a href="#29">Define boundary conditions</a></li><li><a href="#31">Defining the FEBio input structure</a></li><li><a href="#32">Quick viewing of the FEBio input file structure</a></li><li><a href="#34">Exporting the FEBio input file</a></li><li><a href="#35">Running the FEBio analysis</a></li><li><a href="#36">Import FEBio results</a></li></ul></div><h2 id="1">Keywords</h2><div><ul><li>febio_spec version 4.0</li><li>febio, FEBio</li><li>tire mesh</li><li>tetrahedral elements, tet4</li><li>static, solid</li><li>displacement logfile</li><li>stress logfile</li></ul></div><pre class="codeinput">clear; close <span class="string">all</span>; clc;
</pre><p>Plot settings</p><pre class="codeinput">markerSize=10;
markerSize2=10;
fontSize=15;
faceAlpha1=0.3;
faceAlpha2=0.5;
cMap=gjet(4);
</pre><h2 id="4">Control parameters</h2><pre class="codeinput"><span class="comment">% Path names</span>
defaultFolder = fileparts(fileparts(mfilename(<span class="string">'fullpath'</span>)));
savePath=fullfile(defaultFolder,<span class="string">'data'</span>,<span class="string">'temp'</span>);

<span class="comment">% Defining file names</span>
febioFebFileNamePart=<span class="string">'tempModel'</span>;
febioFebFileName=fullfile(savePath,[febioFebFileNamePart,<span class="string">'.feb'</span>]); <span class="comment">%FEB file name</span>
febioLogFileName=[febioFebFileNamePart,<span class="string">'.txt'</span>]; <span class="comment">%FEBio log file name</span>
febioLogFileName_disp=[febioFebFileNamePart,<span class="string">'_disp_out.txt'</span>]; <span class="comment">%Log file name for exporting displacement</span>
febioLogFileName_force=[febioFebFileNamePart,<span class="string">'_force_out.txt'</span>]; <span class="comment">%Log file name for exporting force</span>
febioLogFileName_sed=[febioFebFileNamePart,<span class="string">'_stress_out.txt'</span>]; <span class="comment">%Log file name for exporting strain energy density</span>

tireWidth = 120;
tireRadius = 150;
tireThickness = 8;
threadHeight = 8;
tireBulge=tireWidth/8;
pointSpacing = 8;
tireCircumference = 2*pi.*tireRadius;

numFeatures = 20;
groveWidth = 8;

distKeep=75; <span class="comment">%Distance after which model is cropped, empty = full model</span>
displacementVert=0.8*tireThickness;
displacementHor=-tireRadius/20;
contactInitialOffset=0.1;

<span class="comment">%Material parameter set</span>
c1=1e-3; <span class="comment">%Shear-modulus-like parameter</span>
m1=2; <span class="comment">%Material parameter setting degree of non-linearity</span>
k_factor=100; <span class="comment">%Bulk modulus factor</span>
k=c1*k_factor; <span class="comment">%Bulk modulus</span>

<span class="comment">% FEA control settings</span>
numTimeSteps=20; <span class="comment">%Number of time steps desired</span>
max_refs=40; <span class="comment">%Max reforms</span>
max_ups=0; <span class="comment">%Set to zero to use full-Newton iterations</span>
opt_iter=25; <span class="comment">%Optimum number of iterations</span>
max_retries=5; <span class="comment">%Maximum number of retires</span>
dtmin=(1/numTimeSteps)/100; <span class="comment">%Minimum time step size</span>
dtmax=1/numTimeSteps; <span class="comment">%Maximum time step size</span>
runMode=<span class="string">'external'</span>;<span class="comment">%'internal';</span>
min_residual=1e-20;

<span class="comment">%Contact parameters</span>
contactPenalty=5;
laugon=0;
minaug=1;
maxaug=10;
fric_coeff=0.5;
</pre><pre class="codeinput">tireHalfWidth=tireWidth/2;
featureHeight = (tireCircumference-(numFeatures*groveWidth))./numFeatures;
featureWidth = tireHalfWidth-2*groveWidth;

<span class="comment">% Coordinates of 1x1 square</span>
v=[-1 -1 0;<span class="keyword">...</span>
    1 -1 0;<span class="keyword">...</span>
    1  1 0;<span class="keyword">...</span>
    -1  1 0]/2;

<span class="comment">% Deformation gradient tensor for shear</span>
f=eye(3,3);
f(1,2)=1;

<span class="comment">%Create boundary coordinates</span>
V1=v; <span class="comment">%Copy square</span>
V1(:,1)=V1(:,1).*tireCircumference+tireCircumference/2; <span class="comment">%Stretch to create circumference</span>
V1(:,2)=V1(:,2).*tireHalfWidth+tireHalfWidth/2; <span class="comment">%Stretch to get desired width</span>
V1=evenlySpaceCurve(V1,pointSpacing,<span class="string">'linear'</span>,1,1:1:size(v,1)); <span class="comment">%Evenly sample</span>
V1=(f*V1')'; <span class="comment">%Shear</span>

<span class="comment">%Create thread feature</span>
Vf=v; <span class="comment">%Copy square</span>
Vf(:,1)=Vf(:,1).*featureHeight; <span class="comment">%Stretch to create circumference</span>
Vf(:,2)=Vf(:,2).*(featureWidth+groveWidth/2)+tireHalfWidth/2-groveWidth/4; <span class="comment">%Stretch to get desired width</span>
Vf=evenlySpaceCurve(Vf,pointSpacing,<span class="string">'linear'</span>,1,1:1:size(v,1)); <span class="comment">%Evenly sample</span>
Vf(:,1)=Vf(:,1)+featureHeight/2+groveWidth/2;

VF=cell(1,numFeatures);
<span class="keyword">for</span> q=1:1:numFeatures
    Vff=Vf;
    Vff(:,1)=Vf(:,1)+(q-1).*(featureHeight+groveWidth); <span class="comment">%Shift</span>
    VF{q}=(f*Vff')'; <span class="comment">%Shear and store</span>
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="comment">%Defining 4 regions</span>
regionSpec{1}={V1(:,[1 2])};
<span class="keyword">for</span> q=1:1:numFeatures
    regionSpec{1}{q+1}=VF{q}(:,[1 2]);
<span class="keyword">end</span>

<span class="keyword">for</span> q=1:1:numFeatures
    regionSpec{q+1}{1}=VF{q}(:,[1 2]);
<span class="keyword">end</span>

[Ft,Vt,Ct]=multiRegionTriMesh2D(regionSpec,pointSpacing,0,0);
Vt(:,3)=0;

Fb=fliplr(Ft);
Vb=Vt;
Vb(:,2)=-Vb(:,2);

Cb=Ct;
Cb(Cb&gt;1)=Cb(Cb&gt;1)-1+max(Ct);

[F,V,C]=joinElementSets({Ft,Fb},{Vt,Vb},{Ct,Cb});
[F,V]=mergeVertices(F,V);
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
plotV(V1,<span class="string">'r.-'</span>,<span class="string">'MarkerSize'</span>,markerSize);
plotV(VF,<span class="string">'b.-'</span>,<span class="string">'MarkerSize'</span>,markerSize);
gpatch(F,V,C);

axisGeom(gca,fontSize); view(2);
colormap <span class="string">spectral</span>; icolorbar;
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0079_tire_load_01_01.jpg" alt=""> <pre class="codeinput">cMax=max(C);
numVert=size(V,1);
F2=F(C&gt;1,:);
C2=C(C&gt;1,:)+cMax;
Eb1=patchBoundary(F2);

Eb2=Eb1+numVert;
F=[F(C==1,:);F2+numVert];
V=[V;V];
C=[C(C==1,:);C2+max(C(:))];
</pre><pre class="codeinput"><span class="keyword">if</span> tireBulge&gt;eps(0)
    w=tireWidth;
    h=tireBulge;
    r=h/2+(w^2/(8*h));
    a=atan((w/2)./(r-h));

    TH = (V(:,2)./tireHalfWidth)*a;
    R = r.*ones(size(V,1),1);
    R(numVert+1:end)=R(numVert+1:end)+threadHeight;
    Z = V(:,1);
    [V(:,1),V(:,2),V(:,3)] = pol2cart(TH,R,Z);
    V=V(:,[3 2 1]);

    V(:,3)=V(:,3)-r+h;
<span class="keyword">else</span>
    V(numVert+1:end,3)=V(numVert+1:end,3)+threadHeight;
<span class="keyword">end</span>
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
plotV(V1,<span class="string">'r.-'</span>,<span class="string">'MarkerSize'</span>,markerSize);
plotV(VF,<span class="string">'b.-'</span>,<span class="string">'MarkerSize'</span>,markerSize);
gpatch(F,V,C);

axisGeom(gca,fontSize); view(2);
colormap <span class="string">spectral</span>; icolorbar;
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0079_tire_load_01_02.jpg" alt=""> <pre class="codeinput">TH = V(:,1)./tireRadius;
R = tireRadius+V(:,3);

Z = V(:,2);
[V(:,1),V(:,2),V(:,3)] = pol2cart(TH,R,Z);
V=V(:,[1 3 2]); F=fliplr(F);

[Eb1,V1]=patchCleanUnused(Eb1,V);
[Eb2,V2]=patchCleanUnused(Eb2,V);

[F,V,~,indFix]=mergeVertices(F,V);

numSteps=ceil(threadHeight./pointSpacing)+1;


<span class="comment">%Create quadrilateral faces</span>
X=linspacen(V1(:,1),V2(:,1),numSteps);
Y=linspacen(V1(:,2),V2(:,2),numSteps);
Z=linspacen(V1(:,3),V2(:,3),numSteps);

Vn=[X(:) Y(:) Z(:)]; <span class="comment">%Vertex set</span>
Fn=repmat([fliplr(Eb1) Eb2],numSteps-1,1);
q=repmat(0:(numSteps-2),size(Eb1,1),1);
q=q(:);
Q=[q q q+1 q+1]*size(V1,1);
Fn=Fn+Q;

[Fn,Vn]=quad2tri(Fn,Vn,<span class="string">'a'</span>);
</pre><pre class="codeinput">[F,V]=patchCleanUnused(F,V);
C(C&gt;1)=2; <span class="comment">%Switch to use 2 for all thread profile parts</span>
[F_out,V_out,C_out]=joinElementSets({F,Fn},{V,Vn},{C,max(C(:))+1*ones(size(Fn,1),1)});
[F_out,V_out]=patchCleanUnused(F_out,V_out);
[F_out,V_out]=mergeVertices(F_out,V_out);
Eb_out=patchBoundary(F_out);
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
gpatch(F_out,V_out,C_out);
<span class="comment">% patchNormPlot(Fq,Vq);</span>
axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;
colormap <span class="string">spectral</span>; icolorbar;
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0079_tire_load_01_03.jpg" alt=""> <p>Create inner cylinder</p><pre class="codeinput">inputStructCyl.cylRadius=tireRadius-tireThickness;
inputStructCyl.numRadial=ceil((2*pi*inputStructCyl.cylRadius)/pointSpacing);
inputStructCyl.cylHeight=tireWidth;
numheight=ceil(tireWidth./pointSpacing);
numheight=numheight+iseven(numheight); <span class="comment">%Force uneven</span>
inputStructCyl.numHeight=numheight;
inputStructCyl.meshType=<span class="string">'tri'</span>;
</pre><p>Derive patch data for a cylinder</p><pre class="codeinput">[F_in,V_in]=patchcylinder(inputStructCyl);
V_in=V_in(:,[1 3 2]);
Eb_in=patchBoundary(F_in);
C_in=(max(C_out)+1)*ones(size(F_in,1),1);
</pre><pre class="codeinput">inputStructGroup.outputType=<span class="string">'label'</span>;
G_out=tesgroup(Eb_out,inputStructGroup);
G_in=tesgroup(Eb_in,inputStructGroup);

yMean_out=nan(2,1);
yMean_in=nan(2,1);
<span class="keyword">for</span> q=1:1:2
    ind_out=Eb_out(G_out==q,:);
    yMean_out(q)=mean(V_out(ind_out(:),2));

    ind_in=Eb_in(G_in==q,:);
    yMean_in(q)=mean(V_in(ind_in(:),2));
<span class="keyword">end</span>

[~,ind1_out]=min(yMean_out);
[~,ind2_out]=max(yMean_out);
indCurve1_out=edgeListToCurve(Eb_out(G_out==ind1_out,:));
indCurve1_out=indCurve1_out(1:end-1);
indCurve2_out=edgeListToCurve(Eb_out(G_out==ind2_out,:));
indCurve2_out=indCurve2_out(1:end-1);

[~,ind1_in]=min(yMean_in);
[~,ind2_in]=max(yMean_in);
indCurve1_in=edgeListToCurve(Eb_in(G_in==ind1_in,:));
indCurve1_in=indCurve1_in(1:end-1);
indCurve2_in=edgeListToCurve(Eb_in(G_in==ind2_in,:));
indCurve2_in=indCurve2_in(1:end-1);

[Fs1,Vs1]=regionTriMesh2D({V_out(indCurve1_out,[1 3]),V_in(indCurve1_in,[1 3])},pointSpacing,0);
Vs1(:,3)=-tireWidth/2;
Vs1=Vs1(:,[1 3 2]);
Cs1=(max(C_in)+1)*ones(size(Fs1,1),1);

[Fs2,Vs2]=regionTriMesh2D({V_out(indCurve2_out,[1 3]),V_in(indCurve2_in,[1 3])},pointSpacing,0);
Vs2(:,3)=tireWidth/2;
Vs2=Vs2(:,[1 3 2]);
Fs2=fliplr(Fs2);
Cs2=(max(Cs1)+1)*ones(size(Fs2,1),1);
</pre><pre class="codeinput">[FT,VT,CT]=joinElementSets({F_out,F_in,Fs1,Fs2},{V_out,V_in,Vs1,Vs2},{C_out,C_in,Cs1,Cs2});
[FT,VT]=patchCleanUnused(FT,VT);
[FT,VT]=mergeVertices(FT,VT);
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;

gpatch(FT,VT,CT,<span class="string">'none'</span>);
patchNormPlot(FT,VT);

axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;
colormap <span class="string">spectral</span>; icolorbar;
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0079_tire_load_01_04.jpg" alt=""> <pre class="codeinput">V_regions=getInnerPoint(FT,VT); <span class="comment">%Define region points</span>
V_holes=[]; <span class="comment">%Define hole points</span>
[regionTetVolumes]=tetVolMeanEst(FT,VT); <span class="comment">%Volume estimate for regular tets</span>
stringOpt=<span class="string">'-pq1.2AaY'</span>; <span class="comment">%Options for tetgen</span>
</pre><p>Mesh using TetGen</p><pre class="codeinput"><span class="comment">%Create tetgen input structure</span>
inputStruct.stringOpt=stringOpt; <span class="comment">%Tetgen options</span>
inputStruct.Faces=FT; <span class="comment">%Boundary faces</span>
inputStruct.Nodes=VT; <span class="comment">%Nodes of boundary</span>
inputStruct.faceBoundaryMarker=CT;
inputStruct.regionPoints=V_regions; <span class="comment">%Interior points for regions</span>
inputStruct.holePoints=V_holes; <span class="comment">%Interior points for holes</span>
inputStruct.regionA=regionTetVolumes; <span class="comment">%Desired tetrahedral volume for each region</span>

<span class="comment">% Mesh model using tetrahedral elements using tetGen</span>
[meshOutput]=runTetGen(inputStruct); <span class="comment">%Run tetGen</span>
</pre><pre class="codeoutput"> 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- TETGEN Tetrahedral meshing --- 01-May-2023 10:49:05
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- Writing SMESH file --- 01-May-2023 10:49:05
----&gt; Adding node field
----&gt; Adding facet field
----&gt; Adding holes specification
----&gt; Adding region specification
--- Done --- 01-May-2023 10:49:05
--- Running TetGen to mesh input boundary--- 01-May-2023 10:49:05
Opening /home/kevin/GIBBON/data/temp/temp.smesh.
Delaunizing vertices...
Delaunay seconds:  0.135211
Creating surface mesh ...
Surface mesh seconds:  0.004317
Recovering boundaries...
Boundary recovery seconds:  0.010824
Removing exterior tetrahedra ...
Spreading region attributes.
Exterior tets removal seconds:  0.003438
Recovering Delaunayness...
Delaunay recovery seconds:  0.007581
Refining mesh...
  6411 insertions, added 4090 points, 103234 tetrahedra in queue.
  2134 insertions, added 619 points, 87009 tetrahedra in queue.
  2845 insertions, added 341 points, 2287 tetrahedra in queue.
  3792 insertions, added 312 points, 4989 tetrahedra in queue.
Refinement seconds:  0.111714
Smoothing vertices...
Mesh smoothing seconds:  0.148974
Improving mesh...
Mesh improvement seconds:  0.006856

Writing /home/kevin/GIBBON/data/temp/temp.1.node.
Writing /home/kevin/GIBBON/data/temp/temp.1.ele.
Writing /home/kevin/GIBBON/data/temp/temp.1.face.
Writing /home/kevin/GIBBON/data/temp/temp.1.edge.

Output seconds:  0.024339
Total running seconds:  0.453498

Statistics:

  Input points: 4810
  Input facets: 9620
  Input segments: 14430
  Input holes: 0
  Input regions: 1

  Mesh points: 10238
  Mesh tetrahedra: 47968
  Mesh faces: 100746
  Mesh faces on exterior boundary: 9620
  Mesh faces on input facets: 9620
  Mesh edges on input segments: 14430
  Steiner points inside domain: 5428

--- Done --- 01-May-2023 10:49:06
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- Importing TetGen files --- 01-May-2023 10:49:06
--- Done --- 01-May-2023 10:49:06
</pre><p>Access mesh output structure</p><pre class="codeinput">E=meshOutput.elements; <span class="comment">%The elements</span>
V=meshOutput.nodes; <span class="comment">%The vertices or nodes</span>
Fb=meshOutput.facesBoundary; <span class="comment">%The boundary faces</span>
Cb=meshOutput.boundaryMarker; <span class="comment">%The boundary markers</span>
</pre><p>Visualization</p><pre class="codeinput">hf=cFigure;
subplot(1,2,1); hold <span class="string">on</span>;
title(<span class="string">'Input boundaries'</span>,<span class="string">'FontSize'</span>,fontSize);
hp(1)=gpatch(Fb,V,Cb,<span class="string">'k'</span>,faceAlpha1);
hp(2)=plotV(V_regions,<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
legend(hp,{<span class="string">'Input mesh'</span>,<span class="string">'Interior point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'NorthWestOutside'</span>);
axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;
colormap(cMap); icolorbar;

hs=subplot(1,2,2); hold <span class="string">on</span>;
title(<span class="string">'Tetrahedral mesh'</span>,<span class="string">'FontSize'</span>,fontSize);

<span class="comment">% Visualizing using |meshView|</span>
optionStruct.hFig=[hf,hs];
meshView(meshOutput,optionStruct);

axisGeom(gca,fontSize);
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0079_tire_load_01_05.jpg" alt=""> <pre class="codeinput"><span class="keyword">if</span> ~isempty(distKeep)
    Fb_full=Fb;
    V_full=V;
    [Fb_full,V_full]=patchCleanUnused(Fb_full,V_full);

    VE=patchCentre(E,V);
    logicKeepElements = VE(:,3) &lt;= (min(VE(:,3))+distKeep);
    E=E(logicKeepElements,:);
    indKeepNodes=unique(E);
    logicKeep_Fb=all(ismember(Fb,indKeepNodes),2);
    Fb=Fb(logicKeep_Fb,:);
    Cb=Cb(logicKeep_Fb,:);

    logicKeep_F=all(ismember(F,indKeepNodes),2);
    F=F(logicKeep_F,:);

    [E,V,indFix]=patchCleanUnused(E,V);
    Fb=indFix(Fb);
    F=indFix(F);
    meshOutput.nodes=V;
    meshOutput.facesBoundary=Fb;
    meshOutput.boundaryMarker=Cb;
    meshOutput.faces=F;
    meshOutput.elements=E;
    meshOutput.elementMaterialID=ones(size(E,1),1);
<span class="keyword">else</span>
    Fb_full=Fb;
    V_full=V;
<span class="keyword">end</span>
</pre><pre class="codeinput">hf=cFigure;
subplot(1,2,1); hold <span class="string">on</span>;
title(<span class="string">'Input boundaries'</span>,<span class="string">'FontSize'</span>,fontSize);
hp(1)=gpatch(Fb,V,Cb,<span class="string">'k'</span>,faceAlpha1);
hp(2)=plotV(V_regions,<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,markerSize);
legend(hp,{<span class="string">'Input mesh'</span>,<span class="string">'Interior point(s)'</span>},<span class="string">'Location'</span>,<span class="string">'NorthWestOutside'</span>);
axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;
colormap(cMap); icolorbar;

hs=subplot(1,2,2); hold <span class="string">on</span>;
title(<span class="string">'Tetrahedral mesh'</span>,<span class="string">'FontSize'</span>,fontSize);

<span class="comment">% Visualizing using |meshView|</span>
optionStruct.hFig=[hf,hs];
meshView(meshOutput,optionStruct);

axisGeom(gca,fontSize);
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0079_tire_load_01_06.jpg" alt=""> <pre class="codeinput">plateDim=[2*tireRadius tireWidth];
plateEl=ceil(plateDim./pointSpacing);
[Eg,Vg]=quadPlate(plateDim,plateEl);
Vg(:,3)=Vg(:,3)+min(VT(:,3))-contactInitialOffset;
center_of_mass=mean(Vg,1);
</pre><h2 id="26">Joining node sets</h2><pre class="codeinput">Eg=Eg+size(V,1); <span class="comment">%Fixed element indices</span>
V=[V;Vg;]; <span class="comment">%Combined node sets</span>
</pre><pre class="codeinput">cFigure; hold <span class="string">on</span>;
hp(1)=gpatch(Fb,V,Cb,<span class="string">'k'</span>,faceAlpha1);
hp(2)=gpatch(Eg,V,<span class="string">'kw'</span>,<span class="string">'k'</span>,faceAlpha1);
<span class="comment">% legend(hp,{'Input mesh','Interior point(s)'},'Location','NorthWestOutside');</span>
axisGeom(gca,fontSize); camlight <span class="string">headlight</span>;
colormap(cMap); icolorbar;
gdrawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0079_tire_load_01_07.jpg" alt=""> <h2 id="28">Define contact surfaces</h2><pre class="codeinput"><span class="comment">% The rigid master surface of the sphere</span>
F_contact_secondary=Eg;

<span class="comment">% The deformable slave surface of the slab</span>
logicContactSurf1=Cb==2;
F_contact_primary=fliplr(Fb(logicContactSurf1,:));

<span class="comment">% Plotting surface models</span>
cFigure; hold <span class="string">on</span>;
title(<span class="string">'Contact sets and normal directions'</span>,<span class="string">'FontSize'</span>,fontSize);

gpatch(Fb,V,<span class="string">'kw'</span>,<span class="string">'none'</span>,faceAlpha2);
hl(1)=gpatch(F_contact_secondary,V,<span class="string">'g'</span>,<span class="string">'k'</span>,1);
patchNormPlot(F_contact_secondary,V);
hl(2)=gpatch(F_contact_primary,V,<span class="string">'b'</span>,<span class="string">'k'</span>,1);
patchNormPlot(F_contact_primary,V);

legend(hl,{<span class="string">'Secondary'</span>,<span class="string">'Primary'</span>});

axisGeom(gca,fontSize);
camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0079_tire_load_01_08.jpg" alt=""> <h2 id="29">Define boundary conditions</h2><pre class="codeinput"><span class="comment">%Supported nodes</span>
bcSupportList=unique(Fb(Cb==4,:));
</pre><p>Visualize BC's</p><pre class="codeinput">hf=cFigure;
title(<span class="string">'Boundary conditions model'</span>,<span class="string">'FontSize'</span>,fontSize);
xlabel(<span class="string">'X'</span>,<span class="string">'FontSize'</span>,fontSize); ylabel(<span class="string">'Y'</span>,<span class="string">'FontSize'</span>,fontSize); zlabel(<span class="string">'Z'</span>,<span class="string">'FontSize'</span>,fontSize);
hold <span class="string">on</span>;

gpatch(Fb,V,<span class="string">'w'</span>,<span class="string">'none'</span>,faceAlpha2);

hl2(1)=gpatch(Eg,V,<span class="string">'gw'</span>,<span class="string">'k'</span>,1);
hl2(2)=plotV(V(bcSupportList,:),<span class="string">'k.'</span>,<span class="string">'MarkerSize'</span>,markerSize);

legend(hl2,{<span class="string">'Rigid body plate'</span>,<span class="string">'BC support'</span>});

axisGeom(gca,fontSize);
camlight <span class="string">headlight</span>;
drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0079_tire_load_01_09.jpg" alt=""> <h2 id="31">Defining the FEBio input structure</h2><p>See also <tt>febioStructTemplate</tt> and <tt>febioStruct2xml</tt> and the FEBio user manual.</p><pre class="codeinput"><span class="comment">%Get a template with default settings</span>
[febio_spec]=febioStructTemplate;

<span class="comment">%febio_spec version</span>
febio_spec.ATTR.version=<span class="string">'4.0'</span>;

<span class="comment">%Module section</span>
febio_spec.Module.ATTR.type=<span class="string">'solid'</span>;

<span class="comment">%Create control structure for use by all steps</span>
stepStruct.Control.time_steps=numTimeSteps;
stepStruct.Control.step_size=1/numTimeSteps;
stepStruct.Control.solver.max_refs=max_refs;
stepStruct.Control.time_stepper.dtmin=dtmin;
stepStruct.Control.time_stepper.dtmax=dtmax;
stepStruct.Control.time_stepper.max_retries=max_retries;
stepStruct.Control.time_stepper.opt_iter=opt_iter;

<span class="comment">%Add template based default settings to proposed control section</span>
[stepStruct.Control]=structComplete(stepStruct.Control,febio_spec.Control,1); <span class="comment">%Complement provided with default if missing</span>

<span class="comment">%Remove control field (part of template) since step specific control sections are used</span>
febio_spec=rmfield(febio_spec,<span class="string">'Control'</span>);

febio_spec.Step.step{1}.Control=stepStruct.Control;
febio_spec.Step.step{1}.ATTR.id=1;
febio_spec.Step.step{2}.Control=stepStruct.Control;
febio_spec.Step.step{2}.ATTR.id=2;

<span class="comment">%Material section</span>
materialName1=<span class="string">'Material1'</span>;
febio_spec.Material.material{1}.ATTR.name=materialName1;
febio_spec.Material.material{1}.ATTR.type=<span class="string">'Ogden'</span>;
febio_spec.Material.material{1}.ATTR.id=1;
febio_spec.Material.material{1}.c1=c1;
febio_spec.Material.material{1}.m1=m1;
febio_spec.Material.material{1}.c2=c1;
febio_spec.Material.material{1}.m2=-m1;
febio_spec.Material.material{1}.k=k;

materialName2=<span class="string">'Material2'</span>;
febio_spec.Material.material{2}.ATTR.name=materialName2;
febio_spec.Material.material{2}.ATTR.type=<span class="string">'rigid body'</span>;
febio_spec.Material.material{2}.ATTR.id=2;
febio_spec.Material.material{2}.density=1;
febio_spec.Material.material{2}.center_of_mass=center_of_mass;

<span class="comment">%Mesh section</span>
<span class="comment">% -&gt; Nodes</span>
febio_spec.Mesh.Nodes{1}.ATTR.name=<span class="string">'nodeSet_all'</span>; <span class="comment">%The node set name</span>
febio_spec.Mesh.Nodes{1}.node.ATTR.id=(1:size(V,1))'; <span class="comment">%The node id's</span>
febio_spec.Mesh.Nodes{1}.node.VAL=V; <span class="comment">%The nodel coordinates</span>

<span class="comment">% -&gt; Elements</span>
partName1=<span class="string">'Part1'</span>;
febio_spec.Mesh.Elements{1}.ATTR.name=partName1; <span class="comment">%Name of this part</span>
febio_spec.Mesh.Elements{1}.ATTR.type=<span class="string">'tet4'</span>; <span class="comment">%Element type</span>
febio_spec.Mesh.Elements{1}.elem.ATTR.id=(1:1:size(E,1))'; <span class="comment">%Element id's</span>
febio_spec.Mesh.Elements{1}.elem.VAL=E; <span class="comment">%The element matrix</span>

partName2=<span class="string">'Part2'</span>;
febio_spec.Mesh.Elements{2}.ATTR.name=partName2; <span class="comment">%Name of this part</span>
febio_spec.Mesh.Elements{2}.ATTR.type=<span class="string">'quad4'</span>; <span class="comment">%Element type</span>
febio_spec.Mesh.Elements{2}.elem.ATTR.id=size(E,1)+(1:1:size(Eg,1))'; <span class="comment">%Element id's</span>
febio_spec.Mesh.Elements{2}.elem.VAL=Eg; <span class="comment">%The element matrix</span>

<span class="comment">% -&gt; NodeSets</span>
nodeSetName1=<span class="string">'bcSupportList'</span>;
febio_spec.Mesh.NodeSet{1}.ATTR.name=nodeSetName1;
febio_spec.Mesh.NodeSet{1}.VAL=mrow(bcSupportList);

<span class="comment">%MeshDomains section</span>
febio_spec.MeshDomains.SolidDomain.ATTR.name=partName1;
febio_spec.MeshDomains.SolidDomain.ATTR.mat=materialName1;

febio_spec.MeshDomains.ShellDomain.ATTR.name=partName2;
febio_spec.MeshDomains.ShellDomain.ATTR.mat=materialName2;

<span class="comment">% -&gt; Surfaces</span>
surfaceName1=<span class="string">'contactSurface1'</span>;
febio_spec.Mesh.Surface{1}.ATTR.name=surfaceName1;
febio_spec.Mesh.Surface{1}.quad4.ATTR.id=(1:1:size(F_contact_secondary,1))';
febio_spec.Mesh.Surface{1}.quad4.VAL=F_contact_secondary;

surfaceName2=<span class="string">'contactSurface2'</span>;
febio_spec.Mesh.Surface{2}.ATTR.name=surfaceName2;
febio_spec.Mesh.Surface{2}.tri3.ATTR.id=(1:1:size(F_contact_primary,1))';
febio_spec.Mesh.Surface{2}.tri3.VAL=F_contact_primary;

<span class="comment">% -&gt; Surface pairs</span>
febio_spec.Mesh.SurfacePair{1}.ATTR.name=<span class="string">'Contact1'</span>;
febio_spec.Mesh.SurfacePair{1}.primary=surfaceName2;
febio_spec.Mesh.SurfacePair{1}.secondary=surfaceName1;

<span class="comment">%Boundary condition section</span>
<span class="comment">% -&gt; Fix boundary conditions</span>
febio_spec.Boundary.bc{1}.ATTR.name=<span class="string">'zero_displacement_xyz'</span>;
febio_spec.Boundary.bc{1}.ATTR.type=<span class="string">'zero displacement'</span>;
febio_spec.Boundary.bc{1}.ATTR.node_set=nodeSetName1;
febio_spec.Boundary.bc{1}.x_dof=1;
febio_spec.Boundary.bc{1}.y_dof=1;
febio_spec.Boundary.bc{1}.z_dof=1;

<span class="comment">%Rigid section</span>
<span class="comment">% -&gt; Prescribed rigid body boundary conditions</span>
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.ATTR.name=<span class="string">'RigidFix_1'</span>;
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.ATTR.type=<span class="string">'rigid_fixed'</span>;
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.rb=2;
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.Rx_dof=1;
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.Ry_dof=1;
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.Rz_dof=0;
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.Ru_dof=1;
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.Rv_dof=1;
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.Rw_dof=1;

febio_spec.Step.step{1}.Rigid.rigid_bc{2}.ATTR.name=<span class="string">'RigidPrescribe'</span>;
febio_spec.Step.step{1}.Rigid.rigid_bc{2}.ATTR.type=<span class="string">'rigid_displacement'</span>;
febio_spec.Step.step{1}.Rigid.rigid_bc{2}.rb=2;
febio_spec.Step.step{1}.Rigid.rigid_bc{2}.dof=<span class="string">'z'</span>;
febio_spec.Step.step{1}.Rigid.rigid_bc{2}.value.ATTR.lc=1;
febio_spec.Step.step{1}.Rigid.rigid_bc{2}.value.VAL=(displacementVert+contactInitialOffset);

febio_spec.Step.step{2}.Rigid.rigid_bc{1}.ATTR.name=<span class="string">'RigidFix_1'</span>;
febio_spec.Step.step{2}.Rigid.rigid_bc{1}.ATTR.type=<span class="string">'rigid_fixed'</span>;
febio_spec.Step.step{2}.Rigid.rigid_bc{1}.Rx_dof=0;
febio_spec.Step.step{2}.Rigid.rigid_bc{1}.Ry_dof=1;
febio_spec.Step.step{2}.Rigid.rigid_bc{1}.Rz_dof=1;
febio_spec.Step.step{2}.Rigid.rigid_bc{1}.Ru_dof=1;
febio_spec.Step.step{2}.Rigid.rigid_bc{1}.Rv_dof=1;
febio_spec.Step.step{2}.Rigid.rigid_bc{1}.Rw_dof=1;

febio_spec.Step.step{2}.Rigid.rigid_bc{2}.ATTR.name=<span class="string">'RigidPrescribe'</span>;
febio_spec.Step.step{2}.Rigid.rigid_bc{2}.ATTR.type=<span class="string">'rigid_displacement'</span>;
febio_spec.Step.step{2}.Rigid.rigid_bc{2}.rb=2;
febio_spec.Step.step{2}.Rigid.rigid_bc{2}.dof=<span class="string">'x'</span>;
febio_spec.Step.step{2}.Rigid.rigid_bc{2}.value.ATTR.lc=2;
febio_spec.Step.step{2}.Rigid.rigid_bc{2}.value.VAL=displacementHor;
febio_spec.Step.step{2}.Rigid.rigid_bc{2}.relative=1;

<span class="comment">%Contact section</span>
febio_spec.Contact.contact{1}.ATTR.type=<span class="string">'sliding-elastic'</span>;
febio_spec.Contact.contact{1}.ATTR.surface_pair=febio_spec.Mesh.SurfacePair{1}.ATTR.name;
febio_spec.Contact.contact{1}.two_pass=0;
febio_spec.Contact.contact{1}.laugon=laugon;
febio_spec.Contact.contact{1}.tolerance=0.2;
febio_spec.Contact.contact{1}.gaptol=0;
febio_spec.Contact.contact{1}.minaug=minaug;
febio_spec.Contact.contact{1}.maxaug=maxaug;
febio_spec.Contact.contact{1}.search_tol=0.01;
febio_spec.Contact.contact{1}.search_radius=0.1*sqrt(sum((max(V,[],1)-min(V,[],1)).^2,2));
febio_spec.Contact.contact{1}.symmetric_stiffness=0;
febio_spec.Contact.contact{1}.auto_penalty=1;
febio_spec.Contact.contact{1}.penalty=contactPenalty;
febio_spec.Contact.contact{1}.fric_coeff=fric_coeff;

<span class="comment">%LoadData section</span>
<span class="comment">% -&gt; load_controller</span>
febio_spec.LoadData.load_controller{1}.ATTR.name=<span class="string">'LC_1'</span>;
febio_spec.LoadData.load_controller{1}.ATTR.id=1;
febio_spec.LoadData.load_controller{1}.ATTR.type=<span class="string">'loadcurve'</span>;
febio_spec.LoadData.load_controller{1}.interpolate=<span class="string">'LINEAR'</span>;
<span class="comment">%febio_spec.LoadData.load_controller{1}.extend='CONSTANT';</span>
febio_spec.LoadData.load_controller{1}.points.pt.VAL=[0 0; 1 1; 2 1];

febio_spec.LoadData.load_controller{2}.ATTR.name=<span class="string">'LC_2'</span>;
febio_spec.LoadData.load_controller{2}.ATTR.id=2;
febio_spec.LoadData.load_controller{2}.ATTR.type=<span class="string">'loadcurve'</span>;
febio_spec.LoadData.load_controller{2}.interpolate=<span class="string">'LINEAR'</span>;
<span class="comment">%febio_spec.LoadData.load_controller{2}.extend='CONSTANT';</span>
febio_spec.LoadData.load_controller{2}.points.pt.VAL=[0 0; 1 0; 2 1];

<span class="comment">%Output section</span>
<span class="comment">% -&gt; log file</span>
febio_spec.Output.logfile.ATTR.file=febioLogFileName;
febio_spec.Output.logfile.node_data{1}.ATTR.file=febioLogFileName_disp;
febio_spec.Output.logfile.node_data{1}.ATTR.data=<span class="string">'ux;uy;uz'</span>;
febio_spec.Output.logfile.node_data{1}.ATTR.delim=<span class="string">','</span>;

febio_spec.Output.logfile.node_data{2}.ATTR.file=febioLogFileName_force;
febio_spec.Output.logfile.node_data{2}.ATTR.data=<span class="string">'Rx;Ry;Rz'</span>;
febio_spec.Output.logfile.node_data{2}.ATTR.delim=<span class="string">','</span>;

febio_spec.Output.logfile.element_data{1}.ATTR.file=febioLogFileName_sed;
febio_spec.Output.logfile.element_data{1}.ATTR.data=<span class="string">'sed'</span>;
febio_spec.Output.logfile.element_data{1}.ATTR.delim=<span class="string">','</span>;

<span class="comment">% Plotfile section</span>
febio_spec.Output.plotfile.compression=0;
</pre><h2 id="32">Quick viewing of the FEBio input file structure</h2><p>The <tt>febView</tt> function can be used to view the xml structure in a MATLAB figure window.</p><p><tt>febView(febio_spec); %Viewing the febio file</tt></p><h2 id="34">Exporting the FEBio input file</h2><p>Exporting the febio_spec structure to an FEBio input file is done using the <tt>febioStruct2xml</tt> function.</p><pre class="codeinput">febioStruct2xml(febio_spec,febioFebFileName); <span class="comment">%Exporting to file and domNode</span>
</pre><h2 id="35">Running the FEBio analysis</h2><p>To run the analysis defined by the created FEBio input file the <tt>runMonitorFEBio</tt> function is used. The input for this function is a structure defining job settings e.g. the FEBio input file name. The optional output runFlag informs the user if the analysis was run succesfully.</p><pre class="codeinput">febioAnalysis.run_filename=febioFebFileName; <span class="comment">%The input file name</span>
febioAnalysis.run_logname=febioLogFileName; <span class="comment">%The name for the log file</span>
febioAnalysis.disp_on=1; <span class="comment">%Display information on the command window</span>
febioAnalysis.runMode=runMode;

[runFlag]=runMonitorFEBio(febioAnalysis);<span class="comment">%START FEBio NOW!!!!!!!!</span>
</pre><pre class="codeoutput"> 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--------&gt;    RUNNING/MONITORING FEBIO JOB    &lt;-------- 01-May-2023 10:49:15
FEBio path: /home/kevin/FEBioStudio/bin/febio4
# Attempt removal of existing log files                01-May-2023 10:49:16
 * Removal succesful                                   01-May-2023 10:49:16
# Attempt removal of existing .xplt files              01-May-2023 10:49:16
 * Removal succesful                                   01-May-2023 10:49:16
# Starting FEBio...                                    01-May-2023 10:49:16
  Max. total analysis time is: Inf s
 * Waiting for log file creation                       01-May-2023 10:49:16
   Max. wait time: 30 s
 * Log file found.                                     01-May-2023 10:49:16
# Parsing log file...                                  01-May-2023 10:49:16
    number of iterations   : 4                         01-May-2023 10:49:17
    number of reformations : 4                         01-May-2023 10:49:17
------- converged at time : 0.05                       01-May-2023 10:49:17
    number of iterations   : 4                         01-May-2023 10:49:17
    number of reformations : 4                         01-May-2023 10:49:17
------- converged at time : 0.1                        01-May-2023 10:49:17
    number of iterations   : 4                         01-May-2023 10:49:17
    number of reformations : 4                         01-May-2023 10:49:17
------- converged at time : 0.15                       01-May-2023 10:49:17
    number of iterations   : 5                         01-May-2023 10:49:17
    number of reformations : 5                         01-May-2023 10:49:17
------- converged at time : 0.2                        01-May-2023 10:49:17
    number of iterations   : 4                         01-May-2023 10:49:17
    number of reformations : 4                         01-May-2023 10:49:17
------- converged at time : 0.25                       01-May-2023 10:49:17
    number of iterations   : 5                         01-May-2023 10:49:18
    number of reformations : 5                         01-May-2023 10:49:18
------- converged at time : 0.3                        01-May-2023 10:49:18
    number of iterations   : 5                         01-May-2023 10:49:18
    number of reformations : 5                         01-May-2023 10:49:18
------- converged at time : 0.35                       01-May-2023 10:49:18
    number of iterations   : 5                         01-May-2023 10:49:18
    number of reformations : 5                         01-May-2023 10:49:18
------- converged at time : 0.4                        01-May-2023 10:49:18
    number of iterations   : 5                         01-May-2023 10:49:19
    number of reformations : 5                         01-May-2023 10:49:19
------- converged at time : 0.45                       01-May-2023 10:49:19
    number of iterations   : 4                         01-May-2023 10:49:19
    number of reformations : 4                         01-May-2023 10:49:19
------- converged at time : 0.5                        01-May-2023 10:49:19
    number of iterations   : 5                         01-May-2023 10:49:20
    number of reformations : 5                         01-May-2023 10:49:20
------- converged at time : 0.55                       01-May-2023 10:49:20
    number of iterations   : 4                         01-May-2023 10:49:20
    number of reformations : 4                         01-May-2023 10:49:20
------- converged at time : 0.6                        01-May-2023 10:49:20
    number of iterations   : 4                         01-May-2023 10:49:20
    number of reformations : 4                         01-May-2023 10:49:20
------- converged at time : 0.65                       01-May-2023 10:49:20
    number of iterations   : 5                         01-May-2023 10:49:21
    number of reformations : 5                         01-May-2023 10:49:21
------- converged at time : 0.7                        01-May-2023 10:49:21
    number of iterations   : 4                         01-May-2023 10:49:21
    number of reformations : 4                         01-May-2023 10:49:21
------- converged at time : 0.75                       01-May-2023 10:49:21
    number of iterations   : 5                         01-May-2023 10:49:21
    number of reformations : 5                         01-May-2023 10:49:21
------- converged at time : 0.8                        01-May-2023 10:49:21
    number of iterations   : 5                         01-May-2023 10:49:21
    number of reformations : 5                         01-May-2023 10:49:21
------- converged at time : 0.85                       01-May-2023 10:49:21
    number of iterations   : 5                         01-May-2023 10:49:22
    number of reformations : 5                         01-May-2023 10:49:22
------- converged at time : 0.9                        01-May-2023 10:49:22
    number of iterations   : 5                         01-May-2023 10:49:22
    number of reformations : 5                         01-May-2023 10:49:22
------- converged at time : 0.95                       01-May-2023 10:49:22
    number of iterations   : 5                         01-May-2023 10:49:22
    number of reformations : 5                         01-May-2023 10:49:22
------- converged at time : 1                          01-May-2023 10:49:22
    number of iterations   : 5                         01-May-2023 10:49:23
    number of reformations : 5                         01-May-2023 10:49:23
------- converged at time : 1.05                       01-May-2023 10:49:23
    number of iterations   : 5                         01-May-2023 10:49:23
    number of reformations : 5                         01-May-2023 10:49:23
------- converged at time : 1.1                        01-May-2023 10:49:23
    number of iterations   : 5                         01-May-2023 10:49:23
    number of reformations : 5                         01-May-2023 10:49:23
------- converged at time : 1.15                       01-May-2023 10:49:23
    number of iterations   : 6                         01-May-2023 10:49:24
    number of reformations : 6                         01-May-2023 10:49:24
------- converged at time : 1.2                        01-May-2023 10:49:24
    number of iterations   : 6                         01-May-2023 10:49:24
    number of reformations : 6                         01-May-2023 10:49:24
------- converged at time : 1.25                       01-May-2023 10:49:24
    number of iterations   : 6                         01-May-2023 10:49:25
    number of reformations : 6                         01-May-2023 10:49:25
------- converged at time : 1.3                        01-May-2023 10:49:25
    number of iterations   : 6                         01-May-2023 10:49:25
    number of reformations : 6                         01-May-2023 10:49:25
------- converged at time : 1.35                       01-May-2023 10:49:25
    number of iterations   : 6                         01-May-2023 10:49:25
    number of reformations : 6                         01-May-2023 10:49:25
------- converged at time : 1.4                        01-May-2023 10:49:25
    number of iterations   : 6                         01-May-2023 10:49:26
    number of reformations : 6                         01-May-2023 10:49:26
------- converged at time : 1.45                       01-May-2023 10:49:26
    number of iterations   : 6                         01-May-2023 10:49:26
    number of reformations : 6                         01-May-2023 10:49:26
------- converged at time : 1.5                        01-May-2023 10:49:26
    number of iterations   : 7                         01-May-2023 10:49:27
    number of reformations : 7                         01-May-2023 10:49:27
------- converged at time : 1.55                       01-May-2023 10:49:27
    number of iterations   : 7                         01-May-2023 10:49:27
    number of reformations : 7                         01-May-2023 10:49:27
------- converged at time : 1.6                        01-May-2023 10:49:27
    number of iterations   : 7                         01-May-2023 10:49:27
    number of reformations : 7                         01-May-2023 10:49:27
------- converged at time : 1.65                       01-May-2023 10:49:27
    number of iterations   : 7                         01-May-2023 10:49:28
    number of reformations : 7                         01-May-2023 10:49:28
------- converged at time : 1.7                        01-May-2023 10:49:28
    number of iterations   : 7                         01-May-2023 10:49:28
    number of reformations : 7                         01-May-2023 10:49:28
------- converged at time : 1.75                       01-May-2023 10:49:28
    number of iterations   : 7                         01-May-2023 10:49:29
    number of reformations : 7                         01-May-2023 10:49:29
------- converged at time : 1.8                        01-May-2023 10:49:29
    number of iterations   : 7                         01-May-2023 10:49:29
    number of reformations : 7                         01-May-2023 10:49:29
------- converged at time : 1.85                       01-May-2023 10:49:29
    number of iterations   : 7                         01-May-2023 10:49:30
    number of reformations : 7                         01-May-2023 10:49:30
------- converged at time : 1.9                        01-May-2023 10:49:30
    number of iterations   : 7                         01-May-2023 10:49:30
    number of reformations : 7                         01-May-2023 10:49:30
------- converged at time : 1.95                       01-May-2023 10:49:30
    number of iterations   : 7                         01-May-2023 10:49:30
    number of reformations : 7                         01-May-2023 10:49:30
------- converged at time : 2                          01-May-2023 10:49:30
 Elapsed time : 0:00:14                                01-May-2023 10:49:30
 N O R M A L   T E R M I N A T I O N
# Done                                                 01-May-2023 10:49:30
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
</pre><h2 id="36">Import FEBio results</h2><pre class="codeinput"><span class="keyword">if</span> runFlag==1 <span class="comment">%i.e. a succesful run</span>
</pre><p>Importing nodal displacements from a log file</p><pre class="codeinput">    dataStruct=importFEBio_logfile(fullfile(savePath,febioLogFileName_disp),0,1);

    <span class="comment">%Access data</span>
    N_disp_mat=dataStruct.data; <span class="comment">%Displacement</span>
    timeVec=dataStruct.time; <span class="comment">%Time</span>

    <span class="comment">%Create deformed coordinate set</span>
    V_DEF=N_disp_mat+repmat(V,[1 1 size(N_disp_mat,3)]);
</pre><p>Importing element stress from a log file</p><pre class="codeinput">    dataStruct=importFEBio_logfile(fullfile(savePath,febioLogFileName_sed),0,1);

    <span class="comment">%Access data</span>
    E_sed_mat=dataStruct.data;
    E_sed_mat(isnan(E_sed_mat))=0;
</pre><p>Plotting the simulated results using <tt>anim8</tt> to visualize and animate deformations</p><pre class="codeinput">    [CV]=faceToVertexMeasure(E,V,E_sed_mat(:,:,end));

    <span class="comment">% Create basic view and store graphics handle to initiate animation</span>
    hf=cFigure; <span class="comment">%Open figure</span>
    gtitle([febioFebFileNamePart,<span class="string">': Press play to animate'</span>]);
    title(<span class="string">'Strain energy density'</span>,<span class="string">'Interpreter'</span>,<span class="string">'Latex'</span>)
    gpatch(Fb_full,V_full,<span class="string">'w'</span>,<span class="string">'none'</span>,0.25);
    hp=gpatch(Fb,V_DEF(:,:,end),CV,<span class="string">'none'</span>,1); <span class="comment">%Add graphics object to animate</span>
<span class="comment">%     hp.Marker='.';</span>
<span class="comment">%     hp.MarkerSize=markerSize2;</span>
    hp.FaceColor=<span class="string">'interp'</span>;

    hp2=gpatch(Eg,V_DEF(:,:,end),<span class="string">'w'</span>,<span class="string">'none'</span>,0.5); <span class="comment">%Add graphics object to animate</span>
    Ebb=patchBoundaryLabelEdges(Fb,V,Cb);
    hp3=gpatch(Ebb,V_DEF(:,:,end),<span class="string">'none'</span>,<span class="string">'k'</span>,1,3);
    hp4=gpatch(patchBoundary(Eg),V_DEF(:,:,end),<span class="string">'none'</span>,<span class="string">'kw'</span>,1,3);

    axisGeom(gca,fontSize);
    colormap(spectral(250)); colorbar;
    caxis([0 0.25*max(E_sed_mat(:))]);
    axis(axisLim(V_DEF,V_full)); <span class="comment">%Set axis limits statically</span>
    camlight <span class="string">headlight</span>;

    <span class="comment">% Set up animation features</span>
    animStruct.Time=timeVec; <span class="comment">%The time vector</span>
    <span class="keyword">for</span> qt=1:1:size(N_disp_mat,3) <span class="comment">%Loop over time increments</span>

        [CV]=faceToVertexMeasure(E,V,E_sed_mat(:,:,qt));

        <span class="comment">%Set entries in animation structure</span>
        animStruct.Handles{qt}=[hp hp hp2 hp3 hp4]; <span class="comment">%Handles of objects to animate</span>
        animStruct.Props{qt}={<span class="string">'Vertices'</span>,<span class="string">'CData'</span>,<span class="string">'Vertices'</span>,<span class="string">'Vertices'</span>,<span class="string">'Vertices'</span>}; <span class="comment">%Properties of objects to animate</span>
        animStruct.Set{qt}={V_DEF(:,:,qt),CV,V_DEF(:,:,qt),V_DEF(:,:,qt),V_DEF(:,:,qt)}; <span class="comment">%Property values for to set in order to animate</span>
    <span class="keyword">end</span>
    anim8(hf,animStruct); <span class="comment">%Initiate animation feature</span>
    drawnow;
</pre><img width="100%" height="auto" vspace="5" hspace="5" src="DEMO_febio_0079_tire_load_01_10.jpg" alt=""> <pre class="codeinput"><span class="keyword">end</span>
</pre><p><img vspace="5" hspace="5" src="gibbVerySmall.gif" alt=""> </p><p><i><b>GIBBON</b></i> <a href="www.gibboncode.org">www.gibboncode.org</a></p><p><i>Kevin Mattheus Moerman</i>, <a href="gibbon.toolbox@gmail.com">gibbon.toolbox@gmail.com</a></p><p><i><b>GIBBON footer text</b></i></p><p>License: <a href="https://github.com/gibbonCode/GIBBON/blob/master/LICENSE">https://github.com/gibbonCode/GIBBON/blob/master/LICENSE</a></p><p>GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for image segmentation, image-based modeling, meshing, and finite element analysis.</p><p>Copyright (C) 2006-2022 Kevin Mattheus Moerman and the GIBBON contributors</p><p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p><p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p><p>You should have received a copy of the GNU General Public License along with this program.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% DEMO_febio_0078_actuator_perfect_osmometer_01
% Below is a demonstration for:
% 
% * Building geometry for a cube with hexahedral elements
% * Defining the boundary conditions 
% * Coding the febio structure
% * Running the model
% * Importing and visualizing the displacement and stress results

%% Keywords
%
% * febio_spec version 4.0
% * febio, FEBio
% * tire mesh
% * tetrahedral elements, tet4
% * static, solid
% * displacement logfile
% * stress logfile

%%

clear; close all; clc;

%%
% Plot settings

markerSize=10;
markerSize2=10;
fontSize=15;
faceAlpha1=0.3;
faceAlpha2=0.5;
cMap=gjet(4);

%% Control parameters

% Path names
defaultFolder = fileparts(fileparts(mfilename('fullpath')));
savePath=fullfile(defaultFolder,'data','temp');

% Defining file names
febioFebFileNamePart='tempModel';
febioFebFileName=fullfile(savePath,[febioFebFileNamePart,'.feb']); %FEB file name
febioLogFileName=[febioFebFileNamePart,'.txt']; %FEBio log file name
febioLogFileName_disp=[febioFebFileNamePart,'_disp_out.txt']; %Log file name for exporting displacement
febioLogFileName_force=[febioFebFileNamePart,'_force_out.txt']; %Log file name for exporting force
febioLogFileName_sed=[febioFebFileNamePart,'_stress_out.txt']; %Log file name for exporting strain energy density

tireWidth = 120;
tireRadius = 150;
tireThickness = 8;
threadHeight = 8;
tireBulge=tireWidth/8;
pointSpacing = 8;
tireCircumference = 2*pi.*tireRadius;

numFeatures = 20;
groveWidth = 8;

distKeep=75; %Distance after which model is cropped, empty = full model
displacementVert=0.8*tireThickness;
displacementHor=-tireRadius/20;
contactInitialOffset=0.1;

%Material parameter set
c1=1e-3; %Shear-modulus-like parameter
m1=2; %Material parameter setting degree of non-linearity
k_factor=100; %Bulk modulus factor 
k=c1*k_factor; %Bulk modulus

% FEA control settings
numTimeSteps=20; %Number of time steps desired
max_refs=40; %Max reforms
max_ups=0; %Set to zero to use full-Newton iterations
opt_iter=25; %Optimum number of iterations
max_retries=5; %Maximum number of retires
dtmin=(1/numTimeSteps)/100; %Minimum time step size
dtmax=1/numTimeSteps; %Maximum time step size
runMode='external';%'internal';
min_residual=1e-20;

%Contact parameters
contactPenalty=5;
laugon=0;
minaug=1;
maxaug=10;
fric_coeff=0.5;

%%

tireHalfWidth=tireWidth/2;
featureHeight = (tireCircumference-(numFeatures*groveWidth))./numFeatures;
featureWidth = tireHalfWidth-2*groveWidth;

% Coordinates of 1x1 square
v=[-1 -1 0;...
    1 -1 0;...
    1  1 0;...
    -1  1 0]/2;

% Deformation gradient tensor for shear
f=eye(3,3);
f(1,2)=1;

%Create boundary coordinates
V1=v; %Copy square
V1(:,1)=V1(:,1).*tireCircumference+tireCircumference/2; %Stretch to create circumference
V1(:,2)=V1(:,2).*tireHalfWidth+tireHalfWidth/2; %Stretch to get desired width
V1=evenlySpaceCurve(V1,pointSpacing,'linear',1,1:1:size(v,1)); %Evenly sample
V1=(f*V1')'; %Shear

%Create thread feature
Vf=v; %Copy square
Vf(:,1)=Vf(:,1).*featureHeight; %Stretch to create circumference
Vf(:,2)=Vf(:,2).*(featureWidth+groveWidth/2)+tireHalfWidth/2-groveWidth/4; %Stretch to get desired width
Vf=evenlySpaceCurve(Vf,pointSpacing,'linear',1,1:1:size(v,1)); %Evenly sample
Vf(:,1)=Vf(:,1)+featureHeight/2+groveWidth/2;

VF=cell(1,numFeatures);
for q=1:1:numFeatures
    Vff=Vf;
    Vff(:,1)=Vf(:,1)+(q-1).*(featureHeight+groveWidth); %Shift
    VF{q}=(f*Vff')'; %Shear and store
end

%%


%Defining 4 regions
regionSpec{1}={V1(:,[1 2])};
for q=1:1:numFeatures
    regionSpec{1}{q+1}=VF{q}(:,[1 2]);
end

for q=1:1:numFeatures
    regionSpec{q+1}{1}=VF{q}(:,[1 2]);
end

[Ft,Vt,Ct]=multiRegionTriMesh2D(regionSpec,pointSpacing,0,0);
Vt(:,3)=0;

Fb=fliplr(Ft);
Vb=Vt;
Vb(:,2)=-Vb(:,2);

Cb=Ct;
Cb(Cb>1)=Cb(Cb>1)-1+max(Ct);

[F,V,C]=joinElementSets({Ft,Fb},{Vt,Vb},{Ct,Cb});
[F,V]=mergeVertices(F,V);

%%

cFigure; hold on;
plotV(V1,'r.-','MarkerSize',markerSize);
plotV(VF,'b.-','MarkerSize',markerSize);
gpatch(F,V,C);

axisGeom(gca,fontSize); view(2);
colormap spectral; icolorbar;
gdrawnow;

%%

cMax=max(C);
numVert=size(V,1);
F2=F(C>1,:);
C2=C(C>1,:)+cMax;
Eb1=patchBoundary(F2);

Eb2=Eb1+numVert;
F=[F(C==1,:);F2+numVert];
V=[V;V];
C=[C(C==1,:);C2+max(C(:))];

%%
%

if tireBulge>eps(0)
    w=tireWidth;
    h=tireBulge;
    r=h/2+(w^2/(8*h));
    a=atan((w/2)./(r-h));

    TH = (V(:,2)./tireHalfWidth)*a;
    R = r.*ones(size(V,1),1);
    R(numVert+1:end)=R(numVert+1:end)+threadHeight;
    Z = V(:,1);
    [V(:,1),V(:,2),V(:,3)] = pol2cart(TH,R,Z);
    V=V(:,[3 2 1]);

    V(:,3)=V(:,3)-r+h;
else
    V(numVert+1:end,3)=V(numVert+1:end,3)+threadHeight;
end

%%
cFigure; hold on;
plotV(V1,'r.-','MarkerSize',markerSize);
plotV(VF,'b.-','MarkerSize',markerSize);
gpatch(F,V,C);

axisGeom(gca,fontSize); view(2);
colormap spectral; icolorbar;
gdrawnow;

%%

TH = V(:,1)./tireRadius;
R = tireRadius+V(:,3);

Z = V(:,2);
[V(:,1),V(:,2),V(:,3)] = pol2cart(TH,R,Z);
V=V(:,[1 3 2]); F=fliplr(F);

[Eb1,V1]=patchCleanUnused(Eb1,V);
[Eb2,V2]=patchCleanUnused(Eb2,V);

[F,V,~,indFix]=mergeVertices(F,V);

numSteps=ceil(threadHeight./pointSpacing)+1;


%Create quadrilateral faces
X=linspacen(V1(:,1),V2(:,1),numSteps);
Y=linspacen(V1(:,2),V2(:,2),numSteps);
Z=linspacen(V1(:,3),V2(:,3),numSteps);

Vn=[X(:) Y(:) Z(:)]; %Vertex set
Fn=repmat([fliplr(Eb1) Eb2],numSteps-1,1);
q=repmat(0:(numSteps-2),size(Eb1,1),1);
q=q(:);
Q=[q q q+1 q+1]*size(V1,1);
Fn=Fn+Q;

[Fn,Vn]=quad2tri(Fn,Vn,'a');

%%

[F,V]=patchCleanUnused(F,V);
C(C>1)=2; %Switch to use 2 for all thread profile parts
[F_out,V_out,C_out]=joinElementSets({F,Fn},{V,Vn},{C,max(C(:))+1*ones(size(Fn,1),1)});
[F_out,V_out]=patchCleanUnused(F_out,V_out);
[F_out,V_out]=mergeVertices(F_out,V_out);
Eb_out=patchBoundary(F_out);
%%

cFigure; hold on;
gpatch(F_out,V_out,C_out);
% patchNormPlot(Fq,Vq);
axisGeom(gca,fontSize); camlight headlight;
colormap spectral; icolorbar;
gdrawnow;

%%
% Create inner cylinder
inputStructCyl.cylRadius=tireRadius-tireThickness;
inputStructCyl.numRadial=ceil((2*pi*inputStructCyl.cylRadius)/pointSpacing);
inputStructCyl.cylHeight=tireWidth;
numheight=ceil(tireWidth./pointSpacing);
numheight=numheight+iseven(numheight); %Force uneven
inputStructCyl.numHeight=numheight;
inputStructCyl.meshType='tri';

%%
% Derive patch data for a cylinder
[F_in,V_in]=patchcylinder(inputStructCyl);
V_in=V_in(:,[1 3 2]);
Eb_in=patchBoundary(F_in);
C_in=(max(C_out)+1)*ones(size(F_in,1),1);

%%
inputStructGroup.outputType='label';
G_out=tesgroup(Eb_out,inputStructGroup);
G_in=tesgroup(Eb_in,inputStructGroup);

yMean_out=nan(2,1);
yMean_in=nan(2,1);
for q=1:1:2
    ind_out=Eb_out(G_out==q,:);
    yMean_out(q)=mean(V_out(ind_out(:),2));

    ind_in=Eb_in(G_in==q,:);
    yMean_in(q)=mean(V_in(ind_in(:),2));
end

[~,ind1_out]=min(yMean_out);
[~,ind2_out]=max(yMean_out);
indCurve1_out=edgeListToCurve(Eb_out(G_out==ind1_out,:));
indCurve1_out=indCurve1_out(1:end-1);
indCurve2_out=edgeListToCurve(Eb_out(G_out==ind2_out,:));
indCurve2_out=indCurve2_out(1:end-1);

[~,ind1_in]=min(yMean_in);
[~,ind2_in]=max(yMean_in);
indCurve1_in=edgeListToCurve(Eb_in(G_in==ind1_in,:));
indCurve1_in=indCurve1_in(1:end-1);
indCurve2_in=edgeListToCurve(Eb_in(G_in==ind2_in,:));
indCurve2_in=indCurve2_in(1:end-1);

[Fs1,Vs1]=regionTriMesh2D({V_out(indCurve1_out,[1 3]),V_in(indCurve1_in,[1 3])},pointSpacing,0);
Vs1(:,3)=-tireWidth/2;
Vs1=Vs1(:,[1 3 2]);
Cs1=(max(C_in)+1)*ones(size(Fs1,1),1);

[Fs2,Vs2]=regionTriMesh2D({V_out(indCurve2_out,[1 3]),V_in(indCurve2_in,[1 3])},pointSpacing,0);
Vs2(:,3)=tireWidth/2;
Vs2=Vs2(:,[1 3 2]);
Fs2=fliplr(Fs2);
Cs2=(max(Cs1)+1)*ones(size(Fs2,1),1);

%%

[FT,VT,CT]=joinElementSets({F_out,F_in,Fs1,Fs2},{V_out,V_in,Vs1,Vs2},{C_out,C_in,Cs1,Cs2});
[FT,VT]=patchCleanUnused(FT,VT);
[FT,VT]=mergeVertices(FT,VT);

%%

cFigure; hold on;

gpatch(FT,VT,CT,'none');
patchNormPlot(FT,VT);

axisGeom(gca,fontSize); camlight headlight;
colormap spectral; icolorbar;
gdrawnow;

%%

V_regions=getInnerPoint(FT,VT); %Define region points
V_holes=[]; %Define hole points
[regionTetVolumes]=tetVolMeanEst(FT,VT); %Volume estimate for regular tets
stringOpt='-pq1.2AaY'; %Options for tetgen

%%
% Mesh using TetGen

%Create tetgen input structure
inputStruct.stringOpt=stringOpt; %Tetgen options
inputStruct.Faces=FT; %Boundary faces
inputStruct.Nodes=VT; %Nodes of boundary
inputStruct.faceBoundaryMarker=CT;
inputStruct.regionPoints=V_regions; %Interior points for regions
inputStruct.holePoints=V_holes; %Interior points for holes
inputStruct.regionA=regionTetVolumes; %Desired tetrahedral volume for each region

% Mesh model using tetrahedral elements using tetGen
[meshOutput]=runTetGen(inputStruct); %Run tetGen

%%
% Access mesh output structure

E=meshOutput.elements; %The elements
V=meshOutput.nodes; %The vertices or nodes
Fb=meshOutput.facesBoundary; %The boundary faces
Cb=meshOutput.boundaryMarker; %The boundary markers

%%
% Visualization

hf=cFigure;
subplot(1,2,1); hold on;
title('Input boundaries','FontSize',fontSize);
hp(1)=gpatch(Fb,V,Cb,'k',faceAlpha1);
hp(2)=plotV(V_regions,'r.','MarkerSize',markerSize);
legend(hp,{'Input mesh','Interior point(s)'},'Location','NorthWestOutside');
axisGeom(gca,fontSize); camlight headlight;
colormap(cMap); icolorbar;

hs=subplot(1,2,2); hold on;
title('Tetrahedral mesh','FontSize',fontSize);

% Visualizing using |meshView|
optionStruct.hFig=[hf,hs];
meshView(meshOutput,optionStruct);

axisGeom(gca,fontSize);
gdrawnow;


%%

if ~isempty(distKeep)
    Fb_full=Fb;
    V_full=V;
    [Fb_full,V_full]=patchCleanUnused(Fb_full,V_full);

    VE=patchCentre(E,V);
    logicKeepElements = VE(:,3) <= (min(VE(:,3))+distKeep);
    E=E(logicKeepElements,:);
    indKeepNodes=unique(E);
    logicKeep_Fb=all(ismember(Fb,indKeepNodes),2);
    Fb=Fb(logicKeep_Fb,:);
    Cb=Cb(logicKeep_Fb,:);

    logicKeep_F=all(ismember(F,indKeepNodes),2);
    F=F(logicKeep_F,:);

    [E,V,indFix]=patchCleanUnused(E,V);
    Fb=indFix(Fb);
    F=indFix(F);
    meshOutput.nodes=V;
    meshOutput.facesBoundary=Fb;
    meshOutput.boundaryMarker=Cb;
    meshOutput.faces=F;
    meshOutput.elements=E;
    meshOutput.elementMaterialID=ones(size(E,1),1);    
else
    Fb_full=Fb;
    V_full=V;
end

%%

hf=cFigure;
subplot(1,2,1); hold on;
title('Input boundaries','FontSize',fontSize);
hp(1)=gpatch(Fb,V,Cb,'k',faceAlpha1);
hp(2)=plotV(V_regions,'r.','MarkerSize',markerSize);
legend(hp,{'Input mesh','Interior point(s)'},'Location','NorthWestOutside');
axisGeom(gca,fontSize); camlight headlight;
colormap(cMap); icolorbar;

hs=subplot(1,2,2); hold on;
title('Tetrahedral mesh','FontSize',fontSize);

% Visualizing using |meshView|
optionStruct.hFig=[hf,hs];
meshView(meshOutput,optionStruct);

axisGeom(gca,fontSize);
gdrawnow;

%%

plateDim=[2*tireRadius tireWidth];
plateEl=ceil(plateDim./pointSpacing);
[Eg,Vg]=quadPlate(plateDim,plateEl);
Vg(:,3)=Vg(:,3)+min(VT(:,3))-contactInitialOffset;
center_of_mass=mean(Vg,1);

%% Joining node sets
Eg=Eg+size(V,1); %Fixed element indices
V=[V;Vg;]; %Combined node sets

%%

cFigure; hold on;
hp(1)=gpatch(Fb,V,Cb,'k',faceAlpha1);
hp(2)=gpatch(Eg,V,'kw','k',faceAlpha1);
% legend(hp,{'Input mesh','Interior point(s)'},'Location','NorthWestOutside');
axisGeom(gca,fontSize); camlight headlight;
colormap(cMap); icolorbar;
gdrawnow;

%% Define contact surfaces

% The rigid master surface of the sphere
F_contact_secondary=Eg;

% The deformable slave surface of the slab
logicContactSurf1=Cb==2;
F_contact_primary=fliplr(Fb(logicContactSurf1,:));

% Plotting surface models
cFigure; hold on;
title('Contact sets and normal directions','FontSize',fontSize);

gpatch(Fb,V,'kw','none',faceAlpha2); 
hl(1)=gpatch(F_contact_secondary,V,'g','k',1); 
patchNormPlot(F_contact_secondary,V);
hl(2)=gpatch(F_contact_primary,V,'b','k',1);
patchNormPlot(F_contact_primary,V);

legend(hl,{'Secondary','Primary'});

axisGeom(gca,fontSize);
camlight headlight;
drawnow;

%% Define boundary conditions

%Supported nodes
bcSupportList=unique(Fb(Cb==4,:));

%%
% Visualize BC's
hf=cFigure;
title('Boundary conditions model','FontSize',fontSize);
xlabel('X','FontSize',fontSize); ylabel('Y','FontSize',fontSize); zlabel('Z','FontSize',fontSize);
hold on;

gpatch(Fb,V,'w','none',faceAlpha2); 

hl2(1)=gpatch(Eg,V,'gw','k',1); 
hl2(2)=plotV(V(bcSupportList,:),'k.','MarkerSize',markerSize);

legend(hl2,{'Rigid body plate','BC support'});

axisGeom(gca,fontSize);
camlight headlight;
drawnow;


%% Defining the FEBio input structure
% See also |febioStructTemplate| and |febioStruct2xml| and the FEBio user
% manual.

%Get a template with default settings 
[febio_spec]=febioStructTemplate;

%febio_spec version 
febio_spec.ATTR.version='4.0'; 

%Module section
febio_spec.Module.ATTR.type='solid'; 

%Create control structure for use by all steps
stepStruct.Control.time_steps=numTimeSteps;
stepStruct.Control.step_size=1/numTimeSteps;
stepStruct.Control.solver.max_refs=max_refs;
stepStruct.Control.time_stepper.dtmin=dtmin;
stepStruct.Control.time_stepper.dtmax=dtmax; 
stepStruct.Control.time_stepper.max_retries=max_retries;
stepStruct.Control.time_stepper.opt_iter=opt_iter;

%Add template based default settings to proposed control section
[stepStruct.Control]=structComplete(stepStruct.Control,febio_spec.Control,1); %Complement provided with default if missing

%Remove control field (part of template) since step specific control sections are used
febio_spec=rmfield(febio_spec,'Control'); 

febio_spec.Step.step{1}.Control=stepStruct.Control;
febio_spec.Step.step{1}.ATTR.id=1;
febio_spec.Step.step{2}.Control=stepStruct.Control;
febio_spec.Step.step{2}.ATTR.id=2;
    
%Material section
materialName1='Material1';
febio_spec.Material.material{1}.ATTR.name=materialName1;
febio_spec.Material.material{1}.ATTR.type='Ogden';
febio_spec.Material.material{1}.ATTR.id=1;
febio_spec.Material.material{1}.c1=c1;
febio_spec.Material.material{1}.m1=m1;
febio_spec.Material.material{1}.c2=c1;
febio_spec.Material.material{1}.m2=-m1;
febio_spec.Material.material{1}.k=k;

materialName2='Material2';
febio_spec.Material.material{2}.ATTR.name=materialName2;
febio_spec.Material.material{2}.ATTR.type='rigid body';
febio_spec.Material.material{2}.ATTR.id=2;
febio_spec.Material.material{2}.density=1;
febio_spec.Material.material{2}.center_of_mass=center_of_mass;

%Mesh section
% -> Nodes
febio_spec.Mesh.Nodes{1}.ATTR.name='nodeSet_all'; %The node set name
febio_spec.Mesh.Nodes{1}.node.ATTR.id=(1:size(V,1))'; %The node id's
febio_spec.Mesh.Nodes{1}.node.VAL=V; %The nodel coordinates

% -> Elements
partName1='Part1';
febio_spec.Mesh.Elements{1}.ATTR.name=partName1; %Name of this part
febio_spec.Mesh.Elements{1}.ATTR.type='tet4'; %Element type 
febio_spec.Mesh.Elements{1}.elem.ATTR.id=(1:1:size(E,1))'; %Element id's
febio_spec.Mesh.Elements{1}.elem.VAL=E; %The element matrix

partName2='Part2';
febio_spec.Mesh.Elements{2}.ATTR.name=partName2; %Name of this part
febio_spec.Mesh.Elements{2}.ATTR.type='quad4'; %Element type 
febio_spec.Mesh.Elements{2}.elem.ATTR.id=size(E,1)+(1:1:size(Eg,1))'; %Element id's
febio_spec.Mesh.Elements{2}.elem.VAL=Eg; %The element matrix

% -> NodeSets
nodeSetName1='bcSupportList';
febio_spec.Mesh.NodeSet{1}.ATTR.name=nodeSetName1;
febio_spec.Mesh.NodeSet{1}.VAL=mrow(bcSupportList);

%MeshDomains section
febio_spec.MeshDomains.SolidDomain.ATTR.name=partName1;
febio_spec.MeshDomains.SolidDomain.ATTR.mat=materialName1;

febio_spec.MeshDomains.ShellDomain.ATTR.name=partName2;
febio_spec.MeshDomains.ShellDomain.ATTR.mat=materialName2;

% -> Surfaces
surfaceName1='contactSurface1';
febio_spec.Mesh.Surface{1}.ATTR.name=surfaceName1;
febio_spec.Mesh.Surface{1}.quad4.ATTR.id=(1:1:size(F_contact_secondary,1))';
febio_spec.Mesh.Surface{1}.quad4.VAL=F_contact_secondary;

surfaceName2='contactSurface2';
febio_spec.Mesh.Surface{2}.ATTR.name=surfaceName2;
febio_spec.Mesh.Surface{2}.tri3.ATTR.id=(1:1:size(F_contact_primary,1))';
febio_spec.Mesh.Surface{2}.tri3.VAL=F_contact_primary;

% -> Surface pairs
febio_spec.Mesh.SurfacePair{1}.ATTR.name='Contact1';
febio_spec.Mesh.SurfacePair{1}.primary=surfaceName2;
febio_spec.Mesh.SurfacePair{1}.secondary=surfaceName1;

%Boundary condition section 
% -> Fix boundary conditions
febio_spec.Boundary.bc{1}.ATTR.name='zero_displacement_xyz';
febio_spec.Boundary.bc{1}.ATTR.type='zero displacement';
febio_spec.Boundary.bc{1}.ATTR.node_set=nodeSetName1;
febio_spec.Boundary.bc{1}.x_dof=1;
febio_spec.Boundary.bc{1}.y_dof=1;
febio_spec.Boundary.bc{1}.z_dof=1;

%Rigid section 
% -> Prescribed rigid body boundary conditions
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.ATTR.name='RigidFix_1';
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.ATTR.type='rigid_fixed';
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.rb=2;
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.Rx_dof=1;
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.Ry_dof=1;
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.Rz_dof=0;
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.Ru_dof=1;
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.Rv_dof=1;
febio_spec.Step.step{1}.Rigid.rigid_bc{1}.Rw_dof=1;

febio_spec.Step.step{1}.Rigid.rigid_bc{2}.ATTR.name='RigidPrescribe';
febio_spec.Step.step{1}.Rigid.rigid_bc{2}.ATTR.type='rigid_displacement';
febio_spec.Step.step{1}.Rigid.rigid_bc{2}.rb=2;
febio_spec.Step.step{1}.Rigid.rigid_bc{2}.dof='z';
febio_spec.Step.step{1}.Rigid.rigid_bc{2}.value.ATTR.lc=1;
febio_spec.Step.step{1}.Rigid.rigid_bc{2}.value.VAL=(displacementVert+contactInitialOffset);

febio_spec.Step.step{2}.Rigid.rigid_bc{1}.ATTR.name='RigidFix_1';
febio_spec.Step.step{2}.Rigid.rigid_bc{1}.ATTR.type='rigid_fixed';
febio_spec.Step.step{2}.Rigid.rigid_bc{1}.Rx_dof=0;
febio_spec.Step.step{2}.Rigid.rigid_bc{1}.Ry_dof=1;
febio_spec.Step.step{2}.Rigid.rigid_bc{1}.Rz_dof=1;
febio_spec.Step.step{2}.Rigid.rigid_bc{1}.Ru_dof=1;
febio_spec.Step.step{2}.Rigid.rigid_bc{1}.Rv_dof=1;
febio_spec.Step.step{2}.Rigid.rigid_bc{1}.Rw_dof=1;

febio_spec.Step.step{2}.Rigid.rigid_bc{2}.ATTR.name='RigidPrescribe';
febio_spec.Step.step{2}.Rigid.rigid_bc{2}.ATTR.type='rigid_displacement';
febio_spec.Step.step{2}.Rigid.rigid_bc{2}.rb=2;
febio_spec.Step.step{2}.Rigid.rigid_bc{2}.dof='x';
febio_spec.Step.step{2}.Rigid.rigid_bc{2}.value.ATTR.lc=2;
febio_spec.Step.step{2}.Rigid.rigid_bc{2}.value.VAL=displacementHor;
febio_spec.Step.step{2}.Rigid.rigid_bc{2}.relative=1;

%Contact section
febio_spec.Contact.contact{1}.ATTR.type='sliding-elastic';
febio_spec.Contact.contact{1}.ATTR.surface_pair=febio_spec.Mesh.SurfacePair{1}.ATTR.name;
febio_spec.Contact.contact{1}.two_pass=0;
febio_spec.Contact.contact{1}.laugon=laugon;
febio_spec.Contact.contact{1}.tolerance=0.2;
febio_spec.Contact.contact{1}.gaptol=0;
febio_spec.Contact.contact{1}.minaug=minaug;
febio_spec.Contact.contact{1}.maxaug=maxaug;
febio_spec.Contact.contact{1}.search_tol=0.01;
febio_spec.Contact.contact{1}.search_radius=0.1*sqrt(sum((max(V,[],1)-min(V,[],1)).^2,2));
febio_spec.Contact.contact{1}.symmetric_stiffness=0;
febio_spec.Contact.contact{1}.auto_penalty=1;
febio_spec.Contact.contact{1}.penalty=contactPenalty;
febio_spec.Contact.contact{1}.fric_coeff=fric_coeff;

%LoadData section
% -> load_controller
febio_spec.LoadData.load_controller{1}.ATTR.name='LC_1';
febio_spec.LoadData.load_controller{1}.ATTR.id=1;
febio_spec.LoadData.load_controller{1}.ATTR.type='loadcurve';
febio_spec.LoadData.load_controller{1}.interpolate='LINEAR';
%febio_spec.LoadData.load_controller{1}.extend='CONSTANT';
febio_spec.LoadData.load_controller{1}.points.pt.VAL=[0 0; 1 1; 2 1];

febio_spec.LoadData.load_controller{2}.ATTR.name='LC_2';
febio_spec.LoadData.load_controller{2}.ATTR.id=2;
febio_spec.LoadData.load_controller{2}.ATTR.type='loadcurve';
febio_spec.LoadData.load_controller{2}.interpolate='LINEAR';
%febio_spec.LoadData.load_controller{2}.extend='CONSTANT';
febio_spec.LoadData.load_controller{2}.points.pt.VAL=[0 0; 1 0; 2 1];

%Output section 
% -> log file
febio_spec.Output.logfile.ATTR.file=febioLogFileName;
febio_spec.Output.logfile.node_data{1}.ATTR.file=febioLogFileName_disp;
febio_spec.Output.logfile.node_data{1}.ATTR.data='ux;uy;uz';
febio_spec.Output.logfile.node_data{1}.ATTR.delim=',';

febio_spec.Output.logfile.node_data{2}.ATTR.file=febioLogFileName_force;
febio_spec.Output.logfile.node_data{2}.ATTR.data='Rx;Ry;Rz';
febio_spec.Output.logfile.node_data{2}.ATTR.delim=',';

febio_spec.Output.logfile.element_data{1}.ATTR.file=febioLogFileName_sed;
febio_spec.Output.logfile.element_data{1}.ATTR.data='sed';
febio_spec.Output.logfile.element_data{1}.ATTR.delim=',';

% Plotfile section
febio_spec.Output.plotfile.compression=0;

%% Quick viewing of the FEBio input file structure
% The |febView| function can be used to view the xml structure in a MATLAB
% figure window. 

%%
% |febView(febio_spec); %Viewing the febio file|

%% Exporting the FEBio input file
% Exporting the febio_spec structure to an FEBio input file is done using
% the |febioStruct2xml| function. 

febioStruct2xml(febio_spec,febioFebFileName); %Exporting to file and domNode

%% Running the FEBio analysis
% To run the analysis defined by the created FEBio input file the
% |runMonitorFEBio| function is used. The input for this function is a
% structure defining job settings e.g. the FEBio input file name. The
% optional output runFlag informs the user if the analysis was run
% succesfully. 

febioAnalysis.run_filename=febioFebFileName; %The input file name
febioAnalysis.run_logname=febioLogFileName; %The name for the log file
febioAnalysis.disp_on=1; %Display information on the command window
febioAnalysis.runMode=runMode;

[runFlag]=runMonitorFEBio(febioAnalysis);%START FEBio NOW!!!!!!!!

%% Import FEBio results 

if runFlag==1 %i.e. a succesful run
    
    %% 
    % Importing nodal displacements from a log file
    dataStruct=importFEBio_logfile(fullfile(savePath,febioLogFileName_disp),0,1);
    
    %Access data
    N_disp_mat=dataStruct.data; %Displacement
    timeVec=dataStruct.time; %Time
    
    %Create deformed coordinate set
    V_DEF=N_disp_mat+repmat(V,[1 1 size(N_disp_mat,3)]);
            
    %%
    % Importing element stress from a log file
    dataStruct=importFEBio_logfile(fullfile(savePath,febioLogFileName_sed),0,1);     
    
    %Access data
    E_sed_mat=dataStruct.data;
    E_sed_mat(isnan(E_sed_mat))=0;
    
        %% 
    % Plotting the simulated results using |anim8| to visualize and animate
    % deformations 
    
    [CV]=faceToVertexMeasure(E,V,E_sed_mat(:,:,end));
    
    % Create basic view and store graphics handle to initiate animation
    hf=cFigure; %Open figure  
    gtitle([febioFebFileNamePart,': Press play to animate']);
    title('Strain energy density','Interpreter','Latex')
    gpatch(Fb_full,V_full,'w','none',0.25);
    hp=gpatch(Fb,V_DEF(:,:,end),CV,'none',1); %Add graphics object to animate
%     hp.Marker='.';
%     hp.MarkerSize=markerSize2;
    hp.FaceColor='interp';
        
    hp2=gpatch(Eg,V_DEF(:,:,end),'w','none',0.5); %Add graphics object to animate
    Ebb=patchBoundaryLabelEdges(Fb,V,Cb);
    hp3=gpatch(Ebb,V_DEF(:,:,end),'none','k',1,3); 
    hp4=gpatch(patchBoundary(Eg),V_DEF(:,:,end),'none','kw',1,3); 
    
    axisGeom(gca,fontSize); 
    colormap(spectral(250)); colorbar;
    caxis([0 0.25*max(E_sed_mat(:))]);    
    axis(axisLim(V_DEF,V_full)); %Set axis limits statically    
    camlight headlight;        
        
    % Set up animation features
    animStruct.Time=timeVec; %The time vector    
    for qt=1:1:size(N_disp_mat,3) %Loop over time increments        
        
        [CV]=faceToVertexMeasure(E,V,E_sed_mat(:,:,qt));
        
        %Set entries in animation structure
        animStruct.Handles{qt}=[hp hp hp2 hp3 hp4]; %Handles of objects to animate
        animStruct.Props{qt}={'Vertices','CData','Vertices','Vertices','Vertices'}; %Properties of objects to animate
        animStruct.Set{qt}={V_DEF(:,:,qt),CV,V_DEF(:,:,qt),V_DEF(:,:,qt),V_DEF(:,:,qt)}; %Property values for to set in order to animate
    end        
    anim8(hf,animStruct); %Initiate animation feature    
    drawnow;
    
end

%% 
%
% <<gibbVerySmall.gif>>
% 
% _*GIBBON*_ 
% <www.gibboncode.org>
% 
% _Kevin Mattheus Moerman_, <gibbon.toolbox@gmail.com>
 
%% 
% _*GIBBON footer text*_ 
% 
% License: <https://github.com/gibbonCode/GIBBON/blob/master/LICENSE>
% 
% GIBBON: The Geometry and Image-based Bioengineering add-On. A toolbox for
% image segmentation, image-based modeling, meshing, and finite element
% analysis.
% 
% Copyright (C) 2006-2022 Kevin Mattheus Moerman and the GIBBON contributors
% 
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

##### SOURCE END #####
--></body></html>
